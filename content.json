{"meta":{"title":"Coding...Coding...","subtitle":"个人博客","description":"这是我的个人博客","author":"KingIsHappy","url":"https://blueleer.github.io"},"pages":[{"title":"about","date":"2018-04-07T04:57:35.000Z","updated":"2018-04-07T05:26:33.518Z","comments":true,"path":"about/index.html","permalink":"https://blueleer.github.io/about/index.html","excerpt":"","text":"QQ : 251668577WeChat : LeeWangJJ"},{"title":"","date":"2018-04-04T19:57:24.000Z","updated":"2018-04-06T13:14:59.072Z","comments":false,"path":"categories/index.html","permalink":"https://blueleer.github.io/categories/index.html","excerpt":"","text":""},{"title":"","date":"2018-04-06T13:14:06.586Z","updated":"2018-04-06T13:14:06.586Z","comments":false,"path":"tags/index.html","permalink":"https://blueleer.github.io/tags/index.html","excerpt":"","text":""}],"posts":[{"title":"回车和换行","slug":"回车和换行","date":"2018-04-07T03:43:40.000Z","updated":"2018-04-07T04:03:02.776Z","comments":true,"path":"2018/04/07/回车和换行/","link":"","permalink":"https://blueleer.github.io/2018/04/07/回车和换行/","excerpt":"","text":"今天在做爬虫的时候,需要匹配下面Title中的内容,发现写的正则表达式question_link(.)&gt;(\\n)(.+)(\\n*)&lt;竟然匹配不上里面的中文,原来在win系统中文件中的换行其实包含了两个字符, /CR(回车),/LF(换行),这两个”.”都是匹配不上的. 123&lt;h2&gt;&lt;a class=\"question_link\" href=\"/question/270597366/answer/355546388\" data-id=\"22407872\" data-za-element-name=\"Title\"&gt;如何看待星巴克被指含有致癌物质（丙烯酰胺Acrylamide）？&lt;/a&gt;&lt;/h2&gt; 修改成下面,成功匹配 1question_link(.*)&gt;(\\r)(\\n)(.*) 完整代码为: 1234567891011121314// 其中这段是从文件中摘录的,文件中查看特殊符号显示了换行包含两个字符 一个回车一个换行String s = \"&lt;h2&gt;&lt;a class=\"question_link\" href=\"/question/270597366/answer/355546388\" data-id=\"22407872\" data-za-element-name=\"Title\"&gt;如何看待星巴克被指含有致癌物质（丙烯酰胺Acrylamide）？&lt;/a&gt;&lt;/h2&gt;\" String regex = \"question_link(.*)&gt;(\\\\r)(\\\\n)(.*)\";Pattern pattern = Pattern.compile(regex);Matcher matcher = pattern.matcher(sb.toString());matcher.find();String group = matcher.group(4);System.out.println(group);// 输出:// 如何看待星巴克被指含有致癌物质（丙烯酰胺Acrylamide）？ 小示例: 123456789String s1 = \"\\r1234\\r567\";String s2 = \"\\n12345\";System.out.println(s1);System.out.println(s2);// 输出:56712345 再次强调,回车和换行,”.”都不能匹配 1234567String s1 = \"\\r1234\\r567\";String regex = \".*\";String regex1 = \"\\\\r.*\";Pattern pattern = Pattern.compile(regex1); // 换成regex则下面的输出为空,也就是不能匹配Matcher matcher = pattern.matcher(s1);matcher.find();System.out.println(matcher.group()); 更多知识请参考: 终于搞懂了回车与换行的区别","categories":[{"name":"java","slug":"java","permalink":"https://blueleer.github.io/categories/java/"},{"name":"其他","slug":"java/其他","permalink":"https://blueleer.github.io/categories/java/其他/"}],"tags":[{"name":"计算机","slug":"计算机","permalink":"https://blueleer.github.io/tags/计算机/"},{"name":"其他","slug":"其他","permalink":"https://blueleer.github.io/tags/其他/"}]},{"title":"hexo主题之next主题的配置","slug":"hexo主题之next主题的配置","date":"2018-04-06T13:46:36.000Z","updated":"2018-04-06T15:48:33.471Z","comments":true,"path":"2018/04/06/hexo主题之next主题的配置/","link":"","permalink":"https://blueleer.github.io/2018/04/06/hexo主题之next主题的配置/","excerpt":"","text":"关于 hexo 主题之next主题 GiuHub地址 Next主题配置官网文档 hexo的next主题个性化教程:打造炫酷网站 另外附上大致的使用GitHub Pages建站的流程: 注册GitHub账号 创建 YourName.github.io库,GitHub默认把它当做静态html托管仓库(我们实际上也仅仅是在它上面托管我们的静态网页,它还能够识别解析css和js文件) 在GitHub上生成 SSH Keys (后面使用的hexo在本地拥有了一个SSH Keys的拷贝,这样就可以实现快速部署到pages仓库) 安装hexo,推荐参考 hexo官方文档 这样可以少走很多弯路,遇到问题了再去查解决方法 然后就可以找一款自己喜欢的主题啦 hexo官网,这上面有很全的plug插件和theme主题,也可以参考别人的推荐,我就用的是GitHub上star数醉的的一款next","categories":[{"name":"其他","slug":"其他","permalink":"https://blueleer.github.io/categories/其他/"}],"tags":[{"name":"hexo主题配置","slug":"hexo主题配置","permalink":"https://blueleer.github.io/tags/hexo主题配置/"}]},{"title":"Java中的Pattern、Matcher、常用的正则表达式","slug":"Java中的Pattern、Matcher、常用的正则表达式","date":"2018-04-06T08:20:55.000Z","updated":"2018-04-06T08:23:37.992Z","comments":true,"path":"2018/04/06/Java中的Pattern、Matcher、常用的正则表达式/","link":"","permalink":"https://blueleer.github.io/2018/04/06/Java中的Pattern、Matcher、常用的正则表达式/","excerpt":"","text":"Java中的Pattern、Matcher、常用的正则表达式Java中的字符串已经有了直接调用简单匹配方法,matches方法(内部也是使用了Pattern.matches()方法) 123456String s = \"Java12Java34\";// 精确匹配,返回regex和s串是否完全匹配boolean isMatch = s.matches(\"Java\"); // 这里返回false// 在一定的范围内进行匹配// 参数的含义: 是否忽略大小写,s串的起始位置(offset),regex字符串,regex字符串的起始位置,取regex串的长度boolean isMatch2 = s.regionMatches(true, 6, \"Java\", 0, \"Java\".length()); // 返回true 但是很多时候String自带的这些方法不足于我们使用,此时Java中提供了Pattern和Matcher两个与正则表达式相关的类供我们使用 Pattern类12String regex = \"Java\";Pattern pattern = Pattern.compile(regex); Pattern.matches()静态方法123String regex = \"Java\";String s2 = \"Java123Java456Java789\";Pattern.matches(\"Java\", s2); // 注意这里也是全串精确匹配 其实这个方法和String中的matches()方法一致,其实String.matches()方法内部就是调用了此方法 split顾名思义就是分割字符串的方法,其中regex就是分割字符串的”刀”,注意当regex和字符串开始或者结尾部分匹配的时候会得到空字符串 123456789101112String regex = \"Java\";String s2 = \"Java123Java456Java789\";Pattern pattern = Pattern.compile(\"Java\");// split(input),分割字符串得到String数组String[] split = pattern.split(s2);System.out.println(split.length); // 输出3,[空串,123,456,789]String[] split1 = pattern.split(regex, 2);System.out.println(\"split1的长度为 : \" + split1.length); // 输出2,[空串,123Java456Java789],想想limit设置成3会怎样?// 注意:limit设置成0或者负数,效果默认一样,也就是和pattern.split(s2)一样 关于Pattern只介绍这两个方法,其他的可以自行创建demo试试 Matcher类1234String regex = \"Java\";String s = \"Java123Java456Java789\";Pattern pattern = Pattern.compile(regex);Matcher matcher1 = pattern.matcher(s); find()：尝试查找与该模式匹配的输入序列的的下一个子序列。重要,下面重点说 find(int start)：重置此匹配器，然后尝试查找匹配该模式、从指定索引开始的输入序列的下一个子序列。 group()：匹配成功返回的组,重要,下面重点说 start()：返回先前匹配的起始位置的索引。 end()：返回最后匹配字符的索引加一。 matches()：尝试将整个区域与模式匹配。匹配成功返回true lookingAt()：尝试将从区域开头开始的输入序列与该模式匹配。 replaceFirst()：替换掉匹配的第一个子序列 replaceAll()：替换掉匹配的全部子序列 appendReplacement：重要，下面重点说 appendTail(StringBuffer buf)：重要，下面重点说 reset():重置匹配器,从起始位置重新开始 reset(CharSequence input):重置匹配器,放入新的待匹配的串 部分方法解析 find()方法 注意:该方法尝试查找与该模式匹配的输入序列的下一个子序列.此方法从匹配器区域的开头开始，如果该方法的前一次调用成功了,并且从那时开始匹配器没有被重置，则从以前匹配操作没有匹配的第一个字符开始 12345678910111213String regex = \"Java.\";String s = \"Java1Java2\";Pattern pattern = Pattern.compile(regex);Matcher matcher1 = pattern.matcher(s);matcher1.find(); // 这里返回true// 其实此时我们可以使用下面的方式来循环获取匹配得到的子串while(matcher.find)&#123; // 循环查找,本次查找结束了,下次如果想获得查找结果应该重新执行find()方法 System.out.println(matcher.group()); // 关于group方法将在下面介绍&#125;// 上面的方法输出:Java1Java2 group()方法 这里介绍下组的概念：组是用括号划分的正则表达式，可以根据组的编号来引用这个组。组号为0表示整个表达式，组号为1表示被第一对括号括起的组，依次类推，例如A(B(C))D，组0是ABCD，组1是BC，组2是C。 Matcher类提供了start()，end()，group()分别用于返回字符串的起始索引，结束索引，以及匹配到到的字符串。 12345678String regex = \"(Java).*(Java)\";String s = \"Java123Java456\";Pattern pattern = Pattern.compile(regex);Matcher matcher2 = pattern.matcher(s);matcher2.find(); // 注意,这里需要先执行find方法System.out.println(matcher2.group()); // 如果find()方法执行返回true,则group()或者group(0)代表整个字符串s:Java123Java456System.out.println(matcher2.group(1)); // 输出 Java123System.out.println(matcher2.group(2)); // 输出Java456 appendReplacement(StringBuffer sb,String replacement)方法 先从字符串中执行查找,查找到了,替换成replacement,并从开始匹配的位置处将字符串写入StringBuffer中,示例入下: 12345678910111213141516171819String s = \"2018-4-10 15-45-30\";String regex = \"-\";Pattern pattern = Pattern.compile(regex);Matcher matcher = pattern.matcher(s);StringBuffer sb = new StringBuffer();matcher.find();matcher.appendReplacement(sb, \":\");System.out.println(sb.toString());matcher.find();matcher.appendReplacement(sb, \":\");System.out.println(sb.toString());matcher.find();matcher.appendReplacement(sb, \":\");System.out.println(sb.toString());输出入下:2018:2018:4:2018:4:10 15: 可以看到,它比String的replaceAll()或者replace()方法更加灵活 正则表达式语法请参考 Java 正则表达式","categories":[{"name":"Java","slug":"Java","permalink":"https://blueleer.github.io/categories/Java/"}],"tags":[{"name":"Java","slug":"Java","permalink":"https://blueleer.github.io/tags/Java/"},{"name":"Java正则表达式","slug":"Java正则表达式","permalink":"https://blueleer.github.io/tags/Java正则表达式/"}]},{"title":"在活动中使用菜单Menu和PopupMenu","slug":"在活动中使用菜单Menu和PopupMenu","date":"2016-11-01T15:55:32.000Z","updated":"2018-04-06T16:05:39.468Z","comments":true,"path":"2016/11/01/在活动中使用菜单Menu和PopupMenu/","link":"","permalink":"https://blueleer.github.io/2016/11/01/在活动中使用菜单Menu和PopupMenu/","excerpt":"","text":"在Activity中使用Menu和PopupMenu流程: 点击res目录新建Android resouce file文件,选择resoucetype为menu,然后可以创建如下菜单的布局: 12345678&lt;?xml version=\"1.0\" encoding=\"utf-8\"?&gt;&lt;menu xmlns:android=\"http://schemas.android.com/apk/res/android\"&gt; &lt;item android:id=\"@+id/refresh_item\" android:title=\"刷新\"/&gt; &lt;item android:id=\"@+id/change_city\" android:title=\"选择城市\"/&gt;&lt;/menu&gt; 然后在活动中重写onCreateOptionsMenu(Menu menu)方法: 12345public boolean onCreateOptionsMenu(Menu menu) &#123; //R.menu.menu就是menu的布局文件 getMenuInflater().inflate(R.menu.menu,menu); return true;&#125; ​ 然后在手机上点击”菜单”就可以弹出菜单了,该菜单是从屏幕底部弹出的. 当然我们也可以为点击菜单上的项目注册响应事件,通过重写onOptionsItemSelected()方法: 1234567891011public boolean onOptionsItemSelected(MenuItem item) &#123; switch(item.getItemId())&#123; case R.id.refresh_item: //加入逻辑 break; case R.id.change_city: //加入逻辑 break; &#125; return super.onOptionsItemSelected(item);&#125; 有时候我们希望通过点击屏幕上自己定义的一个组件弹出一个菜单来,并且这个菜单就在这个组件的周围,那么可以这么来写(还是使用刚刚我们定义的menu布局文件): 12345678910Button button = (Button)findViewById(R.id.refresh);//点击这个按钮就能弹出一个菜单来button.setOnClickListener(new View.OnClickListener()&#123; @Override public void onClick(View view) &#123; PopupMenu popupMenu = new PopupMenu(MainActivity.this,view); popupMenu.getMenuInflater().inflate(R.menu.menu,popupMenu.getMenu()); popupMenu.show(); &#125;&#125;); ​ ​ 在刷新按钮的周围弹出了一个菜单 ​ 当然我们也可以为PopupMenu响应点击事件: 12345678910popupMenu.setOnMenuItemClickListener(new PopupMenu.OnMenuItemClickListener() &#123; @Override public boolean onMenuItemClick(MenuItem menuItem) &#123; switch(menuItem.getId())&#123; case R.id.refresh_item //加入自己的逻辑(点击以后发生的事件) &#125; return false; &#125;&#125;);","categories":[{"name":"Android","slug":"Android","permalink":"https://blueleer.github.io/categories/Android/"}],"tags":[{"name":"Android","slug":"Android","permalink":"https://blueleer.github.io/tags/Android/"}]}]}