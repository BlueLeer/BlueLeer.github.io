{"meta":{"title":"Coding...Coding...","subtitle":"个人博客","description":"这是我的个人博客","author":"KingIsHappy","url":"https://blueleer.github.io"},"pages":[{"title":"about","date":"2018-04-07T04:57:35.000Z","updated":"2018-04-07T05:26:33.518Z","comments":true,"path":"about/index.html","permalink":"https://blueleer.github.io/about/index.html","excerpt":"","text":"QQ : 251668577WeChat : LeeWangJJ"},{"title":"","date":"2018-04-04T19:57:24.000Z","updated":"2018-04-06T13:14:59.072Z","comments":false,"path":"categories/index.html","permalink":"https://blueleer.github.io/categories/index.html","excerpt":"","text":""},{"title":"","date":"2018-04-06T13:14:06.586Z","updated":"2018-04-06T13:14:06.586Z","comments":false,"path":"tags/index.html","permalink":"https://blueleer.github.io/tags/index.html","excerpt":"","text":""}],"posts":[{"title":"SSH框架学习之Struts2--第一天","slug":"SSH框架学习之Struts2-第一天","date":"2018-04-08T05:10:07.000Z","updated":"2018-04-08T08:30:50.604Z","comments":true,"path":"2018/04/08/SSH框架学习之Struts2-第一天/","link":"","permalink":"https://blueleer.github.io/2018/04/08/SSH框架学习之Struts2-第一天/","excerpt":"","text":"","categories":[{"name":"Java","slug":"Java","permalink":"https://blueleer.github.io/categories/Java/"}],"tags":[{"name":"Struts2","slug":"Struts2","permalink":"https://blueleer.github.io/tags/Struts2/"}]},{"title":"回车和换行","slug":"回车和换行","date":"2018-04-07T03:43:40.000Z","updated":"2018-04-07T17:06:23.583Z","comments":true,"path":"2018/04/07/回车和换行/","link":"","permalink":"https://blueleer.github.io/2018/04/07/回车和换行/","excerpt":"","text":"今天在做爬虫的时候,需要匹配下面Title中的内容,发现写的正则表达式question_link(.)&gt;(\\n)(.+)(\\n*)&lt;竟然匹配不上里面的中文,原来在win系统中文件中的换行其实包含了两个字符, /CR(回车),/LF(换行),这两个”.”都是匹配不上的. 123&lt;h2&gt;&lt;a class=\"question_link\" href=\"/question/270597366/answer/355546388\" data-id=\"22407872\" data-za-element-name=\"Title\"&gt;如何看待星巴克被指含有致癌物质（丙烯酰胺Acrylamide）？&lt;/a&gt;&lt;/h2&gt; 修改成下面,成功匹配 1question_link(.*)&gt;(\\r)(\\n)(.*) 完整代码为: 1234567891011121314// 其中这段是从文件中摘录的,文件中查看特殊符号显示了换行包含两个字符 一个回车一个换行String s = \"&lt;h2&gt;&lt;a class=\"question_link\" href=\"/question/270597366/answer/355546388\" data-id=\"22407872\" data-za-element-name=\"Title\"&gt;如何看待星巴克被指含有致癌物质（丙烯酰胺Acrylamide）？&lt;/a&gt;&lt;/h2&gt;\" String regex = \"question_link(.*)&gt;(\\\\r)(\\\\n)(.*)\";Pattern pattern = Pattern.compile(regex);Matcher matcher = pattern.matcher(sb.toString());matcher.find();String group = matcher.group(4);System.out.println(group);// 输出:// 如何看待星巴克被指含有致癌物质（丙烯酰胺Acrylamide）？ 小示例: 123456789String s1 = \"\\r1234\\r567\";String s2 = \"\\n12345\";System.out.println(s1);System.out.println(s2);// 输出:56712345 再次强调,回车和换行,”.”都不能匹配 1234567String s1 = \"\\r1234\\r567\";String regex = \".*\";String regex1 = \"\\\\r.*\";Pattern pattern = Pattern.compile(regex1); // 换成regex则下面的输出为空,也就是不能匹配Matcher matcher = pattern.matcher(s1);matcher.find();System.out.println(matcher.group()); 更多知识请参考: 终于搞懂了回车与换行的区别","categories":[{"name":"其他","slug":"其他","permalink":"https://blueleer.github.io/categories/其他/"}],"tags":[{"name":"计算机","slug":"计算机","permalink":"https://blueleer.github.io/tags/计算机/"},{"name":"其他","slug":"其他","permalink":"https://blueleer.github.io/tags/其他/"}]},{"title":"hexo主题之next主题的配置","slug":"hexo主题之next主题的配置","date":"2018-04-06T13:46:36.000Z","updated":"2018-04-06T15:48:33.471Z","comments":true,"path":"2018/04/06/hexo主题之next主题的配置/","link":"","permalink":"https://blueleer.github.io/2018/04/06/hexo主题之next主题的配置/","excerpt":"","text":"关于 hexo 主题之next主题 GiuHub地址 Next主题配置官网文档 hexo的next主题个性化教程:打造炫酷网站 另外附上大致的使用GitHub Pages建站的流程: 注册GitHub账号 创建 YourName.github.io库,GitHub默认把它当做静态html托管仓库(我们实际上也仅仅是在它上面托管我们的静态网页,它还能够识别解析css和js文件) 在GitHub上生成 SSH Keys (后面使用的hexo在本地拥有了一个SSH Keys的拷贝,这样就可以实现快速部署到pages仓库) 安装hexo,推荐参考 hexo官方文档 这样可以少走很多弯路,遇到问题了再去查解决方法 然后就可以找一款自己喜欢的主题啦 hexo官网,这上面有很全的plug插件和theme主题,也可以参考别人的推荐,我就用的是GitHub上star数醉的的一款next","categories":[{"name":"其他","slug":"其他","permalink":"https://blueleer.github.io/categories/其他/"}],"tags":[{"name":"hexo主题配置","slug":"hexo主题配置","permalink":"https://blueleer.github.io/tags/hexo主题配置/"}]},{"title":"Hibernate学习笔记4","slug":"Hibernate学习笔记4","date":"2017-05-12T11:10:40.000Z","updated":"2018-04-13T12:10:38.107Z","comments":true,"path":"2017/05/12/Hibernate学习笔记4/","link":"","permalink":"https://blueleer.github.io/2017/05/12/Hibernate学习笔记4/","excerpt":"","text":"Hibernate–4JPA(Java Persistence API)：Java持久化API,用于规范ORM接口的一系列规范。 Hibernate中实现了JPA规范 配置 项目引入jpa配置（persistence.xml） 123456789101112131415&lt;?xml version=\"1.0\" encoding=\"UTF-8\" ?&gt;&lt;persistence xmlns=\"http://xmlns.jcp.org/xml/ns/persistence\" xmlns:xsi=\"http://www.w3.org/2001/XMLSchema-instance\" xsi:schemaLocation=\"http://xmlns.jcp.org/xml/ns/persistence http://xmlns.jcp.org/xml/ns/persistence/persistence_2_1.xsd\" version=\"2.1\"&gt; &lt;!-- name : 用于指定持久化单元的名称(可以为空,必须配) transaction-type : 指定事务类型,取值为JTA(默认)、RESOURCE_LOCAL --&gt; &lt;persistence-unit name=\"Unit1\" transaction-type=\"RESOURCE_LOCAL\"&gt; &lt;!--javax.persistence.PersistenceProvider的一个实现类,用于创建EntityManagerFactory(用于产生实体类管理者工厂)--&gt; &lt;!--在Hibernate中实现了JPA规范,这个类其实也是默认的,可以不配--&gt; &lt;provider&gt;org.hibernate.jpa.HibernatePersistenceProvider&lt;/provider&gt; &lt;!--罗列出需要持久化的类(在JavaEE环境下可以不配)--&gt; &lt;class&gt;com.lee.cfgtest.Student&lt;/class&gt; &lt;class&gt;com.lee.cfgtest.Teacher&lt;/class&gt; &lt;class&gt;com.lee.one2many.Tenant&lt;/class&gt; &lt;class&gt;com.lee.one2many.Landlord&lt;/class&gt; &lt;!--JPA实现者专有配置,不同的JPA规范实现框架,可能配置的property值不一样--&gt; &lt;!--参考hibernate.cfg.xml中的配置--&gt; &lt;properties&gt; &lt;!--DDL生成策略--&gt; &lt;!--其中update表示:检测实体类和表结构是否一致,如果不一致,更新表结构达到一致,如果不存在该表,就创建一张表--&gt; &lt;property name=&quot;hibernate.hbm2ddl.auto&quot; value=&quot;update&quot;/&gt; &lt;!--第一部分:数据库连接配置--&gt; &lt;property name=&quot;hibernate.connection.driver_class&quot; value=&quot;com.mysql.jdbc.Driver&quot;/&gt; &lt;property name=&quot;hibernate.connection.url&quot; value=&quot;jdbc:mysql://localhost:3306/hibernate2&quot;/&gt; &lt;property name=&quot;hibernate.connection.username&quot; value=&quot;root&quot;/&gt; &lt;property name=&quot;hibernate.connection.password&quot; value=&quot;123&quot;/&gt; &lt;!--第二部分 :配置数据库连接池:c3p0 (自由选择)--&gt; &lt;property name=&quot;hibernate.connection.provider_class&quot; value=&quot;org.hibernate.connection.C3P0ConnectionProvider&quot;/&gt; &lt;!--配置数据库方言--&gt; &lt;property name=&quot;hibernate.dialect&quot; value=&quot;org.hibernate.dialect.MySQL55Dialect&quot;/&gt; &lt;!--是否在控制台显示生成的sql语句--&gt; &lt;property name=&quot;hibernate.show_sql&quot; value=&quot;true&quot;/&gt; &lt;!--是否将控制台里的sql语句格式化输出--&gt; &lt;!--&lt;property name=&quot;hibernate.format_sql&quot; value=&quot;true&quot;/&gt;--&gt; &lt;/properties&gt; &lt;/persistence-unit&gt; 一对多关系配置 1234567891011121314151617181920212223242526272829303132* 实体类中的配置(包含表之间一对多映射配置) 一对多关系中的\"一\"的一方实体类配置 @Entity @Table(name = \"hb_landlord\") public class Landlord &#123; @Id @GeneratedValue(strategy = GenerationType.IDENTITY) @Column(name = \"l_id\") private Integer lid; @Column(name = \"l_name\") private String lname; @Column(name = \"l_sex\") private String lsex; @Column(name = \"l_age\") private Integer lage; @Column(name = \"l_phone\") private String lphone; // 参数解释: // targetEntity:表示对应的\"多\"的一方的字节码文件,也可以不加 // mappedBy:从表中引用的该实体属性名,如果配置了该项,表示放弃维护和从表之间的关联关系.在一对多配置中,一般\"一\"的一方会配置上该属性;如果没有配置该属性,会生成第三张表(类似于多对多中的中间表)来维护他们之间的关系 // fetch:配置tenants的加载方式, OneToMany中fetch的默认值为LAZY // 还有其他属性:cascade:级联操作 @OneToMany(targetEntity = Tenant.class, fetch = FetchType.LAZY, mappedBy = \"landlord\") private Set&lt;Tenant&gt; tenants = new HashSet&lt;&gt;(0); // 省略默认构造方法,get/set方法,toString()方法 &#125; 一对多中”多”的一方的实体类配置 1234567891011121314151617181920212223242526@Entity@Table(name = \"hb_tenant\")public class Tenant &#123; @Id @GeneratedValue(strategy = GenerationType.IDENTITY) @Column(name = \"t_id\") private Integer tid; @Column(name = \"t_name\") private String tname; @Column(name = \"t_sex\") private String tsex; @Column(name = \"t_age\") private Integer tage; @Column(name = \"t_phone\") private String tphone; @Column(name = \"t_job\") private String tjob; // 从事的工作 // 一位租户只能有一个房东,建立关系 @ManyToOne(targetEntity = Landlord.class, fetch = FetchType.LAZY) // 用于配置外键,如果不配置也会默认生成(最好自己配上,生成的外键字段可读性更好) @JoinColumn(name = \"land_tenant_fk\", referencedColumnName = \"l_id\") private Landlord landlord; // 省略默认构造方法,get/set方法,toString()方法&#125; 多对多关系配置多对多配置以后会生成一个中间表,中间表维护了两个表之间的关系.但是在配置的时候,要分清楚关系维护端(保留关联关系),任何两个表之间都有主从之分 主表:hb_teacher对应的实体表 1234567891011121314151617181920212223242526@Entity // 指定这是一个实体类.在创建EntityManagerFactory的时候就会读取映射配置@Table(name = \"hb_teacher\") // 指定该表所在数据库中的表名public class Teacher &#123; @Id // 主键 @GeneratedValue(strategy = GenerationType.IDENTITY) // 主键生成策略 @Column(name = \"t_id\") // 主键在数据库中对应的字段名 private Long tid; @Column(name = \"t_name\") private String tname; @Column(name = \"t_age\") private String tage; // targetEntity:映射的另一方实体的类 // mappedBy : 被对方维护关联关系(也就是说放弃了维护关联关系的权利) @ManyToMany(targetEntity = Student.class,mappedBy = \"teachers\") private Set&lt;Student&gt; students = new HashSet&lt;&gt;(0); public Teacher() &#123; &#125; // 省略get/set方法,省略toString方法&#125; 从表:hb_student表对应的实: 123456789101112131415161718192021222324252627282930313233@Entity@Table(name = \"hb_student\")public class Student &#123; @Id @GeneratedValue(strategy = GenerationType.IDENTITY) @Column(name = \"s_id\") private Long sid; @Column(name = \"s_name\") private String sname; @Column(name = \"s_age\") private String sage; @ManyToMany(targetEntity = Teacher.class) @JoinTable( name = \"stu_tea_ref\", // 中间表的表名 joinColumns = &#123; // 指定自己一方在表中维护的字段.name:字段名;referencedColumnName:关联的字段名称 @JoinColumn(name = \"stu_id\", referencedColumnName = \"s_id\") &#125;, inverseJoinColumns = &#123; // 指定对方在表中维护的字段.name:字段名;referencedColumnName:关联的字段的名称 @JoinColumn(name = \"tea_id\", referencedColumnName = \"t_id\") &#125; ) private Set&lt;Teacher&gt; teachers = new HashSet&lt;&gt;(0); public Student() &#123; &#125; // 省略get/set方法,省略toString()方法&#125; 在执行删除操作时:主控方(维护了关联关系的表): 可以同时将记录删除,并且删除中间表中的记录 从方(放弃维护关联关系的表): 如果该记录被中间表引用,不能删除 在从方配置了级联删除,会将该记录删除,中间表中的数据也会删除,但,同时会将主控方的表中也删除一条记录,这是不允许的 ​","categories":[],"tags":[{"name":"学习日记","slug":"学习日记","permalink":"https://blueleer.github.io/tags/学习日记/"},{"name":"错误解决","slug":"错误解决","permalink":"https://blueleer.github.io/tags/错误解决/"},{"name":"Hibernate","slug":"Hibernate","permalink":"https://blueleer.github.io/tags/Hibernate/"}]},{"title":"JPA概念解析-关联关系的维护","slug":"JPA概念解析-关联关系的维护","date":"2017-04-13T10:52:43.000Z","updated":"2018-04-13T12:10:17.988Z","comments":true,"path":"2017/04/13/JPA概念解析-关联关系的维护/","link":"","permalink":"https://blueleer.github.io/2017/04/13/JPA概念解析-关联关系的维护/","excerpt":"","text":"JPA中的关联关系的维护数据库中的表之间一般有三种关系:一对一、一对多、多对多。 上面的三种关系都有主从表之分:例如 一对一 客户表(cst_customer)和客户详情表(cst_info)：是先有的客户表，再有的客户详情表,因此客户表是主表，详情表是从表 一对多 房东表（landlord）和租户表（tenant）：是先有的房东表然后才有的租户表，房东表是主表，租户表是从表 多对多 老师表（teacher）和学生表（student）：是先有的老师表，才有的学生，所以老师表是主表，学生表是从表 上面的分析只是从生活实际出发，因为从生活实际出发，这样就更好理解主表和从表之间的关系了。 从上面三种表关系的举例中，不知道大家有没有发现一个共同特点：主表相当于一个leader，二从表就是一个follower，似乎follower更关心它和leader之间的关系。 而在使用JPA时，把维护表之间关系的权利交给谁呢? 肯定是交给follower啦!! 举例:(teacher和student,多对多关系) 老师表实体类: 1234567891011121314151617181920212223242526@Entity // 指定这是一个实体类.在创建EntityManagerFactory的时候就会读取映射配置@Table(name = \"hb_teacher\") // 指定该表所在数据库中的表名public class Teacher &#123; @Id // 主键 @GeneratedValue(strategy = GenerationType.IDENTITY) // 主键生成策略 @Column(name = \"t_id\") // 主键在数据库中对应的字段名 private Long tid; @Column(name = \"t_name\") private String tname; @Column(name = \"t_age\") private String tage; // targetEntity:映射的另一方实体的类 // mappedBy : 生命关系的维护方(也就是说放弃了维护关联关系的权利) @ManyToMany(targetEntity = Student.class,mappedBy = \"teachers\") private Set&lt;Student&gt; students = new HashSet&lt;&gt;(0); public Teacher() &#123; &#125; // 省略get/set方法,省略toString方法&#125; 老师放弃了维护表之间关系的权利,通过设定mappedBy = &quot;teachers&quot; 学生表实体类: 1234567891011121314151617181920212223242526272829303132@Entity@Table(name = \"hb_student\")public class Student &#123; @Id @GeneratedValue(strategy = GenerationType.IDENTITY) @Column(name = \"s_id\") private Long sid; @Column(name = \"s_name\") private String sname; @Column(name = \"s_age\") private String sage; @ManyToMany(targetEntity = Teacher.class,cascade = CascadeType.ALL) @JoinTable( name = \"stu_tea_ref\", // 中间表的表名 joinColumns = &#123; // 指定自己一方在表中维护的字段.name:字段名;referencedColumnName:关联的字段名称 @JoinColumn(name = \"stu_id\", referencedColumnName = \"s_id\") &#125;, inverseJoinColumns = &#123; // 指定对方在表中维护的字段.name:字段名;referencedColumnName:关联的字段的名称 @JoinColumn(name = \"tea_id\", referencedColumnName = \"t_id\") &#125; ) private Set&lt;Teacher&gt; teachers = new HashSet&lt;&gt;(0); public Student() &#123; &#125; // 省略get/set方法,省略toString方法&#125; 学生表维护了和老师表之间的关联关系,你看看它设置了那么多的字段,自己和老师在中间表中的字段都是自己负责设置的,通过设置字段joinColumns和inverseJoinColumns来指定。 实际上本应该就是这样，老师比少，学生比较多，让一个老师记住他教的所有的学生是很困难的，而把这个任务交个学生就相对简单多啦。 接下来，看看这样几种场景： 删除teacher表中的一条记录，如果该记录被中间表引用，能不能删除呢？ 答案是：如果没有设置级联删除，这个记录是不能删除的。试想他能删除，它删除以后，中间表中的数据怎么办，因为它是没有权利维护表关系的。 删除student表中的一条记录，如果该记录被中间表引用，能不能删除呢？ 答案是：是可以删除的。他删除以后，会连同中间表中和自己相关的数据也删除掉。因为它负责维护量表之间的关系！！ 针对第一种情况，能不能删除呢，答案是可以的，但是，不但要在Teacher中设置@ManyToMany(targetEntity = Student.class, mappedBy = &quot;teachers&quot;)标签中设置cascade = CascadeType.REMOVE),因为仅仅只这样设置的话,级联关系是整个表的字段,仅仅这样设置是很危险的。还应该应该给中间表与teacher表相关联的联合主键tea_id加上级联删除 ALTER TABLE stu_tea_ref ADD CONSTRAINT tea_id FOREIGN KEY (tea_id) REFERENCES hb_teacher(t_id) ON DELETE CASCADE ; 说明:stu_tea_ref是中间表,tea_id是引用teacher表主键的联合主键 当删除teacher时,因为应用了级联删除,在中间表将与其主键值相同的相关记录也删除了,没有级联到其他的字段,student表不受影响. 不严谨之处,敬请指出,请关注我的博客: Lee个人博客","categories":[{"name":"数据库","slug":"数据库","permalink":"https://blueleer.github.io/categories/数据库/"}],"tags":[{"name":"Hibernate","slug":"Hibernate","permalink":"https://blueleer.github.io/tags/Hibernate/"},{"name":"数据库","slug":"数据库","permalink":"https://blueleer.github.io/tags/数据库/"}]},{"title":"JPA概念解析-CascadeType详解","slug":"JPA概念解析-CascadeType详解","date":"2017-04-13T10:26:56.000Z","updated":"2018-04-13T12:10:24.879Z","comments":true,"path":"2017/04/13/JPA概念解析-CascadeType详解/","link":"","permalink":"https://blueleer.github.io/2017/04/13/JPA概念解析-CascadeType详解/","excerpt":"","text":"CascadeType.REMOVE Cascade remove operation，级联删除操作。删除当前实体时，与它有映射关系的实体也会跟着被删除。 CascadeType.MERGE Cascade merge operation，级联更新（合并）操作。当Student中的数据改变，会相应地更新Course中的数据。 CascadeType.DETACH Cascade detach operation，级联脱管/游离操作。如果你要删除一个实体，但是它有外键无法删除，你就需要这个级联权限了。它会撤销所有相关的外键关联。 CascadeType.REFRESH Cascade refresh operation，级联刷新操作。假设场景 有一个订单,订单里面关联了许多商品,这个订单可以被很多人操作,那么这个时候A对此订单和关联的商品进行了修改,与此同时,B也进行了相同的操作,但是B先一步比A保存了数据,那么当A保存数据的时候,就需要先刷新订单信息及关联的商品信息后,再将订单及商品保存。 CascadeType.ALL Cascade all operations，清晰明确，拥有以上所有级联操作权限。","categories":[{"name":"数据库","slug":"数据库","permalink":"https://blueleer.github.io/categories/数据库/"}],"tags":[{"name":"Hibernate","slug":"Hibernate","permalink":"https://blueleer.github.io/tags/Hibernate/"},{"name":"数据库","slug":"数据库","permalink":"https://blueleer.github.io/tags/数据库/"}]},{"title":"数据库引擎MyISAM和InnoDB及简单的源码分析","slug":"数据库引擎MyISAM和InnoDB","date":"2017-04-12T15:38:22.000Z","updated":"2018-04-12T16:31:57.786Z","comments":true,"path":"2017/04/12/数据库引擎MyISAM和InnoDB/","link":"","permalink":"https://blueleer.github.io/2017/04/12/数据库引擎MyISAM和InnoDB/","excerpt":"","text":"问题描述: 今天在使用Hibernate框架(版本为5.2.16),建立多表关联映射关系时,发现从表中没有创建关联外键约束,进而导致:从表中应用了主表的主键作为外键,此时删除主表中相关联的数据依然行得通,也就是说从表中的外键在主表中找不到对应的记录与之对应了. 检查了关联关系配置文件中没有问题 最后在这个地方找到了答案:发现数据库的 engine 是MyISAM类型的 MyISAM不支持外键!!!! 在配置文件中发现: 123&lt;property name=\"hibernate.dialect.storage_engine\"&gt; org.hibernate.dialect.MySQL5Dialect&lt;/property&gt; 跟到源码中发现:配置了这一项默认使用的就是MyISAM引擎(源码在后面) 好啦,接下来对比下MyISAM和InnoDB:** 区别: InnoDB支持事务，MyISAM不支持，对于InnoDB每一条SQL语言都默认封装成事务，自动提交，这样会影响速度，所以最好把多条SQL语言放在begin和commit之间，组成一个事务； InnoDB支持外键，而MyISAM不支持。对一个包含外键的InnoDB表转为MYISAM会失败； InnoDB是聚集索引，数据文件是和索引绑在一起的，必须要有主键，通过主键索引效率很高。但是辅助索引需要两次查询，先查询到主键，然后再通过主键查询到数据。因此，主键不应该过大，因为主键太大，其他索引也都会很大。而MyISAM是非聚集索引，数据文件是分离的，索引保存的是数据文件的指针。主键索引和辅助索引是独立的。 InnoDB不保存表的具体行数，执行select count(*) from table时需要全表扫描。而MyISAM用一个变量保存了整个表的行数，执行上述语句时只需要读出该变量即可，速度很快； Innodb不支持全文索引，而MyISAM支持全文索引，查询效率上MyISAM要高； 如何选择: 是否要支持事务，如果要请选择innodb，如果不需要可以考虑MyISAM； 如果表中绝大多数都只是读查询，可以考虑MyISAM，如果既有读写也挺频繁，请使用InnoDB。 系统奔溃后，MyISAM恢复起来更困难，能否接受； MySQL5.5版本开始Innodb已经成为Mysql的默认引擎(之前是MyISAM)，说明其优势是有目共睹的，如果你不知道用什么，那就用InnoDB，至少不会差。 另外:mysql5.7的innodb已支持全文索引 为了保证支持事务、外键，在Hibernate的hibernate.cfg.xml中的hibernate.dialect.storage_engine配置中，应该这么配置: 1234&lt;property name=\"hibernate.dialect.storage_engine\"&gt; org.hibernate.dialect.MySQL55Dialect&lt;/property&gt;&lt;!--我的MySQL版本是5.5,而5.5默认的engine是InnoDB--&gt; 而且注意:org.hibernate.dialect.MySQLDialect在MySQL5.5以上已经不能再使用了. 源码分析: MySQL5Dialect继承自MySQLDialect,没有重载构造方法 123public class MySQL5Dialect extends MySQLDialect &#123; ...&#125; 进入到MySQLDialect中 1234567891011121314151617181920/** * Constructs a MySQLDialect */public MySQLDialect() &#123; super(); String storageEngine = Environment.getProperties().getProperty( Environment.STORAGE_ENGINE ); // null if(storageEngine == null) &#123; storageEngine = System.getProperty( Environment.STORAGE_ENGINE ); &#125; if(storageEngine == null) &#123; this.storageEngine = getDefaultMySQLStorageEngine(); // 进入到此方法 &#125; // ...省略... protected MySQLStorageEngine getDefaultMySQLStorageEngine() &#123; return MyISAMStorageEngine.INSTANCE; // 返回MyISAM引擎 &#125;&#125;","categories":[{"name":"数据库","slug":"数据库","permalink":"https://blueleer.github.io/categories/数据库/"}],"tags":[{"name":"错误解决","slug":"错误解决","permalink":"https://blueleer.github.io/tags/错误解决/"},{"name":"数据库","slug":"数据库","permalink":"https://blueleer.github.io/tags/数据库/"},{"name":"MySQL","slug":"MySQL","permalink":"https://blueleer.github.io/tags/MySQL/"}]},{"title":"Hibernate学习笔记3","slug":"Hibernate学习笔记3","date":"2017-04-10T12:53:33.000Z","updated":"2018-04-13T12:10:46.100Z","comments":true,"path":"2017/04/10/Hibernate学习笔记3/","link":"","permalink":"https://blueleer.github.io/2017/04/10/Hibernate学习笔记3/","excerpt":"","text":"Hibernate–3学习大纲: 数据库中表的关系 一对一 一对多 多对多 注意:不管是哪种关系,在逻辑上都有主表和从表之分 外键 : 从表中的一列来源于主表的主键,或者为null,默认情况下外键是可以重复的 如何确立和实现表之间的关系 确立:看表的外键90%的情况下能确立表之间的关系 实现: 一对一 (A表和B表): B表中的外键是A表的主键,且此外键设置唯一约束,非空约束 B表的外键是A表的主键,同时又是主键 一对多(A表和B表): 其中A表示主表,B表示从表,主表一般指的是一,从表指的是多 B表的外键是A表的主键,也可以为null 多对多(A表和B表) 维护一个第三表,该表只有两个字段,且都为主键,引用自A,B两个表的主键 任何一个多表和第三表之间的关系都是一对多的关系 使用Hibernate多表映射配置的步骤 第一步:确立两张表之间的关系 第二步:在数据库中创建出这两张表,并实现两张表之间的关系 第三步:在实体类中描述出两个实体之间的关系 第四步:在映射配置文件中配置两张表之间的关系 情景一:建立房东(landlord)数据表和租户(tenant)数据表 第一步:确立两张表之间的关系 一个房东可以有多个租户 一个租户只能有一个房东 所以房东和租户之间是一对多的关系 第二步:在数据库中创建出这两张表,并实现两张表之间的关系 123456789101112131415161718/*房东信息表*/CREATE TABLE hb_landlord( l_id INT PRIMARY KEY AUTO_INCREMENT, l_name VARCHAR(10), l_sex CHAR(1), l_age INT(3), l_phone VARCHAR(15))/*租户信息表*/CREATE TABLE hb_tenant( t_id INT PRIMARY KEY AUTO_INCREMENT, t_name VARCHAR(10), t_sex CHAR(1), t_age INT(3), t_phone VARCHAR(15), t_job VARCHAR(10)) 只要在Hibernate中配置好表的映射配置文件以后,获取Session的时候,会自动加载配置文件,Hibernate检查表是否已经创建,如果没有创建就替我们创建表 第三步:在实体类中描述出两个实体之间的关系 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475// 房东 表public class Landlord &#123; private Integer lid; private String lname; private String lsex; private Integer lage; private String lphone; // 一位房东可以包含多位租客,建立一对多关系 // 注意这里的处理方式:防止后面调用添加租客的时候报空指针异常(set还没有创建),提前将其创建出来 // 如果数据众多的时候,会有多个tenants创建,会很占用内存,所以初始化的时候现将其初始容量设置成0 private Set&lt;Tenant&gt; tenants = new HashSet&lt;&gt;(0); public Landlord() &#123; &#125; public Set&lt;Tenant&gt; getTenants() &#123; return tenants; &#125; public void setTenants(Set&lt;Tenant&gt; tenants) &#123; this.tenants = tenants; &#125; public Integer getLid() &#123; return lid; &#125; public void setLid(Integer lid) &#123; this.lid = lid; &#125; public String getLname() &#123; return lname; &#125; public void setLname(String lname) &#123; this.lname = lname; &#125; public String getLsex() &#123; return lsex; &#125; public void setLsex(String lsex) &#123; this.lsex = lsex; &#125; public Integer getLage() &#123; return lage; &#125; public void setLage(Integer lage) &#123; this.lage = lage; &#125; public String getLphone() &#123; return lphone; &#125; public void setLphone(String lphone) &#123; this.lphone = lphone; &#125; @Override public String toString() &#123; return \"Landlord&#123;\" + \"lid=\" + lid + \", lname='\" + lname + '\\'' + \", lsex='\" + lsex + '\\'' + \", lage=\" + lage + \", lphone='\" + lphone + '\\'' + '&#125;'; &#125;&#125; 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475//租户 表public class Tenant &#123; private Integer tid; private String tname; private String tsex; private Integer tage; private String tphone; private String tjob; // 从事的工作 // 一位租户只能有一个房东,建立关系 private Landlord landlord; public Tenant() &#123; &#125; public Integer getTid() &#123; return tid; &#125; public void setTid(Integer tid) &#123; this.tid = tid; &#125; public String getTname() &#123; return tname; &#125; public void setTname(String tname) &#123; this.tname = tname; &#125; public String getTsex() &#123; return tsex; &#125; public void setTsex(String tsex) &#123; this.tsex = tsex; &#125; public Integer getTage() &#123; return tage; &#125; public void setTage(Integer tage) &#123; this.tage = tage; &#125; public String getTphone() &#123; return tphone; &#125; public void setTphone(String tphone) &#123; this.tphone = tphone; &#125; public String getTjob() &#123; return tjob; &#125; public void setTjob(String tjob) &#123; this.tjob = tjob; &#125; @Override public String toString() &#123; return \"Tenant&#123;\" + \"tid=\" + tid + \", tname='\" + tname + '\\'' + \", tsex='\" + tsex + '\\'' + \", tage=\" + tage + \", tphone='\" + tphone + '\\'' + \", tjob='\" + tjob + '\\'' + '&#125;'; &#125;&#125; ​ 第四步:在映射配置文件中配置两张表之间的关系 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748&lt;?xml version=\"1.0\" encoding=\"UTF-8\" ?&gt;&lt;!--指定命名空间,从hibernate-core-5.2.16.Final包中找--&gt;&lt;!DOCTYPE hibernate-mapping PUBLIC \"-//Hibernate/Hibernate Mapping DTD 3.0//EN\" \"http://www.hibernate.org/dtd/hibernate-mapping-3.0.dtd\"&gt;&lt;hibernate-mapping package=\"com.lee.one2many\"&gt; &lt;class name=\"Landlord\" table=\"hb_landlord\"&gt; &lt;id name=\"lid\" column=\"l_id\"&gt; &lt;!--主键自增长,使用数据库本地的自增长能力--&gt; &lt;generator class=\"native\"&gt;&lt;/generator&gt; &lt;/id&gt; &lt;property name=\"lname\" column=\"l_name\"&gt;&lt;/property&gt; &lt;property name=\"lsex\" column=\"l_sex\"&gt;&lt;/property&gt; &lt;property name=\"lage\" column=\"l_age\"&gt;&lt;/property&gt; &lt;property name=\"lphone\" column=\"l_phone\"&gt;&lt;/property&gt; &lt;!-- set:配置set集合属性 name:一对多关系中,维护的\"多\"对应的集合set的成员属性名:private Set&lt;Tenant&gt; tenants = new HashSet&lt;&gt;(0); table:对应的从表的表名(在一对多的配置中可以不写) key:用于映射从表的外键字段 column:指定从表中外键的字段名称 one-to-many:从表对应的实体类 其他字段: lazy:是否懒加载,true:懒加载(延迟加载)-指的是是否延迟加载关联的从表记录 inverse:true,代表放弃了外键的维护权,表示它不关心外键是否正确或null(默认为false) cascade : save-update:级联保存或者更新 delete:级联删除(慎用) cascade=\"save-update,delete\" --&gt; &lt;set name=\"tenants\" table=\"hb_tenant\" cascade=\"save-update\" lazy=\"false\"&gt; &lt;key column=\"ten_land_fk_id\"&gt;&lt;/key&gt; &lt;one-to-many class=\"Tenant\"&gt;&lt;/one-to-many&gt; &lt;/set&gt; &lt;!-- 理解 : 因为维护了多的一方的集合,肯定要知道多的一方对应的实体类(!!必须配置实体类名) : 多的一方怎么跟我建立起关系的呢?因为它引用了我的主键作为它的外键(!!必须要知道外键对应的字段) : 因为已经指定了实体类,而实体类已经通过映射配置文件为其配置了对应的表名,因此表名可有可无 --&gt; &lt;/class&gt;&lt;/hibernate-mapping&gt; 123456789101112131415161718192021222324252627282930&lt;?xml version=\"1.0\" encoding=\"UTF-8\" ?&gt;&lt;!--指定命名空间,从hibernate-core-5.2.16.Final包中找--&gt;&lt;!DOCTYPE hibernate-mapping PUBLIC \"-//Hibernate/Hibernate Mapping DTD 3.0//EN\" \"http://www.hibernate.org/dtd/hibernate-mapping-3.0.dtd\"&gt;&lt;hibernate-mapping package=\"com.lee.one2many\"&gt; &lt;class name=\"Tenant\" table=\"hb_tenant\" lazy=\"false\"&gt; &lt;id name=\"tid\" column=\"t_id\"&gt; &lt;!--主键自增长,使用数据库本地的自增长能力--&gt; &lt;generator class=\"native\"&gt;&lt;/generator&gt; &lt;/id&gt; &lt;property name=\"tname\" column=\"t_name\"&gt;&lt;/property&gt; &lt;property name=\"tsex\" column=\"t_sex\"&gt;&lt;/property&gt; &lt;property name=\"tage\" column=\"t_age\"&gt;&lt;/property&gt; &lt;property name=\"tphone\" column=\"t_phone\"&gt;&lt;/property&gt; &lt;property name=\"tjob\" column=\"t_job\"&gt;&lt;/property&gt; &lt;!-- name : 多对一中,\"一\"对应的属性字段 class : \"一\"对应的实体类 column : 映射的外键 lazy: proxy:代理,依赖主表实体类的加载模式(在主表映射配置文件的&lt;class&gt;标签中进行配置) false:立即加载 no-proxy: 默认为proxy --&gt; &lt;many-to-one name=\"landlord\" class=\"Landlord\" column=\"ten_land_fk_id\" lazy=\"proxy\"/&gt; &lt;/class&gt;&lt;/hibernate-mapping&gt; 情景二:学生和老师的信息 第一步:确立两张表之间的关系 一位学生可以拥有多个老师 一位老师可以拥有多个学生 所以学生表和老师表是多对多的关系 第二步:在数据库中创建出这两张表,并实现两张表之间的关系 只要配置文件中没有出错,Hibernate就会创建出正确的表来 第三步:在实体类中描述出两个实体之间的关系 互相持有对方的一个Set集合引用 第四步:在映射配置文件中配置两张表之间的关系 Student实体对应的数据库表 1234567891011121314&lt;?xml version=\"1.0\" encoding=\"UTF-8\" ?&gt;&lt;!--指定命名空间,从hibernate-core-5.2.16.Final包中找--&gt;&lt;!DOCTYPE hibernate-mapping PUBLIC \"-//Hibernate/Hibernate Mapping DTD 3.0//EN\" \"http://www.hibernate.org/dtd/hibernate-mapping-3.0.dtd\"&gt;&lt;hibernate-mapping package=\"com.lee.many2many\"&gt; &lt;class name=\"Student\" table=\"hb_student\"&gt; &lt;id name=\"sid\" column=\"s_id\"&gt; &lt;!--主键自增长,使用数据库本地的自增长能力--&gt; &lt;generator class=\"native\"&gt;&lt;/generator&gt; &lt;/id&gt; &lt;property name=\"sname\" column=\"s_name\"&gt;&lt;/property&gt; &lt;property name=\"sage\" column=\"s_age\"&gt;&lt;/property&gt; &lt;!-- set:用于配置映射的集合属性 name:指定当前映射实体类中对应集合属性的属性名称 table:指定生成中间表的表名 column:当前映射文件对应实体在中间表中的联合主键字段 class:指定集合属性所装的实体类型 column:指定对方在表中对应的字段名称 --&gt; &lt;!--注意:多对多情况下慎用级联删除,可能会出现删除不需要删除的对象--&gt; &lt;set name=&quot;teachers&quot; table=&quot;tea_stu_ref&quot; cascade=&quot;save-update,delete&quot;&gt; &lt;key column=&quot;stu_id&quot;&gt;&lt;/key&gt; &lt;many-to-many class=&quot;Teacher&quot; column=&quot;tea_id&quot;&gt;&lt;/many-to-many&gt; &lt;/set&gt; &lt;!-- 理解 : 因为维护了多的一方的集合,肯定要知道多的一方对应的实体类(!!必须配置实体类名) : 多的一方怎么跟我建立起关系的呢?因为它引用了我的主键作为它的外键(!!必须要知道外键对应的字段) : 因为已经指定了实体类,而实体类已经通过映射配置文件为其配置了对应的表名,因此表名可有可无 --&gt; &lt;/class&gt; 12345678910111213141516171819202122232425262728293031Teacher实体对应的数据库表```xml&lt;?xml version=&quot;1.0&quot; encoding=&quot;UTF-8&quot; ?&gt;&lt;!DOCTYPE hibernate-mapping PUBLIC &quot;-//Hibernate/Hibernate Mapping DTD 3.0//EN&quot; &quot;http://www.hibernate.org/dtd/hibernate-mapping-3.0.dtd&quot;&gt;&lt;hibernate-mapping package=&quot;com.lee.many2many&quot;&gt; &lt;class name=&quot;Teacher&quot; table=&quot;hb_teacher&quot;&gt; &lt;id name=&quot;tid&quot; column=&quot;t_id&quot;&gt; &lt;generator class=&quot;native&quot;&gt;&lt;/generator&gt; &lt;/id&gt; &lt;property name=&quot;tname&quot; column=&quot;t_name&quot;&gt;&lt;/property&gt; &lt;property name=&quot;tage&quot; column=&quot;t_sex&quot;&gt;&lt;/property&gt; &lt;!--注意:多对多情况下慎用级联删除,可能会出现删除不需要删除的对象--&gt; &lt;set name=&quot;students&quot; table=&quot;tea_stu_ref&quot;&gt; &lt;key column=&quot;tea_id&quot;&gt;&lt;/key&gt; &lt;many-to-many class=&quot;Student&quot; column=&quot;stu_id&quot;&gt;&lt;/many-to-many&gt; &lt;/set&gt; &lt;!-- 理解 : 因为维护了多的一方的集合,肯定要知道多的一方对应的实体类(!!必须配置实体类名) : 多的一方怎么跟我建立起关系的呢?因为它引用了我的主键作为它的外键(!!必须要知道外键对应的字段) : 因为已经指定了实体类,而实体类已经通过映射配置文件为其配置了对应的表名,因此表名可有可无 --&gt; &lt;/class&gt;&lt;/hibernate-mapping&gt; ​ 延迟加载思想 导航查询思想 load方法和get方法的区别,get方法立即查询.get方法取决于当前实体类映射配置文件中&lt;calss&gt;标签中的lazy属性,true表示延迟加载.","categories":[],"tags":[{"name":"学习日记","slug":"学习日记","permalink":"https://blueleer.github.io/tags/学习日记/"},{"name":"错误解决","slug":"错误解决","permalink":"https://blueleer.github.io/tags/错误解决/"},{"name":"Hibernate","slug":"Hibernate","permalink":"https://blueleer.github.io/tags/Hibernate/"}]},{"title":"Hibernate学习笔记2","slug":"Hibernate学习笔记2","date":"2017-04-09T03:57:42.000Z","updated":"2018-04-12T11:11:55.019Z","comments":true,"path":"2017/04/09/Hibernate学习笔记2/","link":"","permalink":"https://blueleer.github.io/2017/04/09/Hibernate学习笔记2/","excerpt":"","text":"Hibernate–2学习内容: 实体类的编写规范(也称作为持久化类) 实体类的编写规范 类的成员变量声明为private 有默认的无参构造方法 可生成具有唯一标志oid的实例 提供get和set方法(也可以只设置只读方法或者只写方法) 用包装型数据类型替代基本类型,比如id类型应该用Long类型替代long类型 不要用final关键字修饰(否则延迟加载机制会失效) JavaBean 指的是用Java语言编写的可重用 hibernate中的对象标识符 Hibernate中oid的:指的是表字段中的主键,这个主键交给数据库底层或者Hibernate去生成,这样能够保证oid的一致性,同时对于持久化类,应该将id对应的set方法设置成private类型的(反射能够访问private类型的成员) hibernate中主键的生成方式 Hibernate的主键生成方式 自然主键和代理主键的区别 自然主键:区分记录,参与业务逻辑 代理主键:区分记录,不参与业务逻辑 hibernate的一级缓存和快照机制 调用Session的update(),save(),saveOrUpdate()方法时,如果Session缓存中没有相应的对象,Hibernate会自动的将刚刚添加进(更新)的数据添加到Session缓存中,以防临近时机调用不用再重复访问数据库 注意:如果设置了主键自动增长,此时再给对象设置主键字段是无效的 快照区其实相当于数据库的一部分数据的拷贝,他保存了数据库真实的数据,每次commit时,都会检查缓存和快照区的数据时候一致,如果不一致,更新数据库,同时更新快照去 hibernate中的对象状态(三种状态/四种状态) 瞬时状态:没有OID,没有和Session建立关系 持久状态:有OID,有缓存,并且对应的Session也没有关闭,在数据库中有对应的记录,每条记录对应一个唯一的持久态对象,注意它是在事务未提交之前形成的持久态的 脱管状态:某个持久态的实例与其相关联的Session被关闭时就形成了脱管状态,此时他就是一条独立于Hibernate的数据,它的改变与数据库没有什么关系 hibernate中的事务控制 解决的问题:让Session对象也符合使用原则(即一个线程只有一个Session对象) hibernate中的查询方式 查询多条记录的方式 共5种查询方式 OID查询 使用session的get(),load()方法进行查询 SQL查询 第一种:SQLQuery方式(使用的很少) 第二种:Session通过doWork()方法,可以拿到Connection对象 HQL查询(官方推荐的查询方式) Hibernate Query Language,使用Query对象查询 QBC查询 Query By Criteria,使用Criteria对象执行查询 对象导航查询 …… hibernate中的Query对象(重点) 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135/** * @CreateAuthor: KingIsHappy * @CreateDate: 2018/4/10 * @Description: 使用Session中的Query进行查询 * SQL:select * from cst_customer * HQL:select * from Customer * 将SQL中的表名换成映射的实体的类名,将将查询的字段名换成实体中对应的属性名 * &lt;p&gt; * 基本查询 * 条件查询 * 分页查询 * 排序查询 * 统计查询 * 投影查询 */public class Demo2 &#123; /* 基本查询 */ @Test public void test1() &#123; Session session = HibernateUtils.openSession(); Transaction transaction = session.beginTransaction();// Query query = session.createQuery(\"from Customer\"); // 查询Customer实体对应的表中的所有的数据 Query query1 = session.createQuery(\"select cname,cage from Customer\"); // 查询两个指定字段 List&lt;Object[]&gt; list = query1.getResultList(); for (Object[] ol : list) &#123; for (Object o : ol) &#123; System.out.println(o); &#125; &#125; transaction.commit(); &#125; /** * 条件查询 */ @Test public void test2() &#123; Session session = HibernateUtils.openSession(); Transaction ts = session.beginTransaction(); Query query = session.createQuery(\"from Customer where cname = ?\"); query.setParameter(0, \"马云\"); // 从0开始(0代表第一个替换位置)// Query query = session.createQuery(\"from Customer where cname like ?\");// query.setString(0,\"%马%\"); // 在HQL中将参数设置别名,然后再给参数赋值// Query query = session.createQuery(\"from Customer where cname like :likename\");// query.setString(\"likename\", \"%马%\"); List&lt;Customer&gt; list = query.list(); for (Customer c : list) &#123; System.out.println(c); &#125; ts.commit(); &#125; /** * 分页查询 */ @Test public void test3() &#123; Session session = HibernateUtils.openSession(); Transaction transaction = session.beginTransaction(); Query query = session.createQuery(\"select cid,cname from Customer \"); query.setFirstResult(5);// 从索引为5的位置开始查 // 假如数据库中有1000条记录,你以此想把这1000条记录查出来,设置了setFetchSize(100) // 数据库每次回返回100条记录,当你需要下面的100条记录的时候,数据库才会加载下面的100条记录// query.setFetchSize(2); query.setMaxResults(2);// 每次查询返回的条数 List&lt;Object[]&gt; list = query.getResultList(); for (Object[] ol : list) &#123; for (Object o : ol) &#123; System.out.println(o); &#125; &#125; transaction.commit(); &#125; /** * 排序查询 */ @Test public void test4() &#123; Session session = HibernateUtils.openSession(); Transaction transaction = session.beginTransaction(); Query query = session.createQuery(\"from Customer order by cid desc \"); List&lt;Customer&gt; list = query.list(); for (Customer c : list) &#123; System.out.println(c); &#125; transaction.commit(); &#125; /** * 统计查询 */ @Test public void test5() &#123; Session session = HibernateUtils.openSession(); Transaction transaction = session.beginTransaction();// Query query = session.createQuery(\"select count (*) from Customer \"); Query query = session.createQuery(\"select avg (cage) from Customer \"); // getSingleResult()只能接收一个结果,当结果超过1一个时就会报错 Object result = query.getSingleResult(); Object o = query.uniqueResult();// 效果和getSingleResult一样 System.out.println(result); transaction.commit(); &#125; /** * 投影查询 */ @Test public void test6() &#123; Session session = HibernateUtils.openSession(); Transaction transaction = session.beginTransaction(); // 给HQL传参的时候,创建一个新的对象,指定要查询的字段的名称,执行查询以后,默认返回一个封装好了的实体 Query query = session.createQuery(\"select new Customer (cname,cage) from Customer where cid = ?\"); query.setParameter(0, 1L); Object result = query.getSingleResult(); System.out.println(result); transaction.commit(); &#125;&#125; ​ hibernate中的Criteria(标准、准则)对象 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154155156157158159160161162163164165166167168169170171172173174175176177178179180181182183184185/** * @CreateAuthor: KingIsHappy * @CreateDate: 2018/4/10 * @Description: 使用Session创建的Criteria进行查询(QBC查询) * Criteria是一个完全面向对象,可扩展的条件查询API,他完全不用考虑数据库底层是如何实现,以及SQL如何编写 * &lt;p&gt; * 基本查询 * 条件查询 * 分页查询 * 排序查询 * 统计查询 * 离线查询(不依赖Session产生一个DetachedCriteria对象(new得到),然后设置查询参数及条件) */public class Demo3 &#123; // * 基本查询(查询所有) @Test public void test1() &#123; Session session = HibernateUtils.openSession(); Transaction transaction = session.beginTransaction(); // 查询所有 Criteria criteria = session.createCriteria(Customer.class); List&lt;Customer&gt; list = criteria.list(); for (Customer c : list) &#123; System.out.println(c); &#125; transaction.commit(); session.close(); &#125; /** * 基本查询(session的createCriteria()方法已经过时的解决办法),官方建议使用Query,这相当于一个折中的方案,CriteriaQuery可以向Criteria一样 * 不用关心SQL怎么写,它可以像Criteria一样进行设置查询条件 */ @Test public void test11() &#123; Session session = HibernateUtils.openSession(); Transaction transaction = session.beginTransaction(); // 查询所有 CriteriaQuery&lt;Customer&gt; cquery = session.getCriteriaBuilder().createQuery(Customer.class); cquery.from(Customer.class); cquery.where();// cquery.where(); Query&lt;Customer&gt; query = session.createQuery(cquery); List&lt;Customer&gt; list = query.list(); for (Customer c : list) &#123; System.out.println(c); &#125; transaction.commit(); session.close(); &#125; // * 条件查询 @Test public void test2() &#123; Session session = HibernateUtils.openSession(); Transaction transaction = session.beginTransaction(); Criteria criteria = session.createCriteria(Customer.class); criteria.add(Restrictions.eq(\"cname\", \"马云\")); List&lt;Customer&gt; list = criteria.list(); for (Customer c : list) &#123; System.out.println(c); &#125; transaction.commit(); session.close(); &#125; // * 分页查询 @Test public void test3() &#123; Session session = HibernateUtils.openSession(); Transaction transaction = session.beginTransaction(); Criteria criteria = session.createCriteria(Customer.class); criteria.setFirstResult(0); criteria.setMaxResults(5); List&lt;Customer&gt; list = criteria.list(); for (Customer c : list) &#123; System.out.println(c); &#125; transaction.commit(); session.close(); &#125; // * 排序查询 @Test public void test4() &#123; Session session = HibernateUtils.openSession(); Transaction transaction = session.beginTransaction(); Criteria criteria = session.createCriteria(Customer.class); criteria.addOrder(Order.desc(\"cid\")); // 降序查询 List&lt;Customer&gt; list = criteria.list(); for (Customer c : list) &#123; System.out.println(c); &#125; transaction.commit(); session.close(); &#125; // * 统计查询(投影查询) @Test public void test5() &#123; Session session = HibernateUtils.openSession(); Transaction transaction = session.beginTransaction(); Criteria criteria = session.createCriteria(Customer.class); // 使用投影查询指定条目的个数 criteria.setProjection(Projections.count(\"cname\")); Object o = criteria.uniqueResult(); System.out.println(o); transaction.commit(); session.close(); &#125; /** * 使用投影查询,查询指定的列 */ @Test public void test55() &#123; Session session = HibernateUtils.openSession(); Transaction transaction = session.beginTransaction(); Criteria criteria = session.createCriteria(Customer.class); criteria.setProjection(Projections.property(\"cname\")); List list = criteria.list(); for (Object o : list) &#123; System.out.println(o); &#125; transaction.commit(); session.close(); &#125; // * 离线查询 /** * 思路:在表现层封装一个DetachedCriteria,将要封装的查询数据到其中 * 传递给服务层,服务层再传递给DAO层,DAO层将DetachedCriteria激活,编程Criteria对象,然后执行查询 */ @Test public void test6() &#123; List list = testServlet(); for (Object o : list) &#123; System.out.println(o); &#125; &#125; // 模拟Servlet public List testServlet() &#123; DetachedCriteria detachedCriteria = DetachedCriteria.forClass(Customer.class); detachedCriteria.add(Restrictions.eq(\"cname\", \"马云\")); List list = null; try &#123; list = testService(detachedCriteria); &#125; catch (Exception e) &#123; e.printStackTrace(); &#125; return list; &#125; // 模拟Service // 在服务中开启事务,事务的处理在业务层 public List testService(DetachedCriteria detachedCriteria) throws Exception &#123; Session session = HibernateUtils.getCurrentSession(); Transaction transaction = null; try &#123; transaction = session.beginTransaction(); List list = testDao(detachedCriteria); transaction.commit(); return list; &#125; catch (HibernateException e) &#123; transaction.rollback(); throw new Exception(e); &#125; &#125; // 模拟DAO private List testDao(DetachedCriteria detachedCriteria) &#123; Session session = HibernateUtils.getCurrentSession(); Criteria executableCriteria = detachedCriteria.getExecutableCriteria(session); return executableCriteria.list(); &#125;&#125; ​ ​ ​ ​ ​","categories":[],"tags":[{"name":"学习日记","slug":"学习日记","permalink":"https://blueleer.github.io/tags/学习日记/"},{"name":"错误解决","slug":"错误解决","permalink":"https://blueleer.github.io/tags/错误解决/"},{"name":"Hibernate","slug":"Hibernate","permalink":"https://blueleer.github.io/tags/Hibernate/"}]},{"title":"Hibernate学习笔记1","slug":"Hibernate学习笔记1","date":"2017-04-08T15:57:47.000Z","updated":"2018-04-12T16:30:53.473Z","comments":true,"path":"2017/04/08/Hibernate学习笔记1/","link":"","permalink":"https://blueleer.github.io/2017/04/08/Hibernate学习笔记1/","excerpt":"","text":"Hibernate–1学习内容: Hibernate相关jar包的依赖 创建表和实体之间的映射配置文件Student.hbm.xml 1234567891011121314151617&lt;?xml version=\"1.0\" encoding=\"UTF-8\" ?&gt;&lt;!--指定命名空间,从hibernate-core-5.2.16.Final包中找--&gt;&lt;!DOCTYPE hibernate-mapping PUBLIC \"-//Hibernate/Hibernate Mapping DTD 3.0//EN\" \"http://www.hibernate.org/dtd/hibernate-mapping-3.0.dtd\"&gt;&lt;hibernate-mapping package=\"com.lee.hibernate1.domain\"&gt; &lt;class name=\"Student\" table=\"student\"&gt; &lt;id name=\"sid\" column=\"sid\"&gt; &lt;!--主键自增长,使用数据库本地的自增长能力--&gt; &lt;generator class=\"native\"&gt;&lt;/generator&gt; &lt;/id&gt; &lt;property name=\"name\" column=\"sname\"&gt;&lt;/property&gt; &lt;property name=\"sex\" column=\"ssex\"&gt;&lt;/property&gt; &lt;property name=\"age\" column=\"sage\"&gt;&lt;/property&gt; &lt;property name=\"address\" column=\"saddress\"&gt;&lt;/property&gt; &lt;/class&gt;&lt;/hibernate-mapping&gt; ​ 创建hibernate.cfg.xml配置文件 123456789101112131415161718192021222324252627282930313233343536373839404142434445&lt;?xml version=\"1.0\" encoding=\"UTF-8\" ?&gt;&lt;!--导入约束文件文件 ,从从hibernate-core-5.2.16.Final包中找到--&gt;&lt;!DOCTYPE hibernate-configuration PUBLIC \"-//Hibernate/Hibernate Configuration DTD 3.0//EN\" \"http://www.hibernate.org/dtd/hibernate-configuration-3.0.dtd\"&gt;&lt;hibernate-configuration&gt; &lt;!--配置SessionFactory,它是数据库连接的会话对象,它是执行CRUD的对象--&gt; &lt;!--创建SessionFactory对象的三部分必须配置: 1.第一部分: 连接数据库的信息 2.第二部分 hibernate的可选配置 3.第三部分 映射配置文件的位置 --&gt; &lt;session-factory&gt; &lt;!--第一部分--&gt; &lt;!--JDBC驱动--&gt; &lt;property name=\"hibernate.connection.driver_class\"&gt;com.mysql.jdbc.Driver&lt;/property&gt; &lt;!--连接数据库的url--&gt; &lt;property name=\"hibernate.connection.url\"&gt;jdbc:mysql://localhost:3306/hibernate&lt;/property&gt; &lt;!--数据库的用户名--&gt; &lt;property name=\"hibernate.connection.username\"&gt;root&lt;/property&gt; &lt;!--登录数据库的密码--&gt; &lt;property name=\"hibernate.connection.password\"&gt;123&lt;/property&gt; &lt;!--#hibernate.dialect org.hibernate.dialect.MySQLDialect--&gt; &lt;!--&amp;lt;!&amp;ndash;配置数据库方言&amp;ndash;&amp;gt;--&gt; &lt;!--&lt;property name=\"hibernate.dialect\"&gt;org.hibernate.dialect.MySQL55Dialect&lt;/property&gt;--&gt; &lt;!--第二部分--&gt; &lt;!--是否在控制台显示生成的sql语句--&gt; &lt;property name=\"hibernate.show_sql\"&gt;true&lt;/property&gt; &lt;!--是否将控制台里的sql语句格式化输出--&gt; &lt;property name=\"hibernate.format_sql\"&gt;true&lt;/property&gt; &lt;!--采用何种方式生成DDL语句--&gt; &lt;!--其中update表示:检测实体类和表结构是否一致,如果不一致,更新表结构达到一致,如果不存在该表,就创建一张表--&gt; &lt;property name=\"hibernate.hbm2ddl.auto\"&gt;update&lt;/property&gt; &lt;!--第三部分--&gt; &lt;!--指定映射的bean配置文件的位置--&gt; &lt;!--如果有多个,就配置多个--&gt; &lt;mapping resource=\"com/lee/hibernate1/Student.hbm.xml\"/&gt; &lt;/session-factory&gt;&lt;/hibernate-configuration&gt; ​ 使用hibernate向数据库中插入数据的小练习 1234567891011121314151617181920212223public void test1() &#123; Student student = new Student(); student.setName(\"Lee\"); student.setAddress(\"安康市\"); student.setSex(\"男\");// 1. 解析主配置文件 Configuration configuration = new Configuration(); configuration.configure(); // 配置默认的配置文件,即为根目录下的hibernate.cfg.xml文件// 2.根据主配置文件,创建SessionFaction对象 SessionFactory factory = configuration.buildSessionFactory();// 3.创建Session Session session = factory.openSession();// 4.开启事务 Transaction transaction = session.beginTransaction();// 5.执行插入 session.save(student);// 6.提交事务 transaction.commit();// 7.释放资源 session.close(); factory.close(); &#125; Configuration配置配置文件 一般在hibernate.cfg.xml中配置的东西,在该对象中都是可以配置的,但是不推荐这么做,硬编码,后期维护升级很费事 SessionFactory 该对象在服务器启动(应用启动)的时候创建,在服务器关闭(应用卸载)的时候销毁,一个应用只存在一个实例 它是线程安全的 在创建SessionFactory以后对配置文件进行更改,将不会影响到该factory Session 一个线程只有一个对象 TransactionHibernate工具类Hibernate中CRUD操作Hibernate中的异常处理HibernateException继承了RuntimeException,这个异常可以不用捕获 Hibernate中配置c3p0连接池F:\\java资料\\SSH框架\\hibernate-release-5.2.16.Final\\project\\etc/hibernate.properties文件中查找配置格式(搜索c3p0) Hibernate中查询的get和load方法的区别查询时机不同,返回查询的结果不一样 get:立即加载 load:延迟加载(懒加载,惰性加载),返回的对象是增强对象(动态代理),增强了toString()方法;他也可以通过配置的方式改为立即加载 学习中遇到的问题及其结局方案: 使用的MySQL版本为5.5,使用Hibernate的版本为5.2.16,在配置hibernate.cfg.xml的时候12&lt;!--配置数据库方言--&gt;&lt;property name=\"hibernate.dialect\"&gt;org.hibernate.dialect.MySQL5Dialect&lt;/property&gt; 在MySQL版本为5.5及以上时,如果配置数据库方言,将org.hibernate.dialect.MySQLDialect改为上面的 org.hibernate.dialect.MySQL5Dialect 不然在hibernate创建表格的时候会报错. 或者这个配置项直接不配置也是可以的","categories":[],"tags":[{"name":"学习日记","slug":"学习日记","permalink":"https://blueleer.github.io/tags/学习日记/"},{"name":"错误解决","slug":"错误解决","permalink":"https://blueleer.github.io/tags/错误解决/"},{"name":"Hibernate","slug":"Hibernate","permalink":"https://blueleer.github.io/tags/Hibernate/"}]},{"title":"Java中的Pattern、Matcher、常用的正则表达式","slug":"Java中的Pattern、Matcher、常用的正则表达式","date":"2017-04-06T08:20:55.000Z","updated":"2018-04-13T12:10:31.304Z","comments":true,"path":"2017/04/06/Java中的Pattern、Matcher、常用的正则表达式/","link":"","permalink":"https://blueleer.github.io/2017/04/06/Java中的Pattern、Matcher、常用的正则表达式/","excerpt":"","text":"Java中的Pattern、Matcher、常用的正则表达式Java中的字符串已经有了直接调用简单匹配方法,matches方法(内部也是使用了Pattern.matches()方法) 123456String s = \"Java12Java34\";// 精确匹配,返回regex和s串是否完全匹配boolean isMatch = s.matches(\"Java\"); // 这里返回false// 在一定的范围内进行匹配// 参数的含义: 是否忽略大小写,s串的起始位置(offset),regex字符串,regex字符串的起始位置,取regex串的长度boolean isMatch2 = s.regionMatches(true, 6, \"Java\", 0, \"Java\".length()); // 返回true 但是很多时候String自带的这些方法不足于我们使用,此时Java中提供了Pattern和Matcher两个与正则表达式相关的类供我们使用 Pattern类12String regex = \"Java\";Pattern pattern = Pattern.compile(regex); Pattern.matches()静态方法123String regex = \"Java\";String s2 = \"Java123Java456Java789\";Pattern.matches(\"Java\", s2); // 注意这里也是全串精确匹配 其实这个方法和String中的matches()方法一致,其实String.matches()方法内部就是调用了此方法 split顾名思义就是分割字符串的方法,其中regex就是分割字符串的”刀”,注意当regex和字符串开始或者结尾部分匹配的时候会得到空字符串 123456789101112String regex = \"Java\";String s2 = \"Java123Java456Java789\";Pattern pattern = Pattern.compile(\"Java\");// split(input),分割字符串得到String数组String[] split = pattern.split(s2);System.out.println(split.length); // 输出3,[空串,123,456,789]String[] split1 = pattern.split(regex, 2);System.out.println(\"split1的长度为 : \" + split1.length); // 输出2,[空串,123Java456Java789],想想limit设置成3会怎样?// 注意:limit设置成0或者负数,效果默认一样,也就是和pattern.split(s2)一样 关于Pattern只介绍这两个方法,其他的可以自行创建demo试试 Matcher类1234String regex = \"Java\";String s = \"Java123Java456Java789\";Pattern pattern = Pattern.compile(regex);Matcher matcher1 = pattern.matcher(s); find()：尝试查找与该模式匹配的输入序列的的下一个子序列。重要,下面重点说 find(int start)：重置此匹配器，然后尝试查找匹配该模式、从指定索引开始的输入序列的下一个子序列。 group()：匹配成功返回的组,重要,下面重点说 start()：返回先前匹配的起始位置的索引。 end()：返回最后匹配字符的索引加一。 matches()：尝试将整个区域与模式匹配。匹配成功返回true lookingAt()：尝试将从区域开头开始的输入序列与该模式匹配。 replaceFirst()：替换掉匹配的第一个子序列 replaceAll()：替换掉匹配的全部子序列 appendReplacement：重要，下面重点说 appendTail(StringBuffer buf)：重要，下面重点说 reset():重置匹配器,从起始位置重新开始 reset(CharSequence input):重置匹配器,放入新的待匹配的串 部分方法解析 find()方法 注意:该方法尝试查找与该模式匹配的输入序列的下一个子序列.此方法从匹配器区域的开头开始，如果该方法的前一次调用成功了,并且从那时开始匹配器没有被重置，则从以前匹配操作没有匹配的第一个字符开始 12345678910111213String regex = \"Java.\";String s = \"Java1Java2\";Pattern pattern = Pattern.compile(regex);Matcher matcher1 = pattern.matcher(s);matcher1.find(); // 这里返回true// 其实此时我们可以使用下面的方式来循环获取匹配得到的子串while(matcher.find)&#123; // 循环查找,本次查找结束了,下次如果想获得查找结果应该重新执行find()方法 System.out.println(matcher.group()); // 关于group方法将在下面介绍&#125;// 上面的方法输出:Java1Java2 group()方法 这里介绍下组的概念：组是用括号划分的正则表达式，可以根据组的编号来引用这个组。组号为0表示整个表达式，组号为1表示被第一对括号括起的组，依次类推，例如A(B(C))D，组0是ABCD，组1是BC，组2是C。 Matcher类提供了start()，end()，group()分别用于返回字符串的起始索引，结束索引，以及匹配到到的字符串。 12345678String regex = \"(Java).*(Java)\";String s = \"Java123Java456\";Pattern pattern = Pattern.compile(regex);Matcher matcher2 = pattern.matcher(s);matcher2.find(); // 注意,这里需要先执行find方法System.out.println(matcher2.group()); // 如果find()方法执行返回true,则group()或者group(0)代表整个字符串s:Java123Java456System.out.println(matcher2.group(1)); // 输出 Java123System.out.println(matcher2.group(2)); // 输出Java456 appendReplacement(StringBuffer sb,String replacement)方法 先从字符串中执行查找,查找到了,替换成replacement,并从开始匹配的位置处将字符串写入StringBuffer中,示例入下: 12345678910111213141516171819String s = \"2018-4-10 15-45-30\";String regex = \"-\";Pattern pattern = Pattern.compile(regex);Matcher matcher = pattern.matcher(s);StringBuffer sb = new StringBuffer();matcher.find();matcher.appendReplacement(sb, \":\");System.out.println(sb.toString());matcher.find();matcher.appendReplacement(sb, \":\");System.out.println(sb.toString());matcher.find();matcher.appendReplacement(sb, \":\");System.out.println(sb.toString());输出入下:2018:2018:4:2018:4:10 15: 可以看到,它比String的replaceAll()或者replace()方法更加灵活 正则表达式语法请参考 Java 正则表达式","categories":[{"name":"Java","slug":"Java","permalink":"https://blueleer.github.io/categories/Java/"}],"tags":[{"name":"Java","slug":"Java","permalink":"https://blueleer.github.io/tags/Java/"},{"name":"Java正则表达式","slug":"Java正则表达式","permalink":"https://blueleer.github.io/tags/Java正则表达式/"}]},{"title":"Git版本控制工具的简单使用","slug":"Git版本控制工具的简单使用","date":"2016-11-07T14:08:04.000Z","updated":"2018-04-07T17:02:45.970Z","comments":true,"path":"2016/11/07/Git版本控制工具的简单使用/","link":"","permalink":"https://blueleer.github.io/2016/11/07/Git版本控制工具的简单使用/","excerpt":"","text":"虽然在Windows系统上安装的Git是可以在图形界面上进行操作的,但是我们并不应该这么做,Git的各种命令才是我们应该掌握的,而且将来我们不管换成什么样的操作系统,使用Git命令来操作都是通用的 1. 创建代码仓库初次打开Bash的时候我们应该配置身份 12git confing --global user.name \"yourname\"git confing --global user.email \"your email address\" 然后切换到你要上传到github的项目的根目录下,例如下面这个项目: 12cd f:cd android/BroadcastTest/ 然后输入下面的命令: 1git init 这样会在BroadcastTest目录下生成一个 .git 文件夹 2. 提交本地代码123git add AndroidManifest.xml # 将AndroidManifest.xml文件添加进本地仓库git add src # 将src目录添加进本地仓库git add . # 添加所有的文件到本地仓库 上面的添加只是将文件/文件夹添加到本地仓库,并没有提交: 1git commit -m \"first commit\" # 其中\"first commit\"是本次提交的描述,建议加上此次提交的描述,将来我们可以很方便的看到提交了什么 3. 忽略文件我们提交的时候,并不是该项目下所有的文件都得提交,例如 .idea 文件夹是不需要提交的,它是IDE自动生成的,那么怎么忽略掉这些文件呢? 第一步: 在BroadcastTest目录下创建 .gitignore文件 注意可能你在创建该文件的时候提示你”必须键入文件名,解决方法是: 在项目根目录下面创建gitignore.txt文件 把你需要排除的文件名保存到gitignore.txt文件 在项目根目录下面按住Shift键并鼠标右键选择“在此处打开命令窗口” 执行命令 ren gitignore.txt .gitignore 第二步:编辑.gitignore文件,将你想要忽略提交的文件或者文件夹加入 例如: 123bin/gen/*.html # 忽略所有的html文件,其中 \"*\" 为通配符,表示任意多个字符, \"?\" 代表一个字符, 方括号 [abc]代表可选字符范围 编辑好上面的.gitignore文件以后,执行 git add .就会自动将匹配上的文件或者文件夹忽略,然后执行 git commit -m &quot;Second commit with ignore&quot; 大功告成! 4. 查看修改内容在项目的开发阶段我们经常提交代码到仓库,理想的情况是每当完成了一小块功能的时候,就执行一次提交.当某个功能修改比较多的时候,写到后面可能我们已经忘记了本次到底修改了什么内容了,此时Git在帮你记着. git status 查看本次更改的概况 git diff src/lee/com/broadcasttest/Main.java 查看某个文件具体修改的内容,其中,减号代表删除的内容,加号代表添加的内容 5. 撤销未提交的修改每次完成一个功能以后,都会先执行 add命令添加进本地仓库 本次代码修改以后,只要未提交(也就是未执行add命令),都可以运行 git checkout src/lee/com/broadcasttest/Main.java 来撤销更改 上面的命令只能针对那些没有执行过add命令的文件有效,当某个文件已经add过了,此时需要先对其进行取消添加 git reset HEAD src/lee/com/broadcast/Main.java,然后在执行上面的 git checkout src/lee/com/broadcasttest/Main.java命令 6. 查看提交记录git log 当我们的提交较多的时候,可以指定该记录的id: git log 提交记录的id -1(注意这里要添加上-1) 在命令中添加-p参数,查看该条记录具体修改的内容: git log 提交记录的id -1 -p 7. 分支的用法git branch -a 查看当前的版本库中有哪些分支,版本库创建的时候默认只有一个分支 master git branch version1.0 创建一个名为 version1.0 的分支,虽然此时创建了一个新的分支version1.0,但是当前你所在的分支依然是master,使用下面的命令进行切花分支 git checkout version1.0 切换到version1.0的分支上 当你想把version1.0分支上所做的修改合并到master分支上,使用下面的命令进行 123git checkout master # 先切换到master分支上git merge version1.0 # 合并merge分支上的修改到master分支上,此时version1.0分支上的代码不会受到影响 # 另外,合并分支的时候可能会出现代码冲突的情况,此时应该慢慢查找那些冲突的代码,git 无力帮助我们 git branch -D version1.0 删除version1.0的分支 8. 与远程版本库协作上面的操作都是在本地完成的,只适合个人作为项目版本的控制方法 所有的版本控制工具最重要的一个特点就是可以使用它来进行团队合作开发,每个人的电脑上都会有一份代码,当团队的某个成员在自己的电脑上编写完成了某个功能后,就将代码提交到服务器,其他的成员只需要将服务器上的代码同步到本地,就能保证整个团队所有人的代码都相同.这样的话,每个成员就可以各司其职,完成每个人负责的模块,这样就可以共同完成一个庞大的项目. 现在,项目负责人在Git上创建了一个项目,项目地址为:https://github.com/BlueLeer/Crawler 将代码下载到本地: 1git clone https://github.com/BlueLeer/Crawler.git 之后,当你在这份代码的基础上完成了一些修改,使用下面的命令将本地修改的内容同步到版本库: 1git push origin master # 注意:该命令应该在上面本地代码根目录上执行,origin指的是远程Git地址,master指的是master分支,当然也可以是其他的分支 团队的其他成员对Git版本库中的代码也进行了修改,我们应该要养成经常从版本库中获取最新代码的习惯,那么怎么讲远程版本库中的修改同步到本地呢?使用下面的命令: 123git fetch origin master # fetch意为获取之意,但是注意:同步下来的代码并不会合并到本地的任何分支上,而是会存放在一个 origin/master# 分支上,此时可以先调用 git diff origin/master 查看远程版本库中到底修改了什么内容 之后调用 merge命令将origin/master分支上的修改合并到本地的master分支上即可: 1git merge origin/master 推荐使用上面的方法,当然下面的方法更简单,一步到位,那就是pull命令了,它其实相当于将fetch和merge两个命令放在一起执行了,它从远程的版本苦衷获取罪行的代码并合并到本地: 1git pull origin master 9.上传本地项目参考:github入门到上传本地项目","categories":[{"name":"其他","slug":"其他","permalink":"https://blueleer.github.io/categories/其他/"}],"tags":[{"name":"GitHub","slug":"GitHub","permalink":"https://blueleer.github.io/tags/GitHub/"}]},{"title":"在活动中使用菜单Menu和PopupMenu","slug":"在活动中使用菜单Menu和PopupMenu","date":"2016-11-01T15:55:32.000Z","updated":"2018-04-06T16:05:39.468Z","comments":true,"path":"2016/11/01/在活动中使用菜单Menu和PopupMenu/","link":"","permalink":"https://blueleer.github.io/2016/11/01/在活动中使用菜单Menu和PopupMenu/","excerpt":"","text":"在Activity中使用Menu和PopupMenu流程: 点击res目录新建Android resouce file文件,选择resoucetype为menu,然后可以创建如下菜单的布局: 12345678&lt;?xml version=\"1.0\" encoding=\"utf-8\"?&gt;&lt;menu xmlns:android=\"http://schemas.android.com/apk/res/android\"&gt; &lt;item android:id=\"@+id/refresh_item\" android:title=\"刷新\"/&gt; &lt;item android:id=\"@+id/change_city\" android:title=\"选择城市\"/&gt;&lt;/menu&gt; 然后在活动中重写onCreateOptionsMenu(Menu menu)方法: 12345public boolean onCreateOptionsMenu(Menu menu) &#123; //R.menu.menu就是menu的布局文件 getMenuInflater().inflate(R.menu.menu,menu); return true;&#125; ​ 然后在手机上点击”菜单”就可以弹出菜单了,该菜单是从屏幕底部弹出的. 当然我们也可以为点击菜单上的项目注册响应事件,通过重写onOptionsItemSelected()方法: 1234567891011public boolean onOptionsItemSelected(MenuItem item) &#123; switch(item.getItemId())&#123; case R.id.refresh_item: //加入逻辑 break; case R.id.change_city: //加入逻辑 break; &#125; return super.onOptionsItemSelected(item);&#125; 有时候我们希望通过点击屏幕上自己定义的一个组件弹出一个菜单来,并且这个菜单就在这个组件的周围,那么可以这么来写(还是使用刚刚我们定义的menu布局文件): 12345678910Button button = (Button)findViewById(R.id.refresh);//点击这个按钮就能弹出一个菜单来button.setOnClickListener(new View.OnClickListener()&#123; @Override public void onClick(View view) &#123; PopupMenu popupMenu = new PopupMenu(MainActivity.this,view); popupMenu.getMenuInflater().inflate(R.menu.menu,popupMenu.getMenu()); popupMenu.show(); &#125;&#125;); ​ ​ 在刷新按钮的周围弹出了一个菜单 ​ 当然我们也可以为PopupMenu响应点击事件: 12345678910popupMenu.setOnMenuItemClickListener(new PopupMenu.OnMenuItemClickListener() &#123; @Override public boolean onMenuItemClick(MenuItem menuItem) &#123; switch(menuItem.getId())&#123; case R.id.refresh_item //加入自己的逻辑(点击以后发生的事件) &#125; return false; &#125;&#125;);","categories":[{"name":"Android","slug":"Android","permalink":"https://blueleer.github.io/categories/Android/"}],"tags":[{"name":"Android","slug":"Android","permalink":"https://blueleer.github.io/tags/Android/"}]}]}