<?xml version="1.0" encoding="utf-8"?>
<search>
  <entry>
    <title><![CDATA[Hibernate学习笔记2]]></title>
    <url>%2F2018%2F04%2F09%2FHibernate%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B02%2F</url>
    <content type="text"><![CDATA[Hibernate–2学习内容: 实体类的编写规范(也称作为持久化类) 实体类的编写规范 类的成员变量声明为private 有默认的无参构造方法 可生成具有唯一标志oid的实例 提供get和set方法(也可以只设置只读方法或者只写方法) 用包装型数据类型替代基本类型,比如id类型应该用Long类型替代long类型 不要用final关键字修饰(否则延迟加载机制会失效) JavaBean 指的是用Java语言编写的可重用 hibernate中的对象标识符 Hibernate中oid的:指的是表字段中的主键,这个主键交给数据库底层或者Hibernate去生成,这样能够保证oid的一致性,同时对于持久化类,应该将id对应的set方法设置成private类型的(反射能够访问private类型的成员) hibernate中主键的生成方式 Hibernate的主键生成方式 自然主键和代理主键的区别 自然主键:区分记录,参与业务逻辑 代理主键:区分记录,不参与业务逻辑 hibernate的一级缓存和快照机制 调用Session的update(),save(),saveOrUpdate()方法时,如果Session缓存中没有相应的对象,Hibernate会自动的将刚刚添加进(更新)的数据添加到Session缓存中,以防临近时机调用不用再重复访问数据库 注意:如果设置了主键自动增长,此时再给对象设置主键字段是无效的 快照区其实相当于数据库的一部分数据的拷贝,他保存了数据库真实的数据,每次commit时,都会检查缓存和快照区的数据时候一致,如果不一致,更新数据库,同时更新快照去 hibernate中的对象状态(三种状态/四种状态) 瞬时状态:没有OID,没有和Session建立关系 持久状态:有OID,有缓存,并且对应的Session也没有关闭,在数据库中有对应的记录,每条记录对应一个唯一的持久态对象,注意它是在事务未提交之前形成的持久态的 脱管状态:某个持久态的实例与其相关联的Session被关闭时就形成了脱管状态,此时他就是一条独立于Hibernate的数据,它的改变与数据库没有什么关系 hibernate中的事务控制 解决的问题:让Session对象也符合使用原则(即一个线程只有一个Session对象) hibernate中的查询方式 查询多条记录的方式 共5种查询方式 OID查询 使用session的get(),load()方法进行查询 SQL查询 第一种:SQLQuery方式(使用的很少) 第二种:Session通过doWork()方法,可以拿到Connection对象 HQL查询(官方推荐的查询方式) Hibernate Query Language,使用Query对象查询 QBC查询 Query By Criteria,使用Criteria对象执行查询 对象导航查询 …… hibernate中的Query对象(重点) 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135/** * @CreateAuthor: KingIsHappy * @CreateDate: 2018/4/10 * @Description: 使用Session中的Query进行查询 * SQL:select * from cst_customer * HQL:select * from Customer * 将SQL中的表名换成映射的实体的类名,将将查询的字段名换成实体中对应的属性名 * &lt;p&gt; * 基本查询 * 条件查询 * 分页查询 * 排序查询 * 统计查询 * 投影查询 */public class Demo2 &#123; /* 基本查询 */ @Test public void test1() &#123; Session session = HibernateUtils.openSession(); Transaction transaction = session.beginTransaction();// Query query = session.createQuery("from Customer"); // 查询Customer实体对应的表中的所有的数据 Query query1 = session.createQuery("select cname,cage from Customer"); // 查询两个指定字段 List&lt;Object[]&gt; list = query1.getResultList(); for (Object[] ol : list) &#123; for (Object o : ol) &#123; System.out.println(o); &#125; &#125; transaction.commit(); &#125; /** * 条件查询 */ @Test public void test2() &#123; Session session = HibernateUtils.openSession(); Transaction ts = session.beginTransaction(); Query query = session.createQuery("from Customer where cname = ?"); query.setParameter(0, "马云"); // 从0开始(0代表第一个替换位置)// Query query = session.createQuery("from Customer where cname like ?");// query.setString(0,"%马%"); // 在HQL中将参数设置别名,然后再给参数赋值// Query query = session.createQuery("from Customer where cname like :likename");// query.setString("likename", "%马%"); List&lt;Customer&gt; list = query.list(); for (Customer c : list) &#123; System.out.println(c); &#125; ts.commit(); &#125; /** * 分页查询 */ @Test public void test3() &#123; Session session = HibernateUtils.openSession(); Transaction transaction = session.beginTransaction(); Query query = session.createQuery("select cid,cname from Customer "); query.setFirstResult(5);// 从索引为5的位置开始查 // 假如数据库中有1000条记录,你以此想把这1000条记录查出来,设置了setFetchSize(100) // 数据库每次回返回100条记录,当你需要下面的100条记录的时候,数据库才会加载下面的100条记录// query.setFetchSize(2); query.setMaxResults(2);// 每次查询返回的条数 List&lt;Object[]&gt; list = query.getResultList(); for (Object[] ol : list) &#123; for (Object o : ol) &#123; System.out.println(o); &#125; &#125; transaction.commit(); &#125; /** * 排序查询 */ @Test public void test4() &#123; Session session = HibernateUtils.openSession(); Transaction transaction = session.beginTransaction(); Query query = session.createQuery("from Customer order by cid desc "); List&lt;Customer&gt; list = query.list(); for (Customer c : list) &#123; System.out.println(c); &#125; transaction.commit(); &#125; /** * 统计查询 */ @Test public void test5() &#123; Session session = HibernateUtils.openSession(); Transaction transaction = session.beginTransaction();// Query query = session.createQuery("select count (*) from Customer "); Query query = session.createQuery("select avg (cage) from Customer "); // getSingleResult()只能接收一个结果,当结果超过1一个时就会报错 Object result = query.getSingleResult(); Object o = query.uniqueResult();// 效果和getSingleResult一样 System.out.println(result); transaction.commit(); &#125; /** * 投影查询 */ @Test public void test6() &#123; Session session = HibernateUtils.openSession(); Transaction transaction = session.beginTransaction(); // 给HQL传参的时候,创建一个新的对象,指定要查询的字段的名称,执行查询以后,默认返回一个封装好了的实体 Query query = session.createQuery("select new Customer (cname,cage) from Customer where cid = ?"); query.setParameter(0, 1L); Object result = query.getSingleResult(); System.out.println(result); transaction.commit(); &#125;&#125; ​ hibernate中的Criteria(标准、准则)对象 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154155156157158159160161162163164165166167168169170171172173174175176177178179180181182183184185/** * @CreateAuthor: KingIsHappy * @CreateDate: 2018/4/10 * @Description: 使用Session创建的Criteria进行查询(QBC查询) * Criteria是一个完全面向对象,可扩展的条件查询API,他完全不用考虑数据库底层是如何实现,以及SQL如何编写 * &lt;p&gt; * 基本查询 * 条件查询 * 分页查询 * 排序查询 * 统计查询 * 离线查询(不依赖Session产生一个DetachedCriteria对象(new得到),然后设置查询参数及条件) */public class Demo3 &#123; // * 基本查询(查询所有) @Test public void test1() &#123; Session session = HibernateUtils.openSession(); Transaction transaction = session.beginTransaction(); // 查询所有 Criteria criteria = session.createCriteria(Customer.class); List&lt;Customer&gt; list = criteria.list(); for (Customer c : list) &#123; System.out.println(c); &#125; transaction.commit(); session.close(); &#125; /** * 基本查询(session的createCriteria()方法已经过时的解决办法),官方建议使用Query,这相当于一个折中的方案,CriteriaQuery可以向Criteria一样 * 不用关心SQL怎么写,它可以像Criteria一样进行设置查询条件 */ @Test public void test11() &#123; Session session = HibernateUtils.openSession(); Transaction transaction = session.beginTransaction(); // 查询所有 CriteriaQuery&lt;Customer&gt; cquery = session.getCriteriaBuilder().createQuery(Customer.class); cquery.from(Customer.class); cquery.where();// cquery.where(); Query&lt;Customer&gt; query = session.createQuery(cquery); List&lt;Customer&gt; list = query.list(); for (Customer c : list) &#123; System.out.println(c); &#125; transaction.commit(); session.close(); &#125; // * 条件查询 @Test public void test2() &#123; Session session = HibernateUtils.openSession(); Transaction transaction = session.beginTransaction(); Criteria criteria = session.createCriteria(Customer.class); criteria.add(Restrictions.eq("cname", "马云")); List&lt;Customer&gt; list = criteria.list(); for (Customer c : list) &#123; System.out.println(c); &#125; transaction.commit(); session.close(); &#125; // * 分页查询 @Test public void test3() &#123; Session session = HibernateUtils.openSession(); Transaction transaction = session.beginTransaction(); Criteria criteria = session.createCriteria(Customer.class); criteria.setFirstResult(0); criteria.setMaxResults(5); List&lt;Customer&gt; list = criteria.list(); for (Customer c : list) &#123; System.out.println(c); &#125; transaction.commit(); session.close(); &#125; // * 排序查询 @Test public void test4() &#123; Session session = HibernateUtils.openSession(); Transaction transaction = session.beginTransaction(); Criteria criteria = session.createCriteria(Customer.class); criteria.addOrder(Order.desc("cid")); // 降序查询 List&lt;Customer&gt; list = criteria.list(); for (Customer c : list) &#123; System.out.println(c); &#125; transaction.commit(); session.close(); &#125; // * 统计查询(投影查询) @Test public void test5() &#123; Session session = HibernateUtils.openSession(); Transaction transaction = session.beginTransaction(); Criteria criteria = session.createCriteria(Customer.class); // 使用投影查询指定条目的个数 criteria.setProjection(Projections.count("cname")); Object o = criteria.uniqueResult(); System.out.println(o); transaction.commit(); session.close(); &#125; /** * 使用投影查询,查询指定的列 */ @Test public void test55() &#123; Session session = HibernateUtils.openSession(); Transaction transaction = session.beginTransaction(); Criteria criteria = session.createCriteria(Customer.class); criteria.setProjection(Projections.property("cname")); List list = criteria.list(); for (Object o : list) &#123; System.out.println(o); &#125; transaction.commit(); session.close(); &#125; // * 离线查询 /** * 思路:在表现层封装一个DetachedCriteria,将要封装的查询数据到其中 * 传递给服务层,服务层再传递给DAO层,DAO层将DetachedCriteria激活,编程Criteria对象,然后执行查询 */ @Test public void test6() &#123; List list = testServlet(); for (Object o : list) &#123; System.out.println(o); &#125; &#125; // 模拟Servlet public List testServlet() &#123; DetachedCriteria detachedCriteria = DetachedCriteria.forClass(Customer.class); detachedCriteria.add(Restrictions.eq("cname", "马云")); List list = null; try &#123; list = testService(detachedCriteria); &#125; catch (Exception e) &#123; e.printStackTrace(); &#125; return list; &#125; // 模拟Service // 在服务中开启事务,事务的处理在业务层 public List testService(DetachedCriteria detachedCriteria) throws Exception &#123; Session session = HibernateUtils.getCurrentSession(); Transaction transaction = null; try &#123; transaction = session.beginTransaction(); List list = testDao(detachedCriteria); transaction.commit(); return list; &#125; catch (HibernateException e) &#123; transaction.rollback(); throw new Exception(e); &#125; &#125; // 模拟DAO private List testDao(DetachedCriteria detachedCriteria) &#123; Session session = HibernateUtils.getCurrentSession(); Criteria executableCriteria = detachedCriteria.getExecutableCriteria(session); return executableCriteria.list(); &#125;&#125; ​ ​ ​ ​ ​]]></content>
      <categories>
        <category>Java</category>
      </categories>
      <tags>
        <tag>学习日记</tag>
        <tag>错误解决</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Hibernate学习笔记1]]></title>
    <url>%2F2018%2F04%2F08%2FHibernate%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B01%2F</url>
    <content type="text"><![CDATA[Hibernate–1学习内容: Hibernate相关jar包的依赖 创建表和实体之间的映射配置文件Student.hbm.xml 1234567891011121314151617&lt;?xml version="1.0" encoding="UTF-8" ?&gt;&lt;!--指定命名空间,从hibernate-core-5.2.16.Final包中找--&gt;&lt;!DOCTYPE hibernate-mapping PUBLIC "-//Hibernate/Hibernate Mapping DTD 3.0//EN" "http://www.hibernate.org/dtd/hibernate-mapping-3.0.dtd"&gt;&lt;hibernate-mapping package="com.lee.hibernate1.domain"&gt; &lt;class name="Student" table="student"&gt; &lt;id name="sid" column="sid"&gt; &lt;!--主键自增长,使用数据库本地的自增长能力--&gt; &lt;generator class="native"&gt;&lt;/generator&gt; &lt;/id&gt; &lt;property name="name" column="sname"&gt;&lt;/property&gt; &lt;property name="sex" column="ssex"&gt;&lt;/property&gt; &lt;property name="age" column="sage"&gt;&lt;/property&gt; &lt;property name="address" column="saddress"&gt;&lt;/property&gt; &lt;/class&gt;&lt;/hibernate-mapping&gt; ​ 创建hibernate.cfg.xml配置文件 123456789101112131415161718192021222324252627282930313233343536373839404142434445&lt;?xml version="1.0" encoding="UTF-8" ?&gt;&lt;!--导入约束文件文件 ,从从hibernate-core-5.2.16.Final包中找到--&gt;&lt;!DOCTYPE hibernate-configuration PUBLIC "-//Hibernate/Hibernate Configuration DTD 3.0//EN" "http://www.hibernate.org/dtd/hibernate-configuration-3.0.dtd"&gt;&lt;hibernate-configuration&gt; &lt;!--配置SessionFactory,它是数据库连接的会话对象,它是执行CRUD的对象--&gt; &lt;!--创建SessionFactory对象的三部分必须配置: 1.第一部分: 连接数据库的信息 2.第二部分 hibernate的可选配置 3.第三部分 映射配置文件的位置 --&gt; &lt;session-factory&gt; &lt;!--第一部分--&gt; &lt;!--JDBC驱动--&gt; &lt;property name="hibernate.connection.driver_class"&gt;com.mysql.jdbc.Driver&lt;/property&gt; &lt;!--连接数据库的url--&gt; &lt;property name="hibernate.connection.url"&gt;jdbc:mysql://localhost:3306/hibernate&lt;/property&gt; &lt;!--数据库的用户名--&gt; &lt;property name="hibernate.connection.username"&gt;root&lt;/property&gt; &lt;!--登录数据库的密码--&gt; &lt;property name="hibernate.connection.password"&gt;123&lt;/property&gt; &lt;!--#hibernate.dialect org.hibernate.dialect.MySQLDialect--&gt; &lt;!--&amp;lt;!&amp;ndash;配置数据库方言&amp;ndash;&amp;gt;--&gt; &lt;!--&lt;property name="hibernate.dialect"&gt;org.hibernate.dialect.MySQL5Dialect&lt;/property&gt;--&gt; &lt;!--第二部分--&gt; &lt;!--是否在控制台显示生成的sql语句--&gt; &lt;property name="hibernate.show_sql"&gt;true&lt;/property&gt; &lt;!--是否将控制台里的sql语句格式化输出--&gt; &lt;property name="hibernate.format_sql"&gt;true&lt;/property&gt; &lt;!--采用何种方式生成DDL语句--&gt; &lt;!--其中update表示:检测实体类和表结构是否一致,如果不一致,更新表结构达到一致,如果不存在该表,就创建一张表--&gt; &lt;property name="hibernate.hbm2ddl.auto"&gt;update&lt;/property&gt; &lt;!--第三部分--&gt; &lt;!--指定映射的bean配置文件的位置--&gt; &lt;!--如果有多个,就配置多个--&gt; &lt;mapping resource="com/lee/hibernate1/Student.hbm.xml"/&gt; &lt;/session-factory&gt;&lt;/hibernate-configuration&gt; ​ 使用hibernate向数据库中插入数据的小练习 1234567891011121314151617181920212223public void test1() &#123; Student student = new Student(); student.setName("Lee"); student.setAddress("安康市"); student.setSex("男");// 1. 解析主配置文件 Configuration configuration = new Configuration(); configuration.configure(); // 配置默认的配置文件,即为根目录下的hibernate.cfg.xml文件// 2.根据主配置文件,创建SessionFaction对象 SessionFactory factory = configuration.buildSessionFactory();// 3.创建Session Session session = factory.openSession();// 4.开启事务 Transaction transaction = session.beginTransaction();// 5.执行插入 session.save(student);// 6.提交事务 transaction.commit();// 7.释放资源 session.close(); factory.close(); &#125; Configuration配置配置文件 一般在hibernate.cfg.xml中配置的东西,在该对象中都是可以配置的,但是不推荐这么做,硬编码,后期维护升级很费事 SessionFactory 该对象在服务器启动(应用启动)的时候创建,在服务器关闭(应用卸载)的时候销毁,一个应用只存在一个实例 它是线程安全的 在创建SessionFactory以后对配置文件进行更改,将不会影响到该factory Session 一个线程只有一个对象 TransactionHibernate工具类Hibernate中CRUD操作Hibernate中的异常处理HibernateException继承了RuntimeException,这个异常可以不用捕获 Hibernate中配置c3p0连接池F:\java资料\SSH框架\hibernate-release-5.2.16.Final\project\etc/hibernate.properties文件中查找配置格式(搜索c3p0) Hibernate中查询的get和load方法的区别查询时机不同,返回查询的结果不一样 get:立即加载 load:延迟加载(懒加载,惰性加载),返回的对象是增强对象(动态代理),增强了toString()方法;他也可以通过配置的方式改为立即加载 学习中遇到的问题及其结局方案: 使用的MySQL版本为5.5,使用Hibernate的版本为5.2.16,在配置hibernate.cfg.xml的时候12&lt;!--配置数据库方言--&gt;&lt;property name="hibernate.dialect"&gt;org.hibernate.dialect.MySQL5Dialect&lt;/property&gt; 在MySQL版本为5.5及以上时,如果配置数据库方言,将org.hibernate.dialect.MySQLDialect改为上面的 org.hibernate.dialect.MySQL5Dialect 不然在hibernate创建表格的时候会报错. 或者这个配置项直接不配置也是可以的]]></content>
      <tags>
        <tag>学习日记</tag>
        <tag>错误解决</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[SSH框架学习之Struts2--第一天]]></title>
    <url>%2F2018%2F04%2F08%2FSSH%E6%A1%86%E6%9E%B6%E5%AD%A6%E4%B9%A0%E4%B9%8BStruts2-%E7%AC%AC%E4%B8%80%E5%A4%A9%2F</url>
    <content type="text"></content>
      <categories>
        <category>Java</category>
      </categories>
      <tags>
        <tag>Struts2</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[回车和换行]]></title>
    <url>%2F2018%2F04%2F07%2F%E5%9B%9E%E8%BD%A6%E5%92%8C%E6%8D%A2%E8%A1%8C%2F</url>
    <content type="text"><![CDATA[今天在做爬虫的时候,需要匹配下面Title中的内容,发现写的正则表达式question_link(.)&gt;(\n)(.+)(\n*)&lt;竟然匹配不上里面的中文,原来在win系统中文件中的换行其实包含了两个字符, /CR(回车),/LF(换行),这两个”.”都是匹配不上的. 123&lt;h2&gt;&lt;a class="question_link" href="/question/270597366/answer/355546388" data-id="22407872" data-za-element-name="Title"&gt;如何看待星巴克被指含有致癌物质（丙烯酰胺Acrylamide）？&lt;/a&gt;&lt;/h2&gt; 修改成下面,成功匹配 1question_link(.*)&gt;(\r)(\n)(.*) 完整代码为: 1234567891011121314// 其中这段是从文件中摘录的,文件中查看特殊符号显示了换行包含两个字符 一个回车一个换行String s = "&lt;h2&gt;&lt;a class="question_link" href="/question/270597366/answer/355546388" data-id="22407872" data-za-element-name="Title"&gt;如何看待星巴克被指含有致癌物质（丙烯酰胺Acrylamide）？&lt;/a&gt;&lt;/h2&gt;" String regex = "question_link(.*)&gt;(\\r)(\\n)(.*)";Pattern pattern = Pattern.compile(regex);Matcher matcher = pattern.matcher(sb.toString());matcher.find();String group = matcher.group(4);System.out.println(group);// 输出:// 如何看待星巴克被指含有致癌物质（丙烯酰胺Acrylamide）？ 小示例: 123456789String s1 = "\r1234\r567";String s2 = "\n12345";System.out.println(s1);System.out.println(s2);// 输出:56712345 再次强调,回车和换行,”.”都不能匹配 1234567String s1 = "\r1234\r567";String regex = ".*";String regex1 = "\\r.*";Pattern pattern = Pattern.compile(regex1); // 换成regex则下面的输出为空,也就是不能匹配Matcher matcher = pattern.matcher(s1);matcher.find();System.out.println(matcher.group()); 更多知识请参考: 终于搞懂了回车与换行的区别]]></content>
      <categories>
        <category>其他</category>
      </categories>
      <tags>
        <tag>计算机</tag>
        <tag>其他</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[hexo主题之next主题的配置]]></title>
    <url>%2F2018%2F04%2F06%2Fhexo%E4%B8%BB%E9%A2%98%E4%B9%8Bnext%E4%B8%BB%E9%A2%98%E7%9A%84%E9%85%8D%E7%BD%AE%2F</url>
    <content type="text"><![CDATA[关于 hexo 主题之next主题 GiuHub地址 Next主题配置官网文档 hexo的next主题个性化教程:打造炫酷网站 另外附上大致的使用GitHub Pages建站的流程: 注册GitHub账号 创建 YourName.github.io库,GitHub默认把它当做静态html托管仓库(我们实际上也仅仅是在它上面托管我们的静态网页,它还能够识别解析css和js文件) 在GitHub上生成 SSH Keys (后面使用的hexo在本地拥有了一个SSH Keys的拷贝,这样就可以实现快速部署到pages仓库) 安装hexo,推荐参考 hexo官方文档 这样可以少走很多弯路,遇到问题了再去查解决方法 然后就可以找一款自己喜欢的主题啦 hexo官网,这上面有很全的plug插件和theme主题,也可以参考别人的推荐,我就用的是GitHub上star数醉的的一款next]]></content>
      <categories>
        <category>其他</category>
      </categories>
      <tags>
        <tag>hexo主题配置</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Java中的Pattern、Matcher、常用的正则表达式]]></title>
    <url>%2F2018%2F04%2F06%2FJava%E4%B8%AD%E7%9A%84Pattern%E3%80%81Matcher%E3%80%81%E5%B8%B8%E7%94%A8%E7%9A%84%E6%AD%A3%E5%88%99%E8%A1%A8%E8%BE%BE%E5%BC%8F%2F</url>
    <content type="text"><![CDATA[Java中的Pattern、Matcher、常用的正则表达式Java中的字符串已经有了直接调用简单匹配方法,matches方法(内部也是使用了Pattern.matches()方法) 123456String s = "Java12Java34";// 精确匹配,返回regex和s串是否完全匹配boolean isMatch = s.matches("Java"); // 这里返回false// 在一定的范围内进行匹配// 参数的含义: 是否忽略大小写,s串的起始位置(offset),regex字符串,regex字符串的起始位置,取regex串的长度boolean isMatch2 = s.regionMatches(true, 6, "Java", 0, "Java".length()); // 返回true 但是很多时候String自带的这些方法不足于我们使用,此时Java中提供了Pattern和Matcher两个与正则表达式相关的类供我们使用 Pattern类12String regex = "Java";Pattern pattern = Pattern.compile(regex); Pattern.matches()静态方法123String regex = "Java";String s2 = "Java123Java456Java789";Pattern.matches("Java", s2); // 注意这里也是全串精确匹配 其实这个方法和String中的matches()方法一致,其实String.matches()方法内部就是调用了此方法 split顾名思义就是分割字符串的方法,其中regex就是分割字符串的”刀”,注意当regex和字符串开始或者结尾部分匹配的时候会得到空字符串 123456789101112String regex = "Java";String s2 = "Java123Java456Java789";Pattern pattern = Pattern.compile("Java");// split(input),分割字符串得到String数组String[] split = pattern.split(s2);System.out.println(split.length); // 输出3,[空串,123,456,789]String[] split1 = pattern.split(regex, 2);System.out.println("split1的长度为 : " + split1.length); // 输出2,[空串,123Java456Java789],想想limit设置成3会怎样?// 注意:limit设置成0或者负数,效果默认一样,也就是和pattern.split(s2)一样 关于Pattern只介绍这两个方法,其他的可以自行创建demo试试 Matcher类1234String regex = "Java";String s = "Java123Java456Java789";Pattern pattern = Pattern.compile(regex);Matcher matcher1 = pattern.matcher(s); find()：尝试查找与该模式匹配的输入序列的的下一个子序列。重要,下面重点说 find(int start)：重置此匹配器，然后尝试查找匹配该模式、从指定索引开始的输入序列的下一个子序列。 group()：匹配成功返回的组,重要,下面重点说 start()：返回先前匹配的起始位置的索引。 end()：返回最后匹配字符的索引加一。 matches()：尝试将整个区域与模式匹配。匹配成功返回true lookingAt()：尝试将从区域开头开始的输入序列与该模式匹配。 replaceFirst()：替换掉匹配的第一个子序列 replaceAll()：替换掉匹配的全部子序列 appendReplacement：重要，下面重点说 appendTail(StringBuffer buf)：重要，下面重点说 reset():重置匹配器,从起始位置重新开始 reset(CharSequence input):重置匹配器,放入新的待匹配的串 部分方法解析 find()方法 注意:该方法尝试查找与该模式匹配的输入序列的下一个子序列.此方法从匹配器区域的开头开始，如果该方法的前一次调用成功了,并且从那时开始匹配器没有被重置，则从以前匹配操作没有匹配的第一个字符开始 12345678910111213String regex = "Java.";String s = "Java1Java2";Pattern pattern = Pattern.compile(regex);Matcher matcher1 = pattern.matcher(s);matcher1.find(); // 这里返回true// 其实此时我们可以使用下面的方式来循环获取匹配得到的子串while(matcher.find)&#123; // 循环查找,本次查找结束了,下次如果想获得查找结果应该重新执行find()方法 System.out.println(matcher.group()); // 关于group方法将在下面介绍&#125;// 上面的方法输出:Java1Java2 group()方法 这里介绍下组的概念：组是用括号划分的正则表达式，可以根据组的编号来引用这个组。组号为0表示整个表达式，组号为1表示被第一对括号括起的组，依次类推，例如A(B(C))D，组0是ABCD，组1是BC，组2是C。 Matcher类提供了start()，end()，group()分别用于返回字符串的起始索引，结束索引，以及匹配到到的字符串。 12345678String regex = "(Java).*(Java)";String s = "Java123Java456";Pattern pattern = Pattern.compile(regex);Matcher matcher2 = pattern.matcher(s);matcher2.find(); // 注意,这里需要先执行find方法System.out.println(matcher2.group()); // 如果find()方法执行返回true,则group()或者group(0)代表整个字符串s:Java123Java456System.out.println(matcher2.group(1)); // 输出 Java123System.out.println(matcher2.group(2)); // 输出Java456 appendReplacement(StringBuffer sb,String replacement)方法 先从字符串中执行查找,查找到了,替换成replacement,并从开始匹配的位置处将字符串写入StringBuffer中,示例入下: 12345678910111213141516171819String s = "2018-4-10 15-45-30";String regex = "-";Pattern pattern = Pattern.compile(regex);Matcher matcher = pattern.matcher(s);StringBuffer sb = new StringBuffer();matcher.find();matcher.appendReplacement(sb, ":");System.out.println(sb.toString());matcher.find();matcher.appendReplacement(sb, ":");System.out.println(sb.toString());matcher.find();matcher.appendReplacement(sb, ":");System.out.println(sb.toString());输出入下:2018:2018:4:2018:4:10 15: 可以看到,它比String的replaceAll()或者replace()方法更加灵活 正则表达式语法请参考 Java 正则表达式]]></content>
      <categories>
        <category>Java</category>
      </categories>
      <tags>
        <tag>Java</tag>
        <tag>Java正则表达式</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Git版本控制工具的简单使用]]></title>
    <url>%2F2016%2F11%2F07%2FGit%E7%89%88%E6%9C%AC%E6%8E%A7%E5%88%B6%E5%B7%A5%E5%85%B7%E7%9A%84%E7%AE%80%E5%8D%95%E4%BD%BF%E7%94%A8%2F</url>
    <content type="text"><![CDATA[虽然在Windows系统上安装的Git是可以在图形界面上进行操作的,但是我们并不应该这么做,Git的各种命令才是我们应该掌握的,而且将来我们不管换成什么样的操作系统,使用Git命令来操作都是通用的 1. 创建代码仓库初次打开Bash的时候我们应该配置身份 12git confing --global user.name "yourname"git confing --global user.email "your email address" 然后切换到你要上传到github的项目的根目录下,例如下面这个项目: 12cd f:cd android/BroadcastTest/ 然后输入下面的命令: 1git init 这样会在BroadcastTest目录下生成一个 .git 文件夹 2. 提交本地代码123git add AndroidManifest.xml # 将AndroidManifest.xml文件添加进本地仓库git add src # 将src目录添加进本地仓库git add . # 添加所有的文件到本地仓库 上面的添加只是将文件/文件夹添加到本地仓库,并没有提交: 1git commit -m "first commit" # 其中"first commit"是本次提交的描述,建议加上此次提交的描述,将来我们可以很方便的看到提交了什么 3. 忽略文件我们提交的时候,并不是该项目下所有的文件都得提交,例如 .idea 文件夹是不需要提交的,它是IDE自动生成的,那么怎么忽略掉这些文件呢? 第一步: 在BroadcastTest目录下创建 .gitignore文件 注意可能你在创建该文件的时候提示你”必须键入文件名,解决方法是: 在项目根目录下面创建gitignore.txt文件 把你需要排除的文件名保存到gitignore.txt文件 在项目根目录下面按住Shift键并鼠标右键选择“在此处打开命令窗口” 执行命令 ren gitignore.txt .gitignore 第二步:编辑.gitignore文件,将你想要忽略提交的文件或者文件夹加入 例如: 123bin/gen/*.html # 忽略所有的html文件,其中 "*" 为通配符,表示任意多个字符, "?" 代表一个字符, 方括号 [abc]代表可选字符范围 编辑好上面的.gitignore文件以后,执行 git add .就会自动将匹配上的文件或者文件夹忽略,然后执行 git commit -m &quot;Second commit with ignore&quot; 大功告成! 4. 查看修改内容在项目的开发阶段我们经常提交代码到仓库,理想的情况是每当完成了一小块功能的时候,就执行一次提交.当某个功能修改比较多的时候,写到后面可能我们已经忘记了本次到底修改了什么内容了,此时Git在帮你记着. git status 查看本次更改的概况 git diff src/lee/com/broadcasttest/Main.java 查看某个文件具体修改的内容,其中,减号代表删除的内容,加号代表添加的内容 5. 撤销未提交的修改每次完成一个功能以后,都会先执行 add命令添加进本地仓库 本次代码修改以后,只要未提交(也就是未执行add命令),都可以运行 git checkout src/lee/com/broadcasttest/Main.java 来撤销更改 上面的命令只能针对那些没有执行过add命令的文件有效,当某个文件已经add过了,此时需要先对其进行取消添加 git reset HEAD src/lee/com/broadcast/Main.java,然后在执行上面的 git checkout src/lee/com/broadcasttest/Main.java命令 6. 查看提交记录git log 当我们的提交较多的时候,可以指定该记录的id: git log 提交记录的id -1(注意这里要添加上-1) 在命令中添加-p参数,查看该条记录具体修改的内容: git log 提交记录的id -1 -p 7. 分支的用法git branch -a 查看当前的版本库中有哪些分支,版本库创建的时候默认只有一个分支 master git branch version1.0 创建一个名为 version1.0 的分支,虽然此时创建了一个新的分支version1.0,但是当前你所在的分支依然是master,使用下面的命令进行切花分支 git checkout version1.0 切换到version1.0的分支上 当你想把version1.0分支上所做的修改合并到master分支上,使用下面的命令进行 123git checkout master # 先切换到master分支上git merge version1.0 # 合并merge分支上的修改到master分支上,此时version1.0分支上的代码不会受到影响 # 另外,合并分支的时候可能会出现代码冲突的情况,此时应该慢慢查找那些冲突的代码,git 无力帮助我们 git branch -D version1.0 删除version1.0的分支 8. 与远程版本库协作上面的操作都是在本地完成的,只适合个人作为项目版本的控制方法 所有的版本控制工具最重要的一个特点就是可以使用它来进行团队合作开发,每个人的电脑上都会有一份代码,当团队的某个成员在自己的电脑上编写完成了某个功能后,就将代码提交到服务器,其他的成员只需要将服务器上的代码同步到本地,就能保证整个团队所有人的代码都相同.这样的话,每个成员就可以各司其职,完成每个人负责的模块,这样就可以共同完成一个庞大的项目. 现在,项目负责人在Git上创建了一个项目,项目地址为:https://github.com/BlueLeer/Crawler 将代码下载到本地: 1git clone https://github.com/BlueLeer/Crawler.git 之后,当你在这份代码的基础上完成了一些修改,使用下面的命令将本地修改的内容同步到版本库: 1git push origin master # 注意:该命令应该在上面本地代码根目录上执行,origin指的是远程Git地址,master指的是master分支,当然也可以是其他的分支 团队的其他成员对Git版本库中的代码也进行了修改,我们应该要养成经常从版本库中获取最新代码的习惯,那么怎么讲远程版本库中的修改同步到本地呢?使用下面的命令: 123git fetch origin master # fetch意为获取之意,但是注意:同步下来的代码并不会合并到本地的任何分支上,而是会存放在一个 origin/master# 分支上,此时可以先调用 git diff origin/master 查看远程版本库中到底修改了什么内容 之后调用 merge命令将origin/master分支上的修改合并到本地的master分支上即可: 1git merge origin/master 推荐使用上面的方法,当然下面的方法更简单,一步到位,那就是pull命令了,它其实相当于将fetch和merge两个命令放在一起执行了,它从远程的版本苦衷获取罪行的代码并合并到本地: 1git pull origin master 9.上传本地项目参考:github入门到上传本地项目]]></content>
      <categories>
        <category>其他</category>
      </categories>
      <tags>
        <tag>GitHub</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[在活动中使用菜单Menu和PopupMenu]]></title>
    <url>%2F2016%2F11%2F01%2F%E5%9C%A8%E6%B4%BB%E5%8A%A8%E4%B8%AD%E4%BD%BF%E7%94%A8%E8%8F%9C%E5%8D%95Menu%E5%92%8CPopupMenu%2F</url>
    <content type="text"><![CDATA[在Activity中使用Menu和PopupMenu流程: 点击res目录新建Android resouce file文件,选择resoucetype为menu,然后可以创建如下菜单的布局: 12345678&lt;?xml version="1.0" encoding="utf-8"?&gt;&lt;menu xmlns:android="http://schemas.android.com/apk/res/android"&gt; &lt;item android:id="@+id/refresh_item" android:title="刷新"/&gt; &lt;item android:id="@+id/change_city" android:title="选择城市"/&gt;&lt;/menu&gt; 然后在活动中重写onCreateOptionsMenu(Menu menu)方法: 12345public boolean onCreateOptionsMenu(Menu menu) &#123; //R.menu.menu就是menu的布局文件 getMenuInflater().inflate(R.menu.menu,menu); return true;&#125; ​ 然后在手机上点击”菜单”就可以弹出菜单了,该菜单是从屏幕底部弹出的. 当然我们也可以为点击菜单上的项目注册响应事件,通过重写onOptionsItemSelected()方法: 1234567891011public boolean onOptionsItemSelected(MenuItem item) &#123; switch(item.getItemId())&#123; case R.id.refresh_item: //加入逻辑 break; case R.id.change_city: //加入逻辑 break; &#125; return super.onOptionsItemSelected(item);&#125; 有时候我们希望通过点击屏幕上自己定义的一个组件弹出一个菜单来,并且这个菜单就在这个组件的周围,那么可以这么来写(还是使用刚刚我们定义的menu布局文件): 12345678910Button button = (Button)findViewById(R.id.refresh);//点击这个按钮就能弹出一个菜单来button.setOnClickListener(new View.OnClickListener()&#123; @Override public void onClick(View view) &#123; PopupMenu popupMenu = new PopupMenu(MainActivity.this,view); popupMenu.getMenuInflater().inflate(R.menu.menu,popupMenu.getMenu()); popupMenu.show(); &#125;&#125;); ​ ​ 在刷新按钮的周围弹出了一个菜单 ​ 当然我们也可以为PopupMenu响应点击事件: 12345678910popupMenu.setOnMenuItemClickListener(new PopupMenu.OnMenuItemClickListener() &#123; @Override public boolean onMenuItemClick(MenuItem menuItem) &#123; switch(menuItem.getId())&#123; case R.id.refresh_item //加入自己的逻辑(点击以后发生的事件) &#125; return false; &#125;&#125;);]]></content>
      <categories>
        <category>Android</category>
      </categories>
      <tags>
        <tag>Android</tag>
      </tags>
  </entry>
</search>
