<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>Coding...Coding...</title>
  <icon>https://www.gravatar.com/avatar/186e8a9967ddc3f700ba1e47b6be9b34</icon>
  <subtitle>个人博客</subtitle>
  <link href="/atom.xml" rel="self"/>
  
  <link href="https://blueleer.github.io/"/>
  <updated>2018-04-26T07:16:19.785Z</updated>
  <id>https://blueleer.github.io/</id>
  
  <author>
    <name>KingIsHappy</name>
    <email>251668577@qq.com</email>
  </author>
  
  <generator uri="http://hexo.io/">Hexo</generator>
  
  <entry>
    <title>《Spring实战》（第四版）读书笔记</title>
    <link href="https://blueleer.github.io/2018/04/21/%E3%80%8ASpring%E5%AE%9E%E6%88%98%E3%80%8B%EF%BC%88%E7%AC%AC%E5%9B%9B%E7%89%88%EF%BC%89%E8%AF%BB%E4%B9%A6%E7%AC%94%E8%AE%B0/"/>
    <id>https://blueleer.github.io/2018/04/21/《Spring实战》（第四版）读书笔记/</id>
    <published>2018-04-21T06:42:36.000Z</published>
    <updated>2018-04-26T07:16:19.785Z</updated>
    
    <content type="html"><![CDATA[<h1 id="第1章-Spring之旅"><a href="#第1章-Spring之旅" class="headerlink" title="第1章 Spring之旅"></a>第1章 Spring之旅</h1><p><strong>两大核心</strong></p><ul><li>依赖注入(Dependency injection,DI)</li><li>面向切面编程(aspect-oriented-programming,AOP)</li></ul><p><strong>发展历程:</strong></p><ul><li>创建Spring的主要目的是用来<strong>替代更加重量级的企业级Java技术</strong>，尤其是EJB。相对于EJB说,Spring提供了更加轻量级和简单的编程模型。它<strong>增强了简单老式Java对象</strong>（Plain Old Java object，POJO）的功能，使<strong>其具备了之前只有EJB和其他企业级Java规范才具有的功能</strong>。</li><li>随着时间的推移，EJB以及Java 2企业版（Java 2 Enterprise Edition，J2EE）在不断演化。EJB自身也提供了面向简单POJO的编程模型。现在，EJB也采用了依赖注入（Dependency Injection，DI）和面向切面编程（Aspect-Oriented Programming，AOP）的理念，这毫无疑问是受到Spring成功的启发。</li><li>尽管J2EE（现在称之为JEE）能够赶上Spring的步伐，但Spring也没有停止前进。Spring继续在其他领域发展，而JEE则刚刚开始涉及这些领域，或者还完全没有开始在这些领域的创新。移动开发、社交API集成、NoSQL数据库、云计算以及大数据都是Spring正在涉足和创新的领域。Spring的前景依然会很美好。</li></ul><h2 id="1-1-简化Java开发"><a href="#1-1-简化Java开发" class="headerlink" title="1.1 简化Java开发"></a>1.1 简化Java开发</h2><p>为了降低Java开发的复杂性,Spring采取了下面四种关键性策略</p><ul><li>基于POJO的轻量级和最小侵入性编程；</li><li>通过依赖注入和面向接口实现松耦合；</li><li>基于切面和惯例进行声明式编程；</li><li>通过切面和模板减少样板式代码。</li></ul><blockquote><p>POJO:plain old java object,简单老实Java对象。使用POJO名称是为了避免和<a href="https://baike.baidu.com/item/EJB" target="_blank" rel="noopener">EJB</a>混淆起来, 而且简称比较直接. 其中<strong>有一些属性及其getter setter方法的类,没有业务逻辑</strong>，有时可以作为<a href="https://baike.baidu.com/item/VO" target="_blank" rel="noopener">VO</a>(value -object)或<a href="https://baike.baidu.com/item/dto" target="_blank" rel="noopener">dto</a>(Data Transform Object)来使用.当然,如果你有一个简单的运算属性也是可以的,但不允许有业务方法,也不能携带有connection之类的方法。</p></blockquote><h3 id="1-1-1-基于POJO的轻量级和最小侵入性编程"><a href="#1-1-1-基于POJO的轻量级和最小侵入性编程" class="headerlink" title="1.1.1 基于POJO的轻量级和最小侵入性编程"></a>1.1.1 基于POJO的轻量级和最小侵入性编程</h3><p><strong>侵入式框架</strong>：框架通过强迫应用继承它们的类或实现它们的接口从而导致应用与框架绑死。例如：struts框架。</p><p><strong>非侵入式框架</strong>：不会强迫的让你继承框架提供的类或者接口，你一样可以使用，简而言之，拿来即用，不用去修改你原来的代码。例如：Hibernate框架，Spring框架等等。</p><h3 id="1-1-2-通过依赖注入和面向接口实现松耦合"><a href="#1-1-2-通过依赖注入和面向接口实现松耦合" class="headerlink" title="1.1.2 通过依赖注入和面向接口实现松耦合"></a>1.1.2 通过依赖注入和面向接口实现松耦合</h3><p>Spring通过应用上下文（Application Context）装载bean的定义并把它们组装起来。Spring应用上下文全权负责对象的创建和组装。Spring自带了多种应用上下文的实现，它们之间主要的区别仅仅在于如何加载配置。</p><h3 id="1-1-3-基于切面和惯例进行声明式编程（应用切面）"><a href="#1-1-3-基于切面和惯例进行声明式编程（应用切面）" class="headerlink" title="1.1.3 基于切面和惯例进行声明式编程（应用切面）"></a>1.1.3 基于切面和惯例进行声明式编程（应用切面）</h3><p><strong>面向切面编程（aspect-oriented programming，AOP）允许你把遍布应用各处的功能分离出来形成可重用的组件。</strong></p><p>面向切面编程往往被定义为促使软件系统实现关注点的分离一项技术。<strong>系统由许多不同的组件组成，每一个组件各负责一块特定功能。除了实现自身核心的功能之外，这些组件还经常承担着额外的职责。诸如日志、事务管理和安全这样的系统服务经常融入到自身具有核心业务逻辑的组件中去，这些系统服务通常被称为横切关注点，因为它</strong><br><strong>们会跨越系统的多个组件。</strong></p><p><strong>横切关注点 ：这些系统服务通常被称为横切关注点，因为他们会跨越系统的多个组件</strong></p><p><strong>如果将这些关注点分散到多个组件中去，你的代码将会带来双重的复杂性。</strong></p><ul><li>实现系统关注点功能的代码将会重复出现在多个组件中。这意味着如果你要改变这些关注点的逻辑，必须修改各个模块中的相关实现。即使你把这些关注点抽象为一个独立的模块，其他模块只是调用它的方法，但方法的调用还是会重复出现在各个模块中。组件会因为那些与自身核心业务无关的代码而变得混乱。一个向地址簿增加地址条目的方法应该只关注如何添加地址，而不应该关注它是不是安全的或者是否需要支持事务。</li></ul><p><strong>使用AOP的好处：</strong></p><p>借助AOP，可以使用各种功能层去包裹核心业务层。这些层以声明的方式灵活地应用到系统中，你的核心应用甚至根本不知道它们的存在。这是一个非常强大的理念，可以将安全、事务和日志关注点与核心业务逻辑相分离。</p><h3 id="1-1-4-使用模板消除样板式代码"><a href="#1-1-4-使用模板消除样板式代码" class="headerlink" title="1.1.4 使用模板消除样板式代码"></a>1.1.4 使用模板消除样板式代码</h3><p>Spring旨在通过模板封装来消除样板式代码。例如：<code>Spring</code>的<code>JdbcTemplate</code>使得执行数据库操作时，避免传统的JDBC样板代码成为了可能。（例如：在使用JDBC操作数据库的时候，需要关闭数据库连接，关闭Statement，关闭ResultSet等等这些都是重复性的代码，使用模板将这些重复性的代码封装到了模板中）</p><h2 id="1-2-Spring容器"><a href="#1-2-Spring容器" class="headerlink" title="1.2 Spring容器"></a>1.2 Spring容器</h2><p>简单来说就是装JavaBean的容器，统一管理，按需装配（使用依赖注入的方式）。</p><p><strong>它是Spring框架的核心。</strong>Spring容器使用DI管理构成应用的组件，它会创建相互协作的组件之间的关联。毫无疑问，这些对象更简单干净，更易于理解，更易于重用并且更易于进行单元测试。</p><p>Spring容器分为两种类型：</p><ul><li><strong>Bean工厂</strong> 实现<code>org.springframework. beans.factory.BeanFactory</code>接口，是最简单的容器，提供基本的DI支持.</li><li><strong>应用上下文</strong> <strong>(ApplicationContext)</strong> 实现<code>org.springframework.context.ApplicationContext</code>接口,它是基于Bean工厂实现的,并提供应用框架级别的服务，例如从属性文件解析文本信息以及发布应用事件给感兴趣的事件监听者。</li></ul><p>Bean工厂功能态单一,所以大多数选用<code>ApplicationContext</code></p><h3 id="1-2-1-使用应用上下文"><a href="#1-2-1-使用应用上下文" class="headerlink" title="1.2.1 使用应用上下文"></a>1.2.1 使用应用上下文</h3><p>常用的应用上下文:</p><ul><li><strong>AnnotationConfigApplicationContext</strong>：从一个或多个基于Java的配置类中加载Spring应用上下文。</li></ul><ul><li><strong>AnnotationConfigWebApplicationContext</strong>：从一个或多个基于Java的配置类中加载Spring Web应用上下文。</li></ul><ul><li><strong>ClassPathXmlApplicationContext</strong>：从类路径下的一个或多个XML配置文件中加载上下文定义，把应用上下文的定义文件作为类资源。</li></ul><ul><li><strong>FileSystemXmlapplicationcontext</strong>：从文件系统下的一个或多个XML配置文件中加载上下文定义。</li><li><strong>XmlWebApplicationContext</strong>：从Web应用下的一个或多个XML配置文件中加载上下文定义。</li></ul><p>使用<code>FileSystemXmlApplicationContext</code>和使用<code>ClassPathXmlApp-licationContext</code>的区别在于：<code>FileSystemXmlApplicationContext</code>在指定的文件系统路径下查找<code>bean.xml</code>文件；而<code>ClassPathXmlApplicationContext</code>是在所有的类路径（包含JAR文件）下查找 <code>bean.xml</code>文件。</p><p>这里需要注意的是:使用 “classpath*:”和”classpath:”的区别</p><h3 id="1-2-2-Bean的生命周期"><a href="#1-2-2-Bean的生命周期" class="headerlink" title="1.2.2 Bean的生命周期"></a>1.2.2 Bean的生命周期</h3><p><img src="E:\github\MyBlog\source\_posts\《Spring实战》（第四版）读书笔记\Bean的生命周期.png" alt=""></p><ul><li>1．Spring对bean进行实例化；</li><li>2．Spring将值和bean的引用注入到bean对应的属性中；</li><li>3．如果bean实现了BeanNameAware接口，Spring将bean的ID传递给setBean-Name()方法；</li></ul><ul><li>4．如果bean实现了BeanFactoryAware接口，Spring将调用setBeanFactory()方法，将BeanFactory容器实例传入；</li></ul><ul><li>5．如果bean实现了ApplicationContextAware接口，Spring将调用setApplicationContext()方法，将bean所在的应用上下文的引用传入进来；</li></ul><ul><li>6．如果bean实现了BeanPostProcessor接口，Spring将调用它们的post-ProcessBeforeInitialization()方法；</li></ul><ul><li>7．如果bean实现了InitializingBean接口，Spring将调用它们的after-PropertiesSet()方法。类似地，如果bean使用initmethod声明了初始化方法，该方法也会被调用；</li></ul><ul><li>8．如果bean实现了BeanPostProcessor接口，Spring将调用它们的post-ProcessAfterInitialization()方法；</li></ul><ul><li>9．此时，bean已经准备就绪，可以被应用程序使用了，它们将一直驻留在应用上下文中，直到该应用上下文被销毁；</li></ul><ul><li>10．如果bean实现了DisposableBean接口，Spring将调用它的destroy()接口方法。同样，如果bean使用destroy-method声明了销毁方法，该方法也会被调用。</li></ul><h2 id="1-3-Spring模块"><a href="#1-3-Spring模块" class="headerlink" title="1.3 Spring模块"></a>1.3 Spring模块</h2><h2 id="1-4-Spring新方向"><a href="#1-4-Spring新方向" class="headerlink" title="1.4 Spring新方向"></a>1.4 Spring新方向</h2><ul><li><strong>Spring Boot</strong></li></ul><h2 id="1-5-小节"><a href="#1-5-小节" class="headerlink" title="1.5 小节"></a>1.5 小节</h2><ul><li><p>Spring致力于简化开发,方便维护,其核心是<strong>依赖注入</strong>和<strong>面向切面编程</strong></p></li><li><p>依赖注入,也叫作控制反转。正常情况下类中需要用到的组件都是需要使用自己去new，相当于控制正转。但是它的耦合性太高，不利于维护和测试。而控制反转是我们需要什么组件外界使用我们的时候自己传进来，例如可以通过set方法或者构造器传入。这样，依赖的对象可以有使用者自己去扩展，实现了松耦合。而依赖注入正是控制反转的一种实现。另一方面，使用Spring的依赖注入核心功能使得对象的管理更加清晰。</p></li><li><p>面向切面编程（AOP），是将散落的逻辑，例如日志（在Spring中称作关注点），事务等等，这些功能也不得不使用，将这些逻辑汇聚在一起，形成一个面，也就是一个独立的模块，这样讲这些与核心业务逻辑类分离。一方面能够减少业务逻辑类中的代码量，使其专注自己的逻辑。</p><blockquote><p>AOP可以帮助应用将散落在各处的逻辑汇集于一处——切面。当Spring装配bean的时候，这些切面能够在运行期编织起来，这样就能非常有效地赋予bean新的行为。</p></blockquote></li></ul><h1 id="第2章-装配Bean（Bean的配置与获取）"><a href="#第2章-装配Bean（Bean的配置与获取）" class="headerlink" title="第2章 装配Bean（Bean的配置与获取）"></a>第2章 装配Bean（Bean的配置与获取）</h1><blockquote><p>在Spring中，对象无需自己查找或创建与其所关联的其他对象。相反，容器负责把需要相互协作的对象引用赋予各个对象。例如，一个订单管理组件需要信用卡认证组件，但它不需要自己创建信用卡认证组件。订单管理组件只需要表明自己两手空空，容器就会主动赋予它一个信用卡认证组件。</p></blockquote><blockquote><p><strong>创建应用对象之间协作关系的行为通常称为装配（wiring），这也是依赖注入（DI）的本质</strong>。</p></blockquote><h2 id="2-1-Spring容器的配置方式"><a href="#2-1-Spring容器的配置方式" class="headerlink" title="2.1 Spring容器的配置方式"></a>2.1 Spring容器的配置方式</h2><ul><li>在XML中进行显式配置。</li><li>在Java中进行显式配置。</li><li>隐式的bean发现机制和自动装配。</li></ul><p>关于三种配置方式的选择问题:</p><blockquote><p>选择自己喜欢的或者项目适合的配置方式。</p><p>搭配配置也是可以的</p><p>我的建议是尽可能地使用<strong>自动配置的机制</strong>。<strong>显式配置越少越好</strong>。当你必须要显式配置bean的时候（比如，有些源码不是由你来维护的，而当你需要为这些代码配置bean的时候），我推荐使用<strong>类型安全并且比XML更加强大的JavaConfig</strong>。最后，只有当你想要使用便利的XML命名空间，并且在JavaConfig中没有同样的实现时，才应该使用XML。</p></blockquote><p>未完待续…</p><h1 id="第4章-面向切面的Spring-Spring中的AOP"><a href="#第4章-面向切面的Spring-Spring中的AOP" class="headerlink" title="第4章  面向切面的Spring(Spring中的AOP)"></a>第4章  面向切面的Spring(Spring中的AOP)</h1><blockquote><p>软件系统中的一些功能就像我们家里的电表一样。这些功能需要用到应用程序的多个地方，但是我们又不想在每个点都明确调用它们。日志、安全和事务管理的确都很重要，但它们是否为应用对象主动参与的行为呢？<strong>如果让应用对象只关注于自己所针对的业务领域问题，而其他方面的问题由其他应用对象来处理，这会不会更好呢？</strong></p><p><strong>在软件开发中，散布于应用中多处的功能被称为横切关注点</strong>（crosscuttingconcern）。通常来讲，这些<strong>横切关注点从概念上是与应用的业务逻辑相分离的（但是往往会直接嵌入到应用的业务逻辑之中）。把这些横切关注点与业务逻辑相分离正是面向切面编程（AOP）所要解决的问题。</strong></p></blockquote><p>理解：各司其职，例如日志功能呢，虽然我们希望日志系统能够很好的帮我们记日志，但是日志系统的主要工作范畴。他就像财务，是替我们记账的。横切关注点串联起来，可以形成一个完整的面，该面相当于一个分布于应用中的微型系统。例如，日志，错误处理，事务管理等等。</p><blockquote><p><strong>DI有助于应用对象之间的解耦，而AOP可以实现横切关注点与它们所影响的对象之间的解耦。</strong></p></blockquote><h2 id="4-1-什么是面向切面编程"><a href="#4-1-什么是面向切面编程" class="headerlink" title="4.1 什么是面向切面编程"></a>4.1 什么是面向切面编程</h2><p><strong>Spring切面的实现原理</strong></p><blockquote><p>切面提供了取代继承和委托的另一种可选方案，而且在很多场景下更清晰简洁。<strong>在使用面向切面编程时，我们仍然在一个地方定义通用功能，但是可以通过声明的方式定义这个功能要以何种方式在何处应用，而无需修改受影响的类。**</strong>横切关注点可以被模块化为特殊的类，这些类被称为切面（aspect）<strong>。</strong></p><p><strong>这样做有两个好处：首先，现在每个关注点都集中于一个地方，而不是分散到多处代码中；其次，服务模块更简洁，因为它们只包含主要关注点（或核心功能）的代码，而次要关注点的代码被转移到切面中了。</strong></p></blockquote><h3 id="4-1-1-AOP相关术语"><a href="#4-1-1-AOP相关术语" class="headerlink" title="4.1.1 AOP相关术语"></a>4.1.1 AOP相关术语</h3><ul><li><p><strong>通知（Advice）–也叫增强</strong></p><blockquote><p>通知定义了切面是什么以及何时使用。除了描述切面要完成的工作，通知还解决了何时执行这个工作的问题。它应该应用在某个方法被调用之前？之后？之前和之后都调用？还是只在方法抛出异常时调用？</p></blockquote><p>Spring切面可以应用5种类型的通知：</p><ul><li><strong>前置通知</strong>（Before）：在目标方法被调用之前调用通知功能；</li><li><strong>后置通知</strong>（After）：在目标方法完成之后调用通知，此时不会关心方法的输出是什么；</li></ul></li><li><p><strong>连接点（Join point）</strong></p><blockquote><p>我们的应用可能也有数以千计的时机应用通知。这些时机被称为连接点。连接点是在应用执行过程中能够插入切面的一个点。这个点可以是调用方法时、抛出异常时、甚至修改一个字段时。切面代码可以利用这些点插入到应用的正常流程之中，并添加新的行为。</p></blockquote><p>简单理解就是:所有可以被增强的方法</p><p>​</p></li><li><p><strong>切点（Poincut）</strong></p><blockquote><p>如果说通知定义了切面的“什么”和“何时”的话，那么切点就定义了“何处”。切点的定义会匹配通知所要织入的一个或多个连接点。我们通常使用明确的类和方法名称，或是利用正则表达式定义所匹配的类和方法名称来指定这些切点。有些AOP框架允许我们创建动态的切点，可以根据运行时的决策（比如方法的参数值）来决定是否应用通知。</p></blockquote><p>简单理解:可以被增强的方法有很多个,但是并不是所有的方法都需要被增强,从连接点中选取一部分必要的方法来增强.切点是连接点的子集。</p></li><li><p><strong>切面（Aspect）</strong></p><blockquote><p>切面是通知和切点的结合。通知和切点共同定义了切面的全部内容——它是什么，在何时和何处完成其功能。</p></blockquote><p>简单理解：切面就是通知（增强）和切点编织在一起。他知道在哪里应用增强以及增强的内容。例如：在管理员往数据库中插入一条记录的时候就将插入记录的相关细节记录到日志中去。</p></li><li><p><strong>引入（Introduction）</strong></p><blockquote><p>引入允许我们向现有的类添加新方法或属性。例如，我们可以创建一个Auditable通知类，该类记录了对象最后一次修改时的状态。这很简单，只需一个方法，setLastModified(Date)，和一个实例变量来保存这个状态。然后，这个新方法和实例变量就可以被引入到现有的类中，从而可以在无需修改这些现有的类的情况下，让它们具有新的行为和状态。</p></blockquote></li><li><p><strong>织入（Weaving）</strong></p><blockquote><p>织入是把切面应用到目标对象并创建新的代理对象的过程。切面在指定的连接点被织入到目标对象中。在目标对象的生命周期里有多个点可以进行织入：</p><ul><li>编译期：切面在目标类编译时被织入。这种方式需要特殊的编译器。AspectJ的织入编译器就是以这种方式织入切面的。</li><li>类加载期：切面在目标类加载到JVM时被织入。这种方式需要特殊的类加载器（ClassLoader），它可以在目标类被引入应用之前增强该目标类的字节码。AspectJ 5的加载时织入（load-timeweaving，LTW）就支持以这种方式织入切面。</li><li>运行期：切面在应用运行的某个时刻被织入。一般情况下，在织入切面时，AOP容器会为目标对象动态地创建一个代理对象。<strong>Spring AOP就是以这种方式织入切面的。</strong></li></ul></blockquote><p>简单理解：创建切面的过程</p></li></ul><h3 id="4-1-2-Spring对AOP的支持"><a href="#4-1-2-Spring对AOP的支持" class="headerlink" title="4.1.2 Spring对AOP的支持"></a>4.1.2 Spring对AOP的支持</h3><p><strong>Spring提供了4种类型的AOP支持：</strong></p><ul><li>基于代理的经典Spring AOP；</li><li>纯POJO切面；</li><li>@AspectJ注解驱动的切面；</li><li>注入式AspectJ切面（适用于Spring各版本）。</li></ul><p><strong>前三种都是Spring AOP实现的变体</strong>，Spring AOP构建在动态代理基础之上，因此，Spring对AOP的支持局限于方法拦截。</p><p>Spring中AOP的特点:</p><ul><li><p>Spring在运行时,也就是说当真正的需要被代理的对象时,才创建代理对象.即运行时织入.</p></li><li><p>Spring只支持方法级别的连接点.不支持字段和构造器接入点.</p><blockquote><p>但是方法拦截可以满足绝大部分的需求。如果需要方法拦截之外的连接点拦截功能，那么我们可以利用Aspect来补充Spring AOP的功能。</p></blockquote></li></ul><blockquote><p><strong>在Spring AOP中，要使用AspectJ的切点表达式语言来定义切点。</strong></p></blockquote><blockquote><p><strong>关于Spring AOP的AspectJ切点，最重要的一点就是Spring仅支持AspectJ切点指示器（pointcut designator）的一个子集</strong></p></blockquote><h2 id="4-2-编写切点"><a href="#4-2-编写切点" class="headerlink" title="4.2 编写切点"></a>4.2 编写切点</h2><p>例如: <code>execution(* com.lee.aop.LeeDao.*(..))</code></p><p>说明: </p><ul><li>第一个*代表返回任意类型</li><li>第二个*代表匹配LeeDao类中的所有的方法</li><li>(..)代表任意的参数</li></ul><p>除了execution之外还有以下这些<code>AspectJ指示器</code></p><ul><li><p><code>arg()</code> 限制连接点匹配参数为指定类型的执行方法</p></li><li><p><code>@args()</code>限制连接点匹配参数由指定注解标注的执行方法</p><p>例如: <code>execution(* com.lee.aop.LeeDao.findById(int)) &amp;&amp; args(num)</code>表示当调用findById的时候传入的参数同时会传入到通知方法中去,此时通知方法可以在方法参数列表中指定一个参数用来接收这个参数,必须要保证通知方法参数列表中的参数名称和<code>num</code>名称一致</p></li><li><p><code>execution()</code> 用于匹配是连接点的执行方法</p></li><li><p><code>this()</code>限制连接点匹配AOP代理的bean引用为指定类型的类</p></li><li><p><code>target</code> 限制连接点匹配目标对象为指定类型的类</p></li><li><p><code>@target()</code> 限制连接点匹配特定的执行对象，这些对象对应的类要具有指定类型的注解</p></li><li><p><code>within()</code> 限制连接点匹配指定的类型</p></li><li><p><code>@within()</code> 限制连接点匹配指定注解所标注的类型（当使用Spring AOP时，方法定义在由指定的注解所标注的类里）</p></li><li><p><code>@annotation</code> 限定匹配带有指定注解的连接点</p></li><li><p>Spring还引入了一个新的bean()指示器，它允许我们在切点表达式中使用bean的ID来标识bean。bean()使用bean ID或bean名称作为参数来限制切点只匹配特定的bean。</p><p>例如:<code>execution(* com.lee.aop.LeeDao. *(..)) and bean(&quot;leeDao1&quot;)</code>表示限定的bean的ID为<code>leeDao1</code></p></li></ul><p>使用示例:</p><p><code>execution(* com.lee.aop.LeeDao. *(..)) &amp;&amp;  within(com.lee.*)</code></p><p>解释:<code>&amp;&amp;</code> 表示逻辑与.还有<code>!</code>,表示非.<code>||</code>表示或.响应的都可以使用<code>and</code>,<code>not</code>,<code>or</code>来代替</p><p>​        <code>within</code>表示限制切点仅仅匹配com.lee包下的</p><h2 id="4-3-使用注解创建切面"><a href="#4-3-使用注解创建切面" class="headerlink" title="4.3 使用注解创建切面"></a>4.3 使用注解创建切面</h2><p>在类上进行标注:</p><ul><li><code>@Aspect</code>: 代表该类不仅是一个POJO类,还是一个切面</li></ul><p>在方法上进行标注:代表他们是通知(增强)</p><ul><li><code>@After</code> 通知方法会在目标方法返回或抛出异常后调用</li><li><code>@AfterReturning</code> 通知方法会在目标方法返回后调用</li><li><code>@AfterThrowing</code> 通知方法会在目标方法抛出异常后调用</li><li><code>@Around</code> 通知方法会将目标方法封装起来</li><li><code>@Before</code> 通知方法会在目标方法调用之前执行</li><li><code>@Pointcut</code> 定义一个公用的切点</li></ul><p>需要注意的是<code>@Around</code>环绕通知的使用方法</p><blockquote><p>关于这个新的通知方法，你首先注意到的可能是它接受<strong>ProceedingJoinPoint</strong>作为参数。这个对象是必须要有的，因为你要在通知中通过它来调用被通知的方法。通知方法中可以做任何的事情，当要将控制权交给被通知的方法时，它需要调用<strong>ProceedingJoinPoint</strong>的<strong>proceed()</strong>方法。</p></blockquote><p>​    <em>**</em></p><p><strong>通过注解引入新的功能:</strong></p><blockquote><p>一些编程语言，例如Ruby和Groovy，有开放类的理念。它们可以不用直接修改对象或类的定义就能够为对象或类增加新的方法。不过，Java并不是动态语言。一旦类编译完成了，我们就很难再为该类添加新的功了。</p></blockquote><p>实现方法</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Aspect</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">FoodFruitAppleAspect</span> </span>&#123;</span><br><span class="line">    <span class="comment">// value代表那种类型的bean需要引入新的接口,这里Fruit的子类将会引入新的接口</span></span><br><span class="line">    <span class="comment">// defaultImpl代表引入新的功能的实现类</span></span><br><span class="line">    <span class="meta">@DeclareParents</span>(value = <span class="string">"com.lee.aop.aopjoinnewfunction.Fruit+"</span>,</span><br><span class="line">            defaultImpl = FoodImpl.class)</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> Food sFood;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>在xml中配置</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">bean</span> <span class="attr">id</span>=<span class="string">"myApple"</span> <span class="attr">class</span>=<span class="string">"com.lee.aop.aopjoinnewfunction.Apple"</span>/&gt;</span></span><br><span class="line"><span class="comment">&lt;!--</span></span><br><span class="line"><span class="comment">在FoodFruitAppleAspect类中已经声明它作为一个切面,当Spring发现一个bean使</span></span><br><span class="line"><span class="comment">用了@Aspect注解时，Spring就会创建一个代理，然后将调用委托给</span></span><br><span class="line"><span class="comment">被代理的bean或被引入的实现，这取决于调用的方法属于被代理的</span></span><br><span class="line"><span class="comment">bean还是属于被引入的接口。</span></span><br><span class="line"><span class="comment">--&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">bean</span> <span class="attr">id</span>=<span class="string">"foodFruitAppleAspect"</span> <span class="attr">class</span>=<span class="string">"com.lee.aop.aopjoinnewfunction.FoodFruitAppleAspect"</span>/&gt;</span></span><br></pre></td></tr></table></figure><p>使用:</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">test1</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        ApplicationContext context = <span class="keyword">new</span> ClassPathXmlApplicationContext(<span class="string">"com/lee/aop/aopjoinnewfunction/NewApple.xml"</span>);</span><br><span class="line">        <span class="comment">// 虽然MyApple是一个Fruit的实现类,并没有显示的实现了Food接口,但是通过AOP切面的形式创建了代理  类,该代理类在运行时创建了代理对象</span></span><br><span class="line">        <span class="comment">// 该代理对象融合了新的功能</span></span><br><span class="line">        Food food = (Food) context.getBean(<span class="string">"myApple"</span>);</span><br><span class="line">        food.canEat();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="4-4-在xml中生命切面"><a href="#4-4-在xml中生命切面" class="headerlink" title="4.4 在xml中生命切面"></a>4.4 在xml中生命切面</h2><p>略</p><h2 id="4-5-注入AspectJ切面"><a href="#4-5-注入AspectJ切面" class="headerlink" title="4.5 注入AspectJ切面"></a>4.5 注入AspectJ切面</h2><p>上面的切面是Spring AOP的变体.</p><blockquote><p>虽然Spring AOP能够满足许多应用的切面需求，但是与AspectJ相比，Spring AOP 是一个功能比较弱的AOP解决方案。AspectJ提供了SpringAOP所不能支持的许多类型的切点。</p></blockquote><blockquote><p>例如，当我们需要在创建对象时应用通知，构造器切点就非常方便。不像某些其他面向对象语言中的构造器，Java构造器不同于其他的正常方法。这使得Spring基于代理的AOP无法把通知应用于对象的创建过程。</p><p>对于大部分功能来讲，AspectJ切面与Spring是相互独立的。虽然它们可以织入到任意的Java应用中，这也包括了Spring应用，但是在应用AspectJ切面时几乎不会涉及到Spring。</p></blockquote><h1 id="第10章-通过Spring和JDBC征服数据库"><a href="#第10章-通过Spring和JDBC征服数据库" class="headerlink" title="第10章 通过Spring和JDBC征服数据库"></a>第10章 通过Spring和JDBC征服数据库</h1><blockquote><p>SQLException的问题在于捕获到它的时候该如何处理。事实上，能够触发SQLException的问题通常是不能在catch代码块中解决的。大多数抛出SQLException的情况表明发生了致命性错误。如果应用程序不能连接到数据库，这通常意味着应用不能继续使用了。类似地，如果查询时出现了错误，那在运行时基本上也是无能为力。</p></blockquote><blockquote><p>SQLException并查看其属性才能获知问题根源的更多信息。这是因为SQLException被视为处理数据访问所有问题的通用异常。对于所有的数据访问问题都会抛出SQLException，而不是对每种可能的问题都会有不同的异常类型。</p></blockquote><blockquote><p>一方面，JDBC的异常体系过于简单了——实际上，它算不上一个体系。另一方面，Hibernate的异常体系是其本身所独有的。我们需要的数据访问异常要具有描述性而且又与特定的持久化框架无关。</p><p><strong>Spring所提供的平台无关的持久化异常</strong></p><p>Spring JDBC提供的数据访问异常体系解决了以上的两个问题。不同于JDBC，Spring提供了多个数据访问异常，分别描述了它们抛出时所对应的问题。表10.1对比了Spring的部分数据访问异常以及JDBC所提供的异常。</p></blockquote><h2 id="10-2-访问数据源"><a href="#10-2-访问数据源" class="headerlink" title="10.2 访问数据源"></a>10.2 访问数据源</h2><h3 id="10-2-1-使用JNDI配置数据源"><a href="#10-2-1-使用JNDI配置数据源" class="headerlink" title="10.2.1 使用JNDI配置数据源"></a>10.2.1 使用JNDI配置数据源</h3><p>(略)</p><h3 id="10-2-2-使用数据源连接池"><a href="#10-2-2-使用数据源连接池" class="headerlink" title="10.2.2 使用数据源连接池"></a>10.2.2 使用数据源连接池</h3><p>常见的有DBCP,c3p0等,配置上大体相同</p><h3 id="10-2-5-使用profile选择数据源"><a href="#10-2-5-使用profile选择数据源" class="headerlink" title="10.2.5 使用profile选择数据源"></a>10.2.5 使用profile选择数据源</h3><blockquote><p>实际上，我们很可能面临这样一种需求，那就是在某种环境下需要其中一种数据源，而在另外的环境中需要不同的数据源。</p><p>例如，对于开发期来说，<a href="jdbc:embedded-database" target="_blank" rel="noopener">jdbc:embedded-database</a>元素是很合适的，而在QA环境中，你可能希望使用DBCP的BasicDataSource，在生产部署环境下，可能需要使用<a href="jee:jndi-lookup" target="_blank" rel="noopener">jee:jndi-lookup</a>。</p></blockquote><p><strong>借助Spring的profile特性能够在运行时选择数据源</strong></p><h2 id="10-3-在Spring中使用JDBC"><a href="#10-3-在Spring中使用JDBC" class="headerlink" title="10.3 在Spring中使用JDBC"></a>10.3 在Spring中使用JDBC</h2><blockquote><p>JDBC不要求我们掌握其他框架的查询语言。它是建立在SQL之上的，而SQL本身就是数据访问语言。此外，与其他的技术相比，<strong>使用JDBC能够更好地对数据访问的性能进行调优</strong>。JDBC允许你使用数据库的所有特性，而这是其他框架不鼓励甚至禁止的。</p><p>再者，相对于持久层框架，<strong>JDBC能够让我们在更低的层次上处理数据</strong>，<strong>我们可以完全控制应用程序如何读取和管理数据，包括访问和管理数据库中单独的列</strong>。这种细粒度的数据访问方式在很多应用程序中是很方便的。例如在报表应用中，如果将数据组织为对象，而接下来唯一要做的就是将其解包为原始数据，那就没有太大意义了。</p></blockquote><p>理解:很多时候我们先将基本的功能实现了,再考虑优化问题,提高性能等.而使用持久层框架,它们帮我们做了很多封装,会隐藏很多细节,这样有针对性的优化就会付出很多成本.</p><blockquote><p>首先使代码正确的运行,然后再提高代码的速度.</p><p>摘自《Java并发编程实战》</p></blockquote>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h1 id=&quot;第1章-Spring之旅&quot;&gt;&lt;a href=&quot;#第1章-Spring之旅&quot; class=&quot;headerlink&quot; title=&quot;第1章 Spring之旅&quot;&gt;&lt;/a&gt;第1章 Spring之旅&lt;/h1&gt;&lt;p&gt;&lt;strong&gt;两大核心&lt;/strong&gt;&lt;/p&gt;
&lt;ul&gt;
      
    
    </summary>
    
      <category term="Spring" scheme="https://blueleer.github.io/categories/Spring/"/>
    
    
      <category term="Spring" scheme="https://blueleer.github.io/tags/Spring/"/>
    
  </entry>
  
  <entry>
    <title>Spring加载resource时classpath*:与classpath:的区别</title>
    <link href="https://blueleer.github.io/2018/04/21/Spring%E5%8A%A0%E8%BD%BDresource%E6%97%B6classpath/"/>
    <id>https://blueleer.github.io/2018/04/21/Spring加载resource时classpath/</id>
    <published>2018-04-21T03:37:39.000Z</published>
    <updated>2018-04-21T06:41:18.612Z</updated>
    
    <content type="html"><![CDATA[<p>Spring加载context配置文件是从classpath加载进来的。</p><h3 id="What-is-classpath"><a href="#What-is-classpath" class="headerlink" title="What is classpath?"></a>What is classpath?</h3><ul><li><p>就是.java文件存放的根路径,在<code>intellij</code>中是<code>src</code>目录</p></li><li><p>我们也可以将配置文件单独放在一个文件夹下,例如<code>resources</code>文件夹,该文件夹和src目录是同级的.</p><ul><li><p>怎么创建这个文件夹呢?</p><ul><li><p>现在项目中创建一个和<code>src</code>同级的<code>directory</code>,名为<code>resources</code></p></li><li><p>右键该<code>resources</code>,然后<code>make Directory As</code>,然后选择<code>Source Root</code></p></li><li><p>此时你会发现该文件夹变颜色了,和src是一样的颜色</p></li><li><p>同时你也可以查看项目的配置问价<code>yourproject.xml</code>,例如,我的是这样的:</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line">&lt;?xml version="1.0" encoding="UTF-8"?&gt;</span><br><span class="line"><span class="tag">&lt;<span class="name">module</span> <span class="attr">type</span>=<span class="string">"JAVA_MODULE"</span> <span class="attr">version</span>=<span class="string">"4"</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">component</span> <span class="attr">name</span>=<span class="string">"FacetManager"</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">facet</span> <span class="attr">type</span>=<span class="string">"Spring"</span> <span class="attr">name</span>=<span class="string">"Spring"</span>&gt;</span></span><br><span class="line">      <span class="tag">&lt;<span class="name">configuration</span> /&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">facet</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;/<span class="name">component</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">component</span> <span class="attr">name</span>=<span class="string">"NewModuleRootManager"</span> <span class="attr">inherit-compiler-output</span>=<span class="string">"true"</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">exclude-output</span> /&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">content</span> <span class="attr">url</span>=<span class="string">"file://$MODULE_DIR$"</span>&gt;</span></span><br><span class="line">      <span class="tag">&lt;<span class="name">sourceFolder</span> <span class="attr">url</span>=<span class="string">"file://$MODULE_DIR$/src"</span> <span class="attr">isTestSource</span>=<span class="string">"false"</span> /&gt;</span></span><br><span class="line">      <span class="tag">&lt;<span class="name">sourceFolder</span> <span class="attr">url</span>=<span class="string">"file://$MODULE_DIR$/sources"</span> <span class="attr">isTestSource</span>=<span class="string">"false"</span> /&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">content</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">orderEntry</span> <span class="attr">type</span>=<span class="string">"inheritedJdk"</span> /&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">orderEntry</span> <span class="attr">type</span>=<span class="string">"sourceFolder"</span> <span class="attr">forTests</span>=<span class="string">"false"</span> /&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">orderEntry</span> <span class="attr">type</span>=<span class="string">"library"</span> <span class="attr">name</span>=<span class="string">"Spring-4.3.16.RELEASE"</span> <span class="attr">level</span>=<span class="string">"project"</span> /&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">orderEntry</span> <span class="attr">type</span>=<span class="string">"module-library"</span>&gt;</span></span><br><span class="line">      <span class="tag">&lt;<span class="name">library</span> <span class="attr">name</span>=<span class="string">"JUnit4"</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">CLASSES</span>&gt;</span></span><br><span class="line">          <span class="tag">&lt;<span class="name">root</span> <span class="attr">url</span>=<span class="string">"jar://$APPLICATION_HOME_DIR$/lib/junit-4.12.jar!/"</span> /&gt;</span></span><br><span class="line">          <span class="tag">&lt;<span class="name">root</span> <span class="attr">url</span>=<span class="string">"jar://$APPLICATION_HOME_DIR$/lib/hamcrest-core-1.3.jar!/"</span> /&gt;</span></span><br><span class="line">        <span class="tag">&lt;/<span class="name">CLASSES</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">JAVADOC</span> /&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">SOURCES</span> /&gt;</span></span><br><span class="line">      <span class="tag">&lt;/<span class="name">library</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">orderEntry</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;/<span class="name">component</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">module</span>&gt;</span></span><br></pre></td></tr></table></figure><p>其中可以清楚的看到<code>src</code>目录和<code>sources</code>都是<code>sourceFolder</code></p></li></ul></li></ul></li></ul><h3 id="classpath-和classpath-到底有什么区别呢"><a href="#classpath-和classpath-到底有什么区别呢" class="headerlink" title="classpath*:和classpath:到底有什么区别呢?"></a>classpath*:和classpath:到底有什么区别呢?</h3><ul><li><p>你先想想<strong>*</strong>通常用来是干嘛用的? 是不是通配符?</p><ul><li><strong>classpath*:</strong> 就是从多个jar文件,包括你自己的项目<code>src</code>目录下(src目录作为sourceroot)加载指定的问价,比如:</li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">ApplicationContext context = <span class="keyword">new</span> ClassPathXmlApplicationContext(<span class="string">"classpath*:/bean.xml"</span>);</span><br><span class="line"><span class="comment">// 其中斜杠表示sourceroot的根目录(也可以不写),</span></span><br></pre></td></tr></table></figure><p>它从所有的classpath中查找这个bean.xml文件,所有符合条件的bean.xml文件都被加载进来了</p></li><li><p><strong>classpath:</strong> 如果存在多个满足条件的,第一个加载到了,就不管了</p></li></ul><p>参考:</p><p><a href="https://blog.csdn.net/kkdelta/article/details/5507799" target="_blank" rel="noopener">Spring加载resource时classpath*:与classpath:的区别</a></p><p>更多内容请点开上面的链接</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;Spring加载context配置文件是从classpath加载进来的。&lt;/p&gt;
&lt;h3 id=&quot;What-is-classpath&quot;&gt;&lt;a href=&quot;#What-is-classpath&quot; class=&quot;headerlink&quot; title=&quot;What is classp
      
    
    </summary>
    
      <category term="JavaEE" scheme="https://blueleer.github.io/categories/JavaEE/"/>
    
    
      <category term="Spring" scheme="https://blueleer.github.io/tags/Spring/"/>
    
  </entry>
  
  <entry>
    <title>SSH框架学习之Struts2--第一天</title>
    <link href="https://blueleer.github.io/2018/04/08/SSH%E6%A1%86%E6%9E%B6%E5%AD%A6%E4%B9%A0%E4%B9%8BStruts2-%E7%AC%AC%E4%B8%80%E5%A4%A9/"/>
    <id>https://blueleer.github.io/2018/04/08/SSH框架学习之Struts2-第一天/</id>
    <published>2018-04-08T05:10:07.000Z</published>
    <updated>2018-04-08T08:30:50.604Z</updated>
    
    <summary type="html">
    
    </summary>
    
      <category term="Java" scheme="https://blueleer.github.io/categories/Java/"/>
    
    
      <category term="Struts2" scheme="https://blueleer.github.io/tags/Struts2/"/>
    
  </entry>
  
  <entry>
    <title>回车和换行</title>
    <link href="https://blueleer.github.io/2018/04/07/%E5%9B%9E%E8%BD%A6%E5%92%8C%E6%8D%A2%E8%A1%8C/"/>
    <id>https://blueleer.github.io/2018/04/07/回车和换行/</id>
    <published>2018-04-07T03:43:40.000Z</published>
    <updated>2018-04-07T17:06:23.583Z</updated>
    
    <content type="html"><![CDATA[<p>今天在做爬虫的时候,需要匹配下面Title中的内容,发现写的正则表达式<strong>question_link(.<em>)&gt;(\n</em>)(.+)(\n*)&lt;</strong>竟然匹配不上里面的中文,原来在win系统中文件中的换行其实包含了两个字符, <strong>/CR(回车),/LF(换行)</strong>,这两个”.”都是匹配不上的.</p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">h2</span>&gt;</span><span class="tag">&lt;<span class="name">a</span> <span class="attr">class</span>=<span class="string">"question_link"</span> <span class="attr">href</span>=<span class="string">"/question/270597366/answer/355546388"</span> <span class="attr">data-id</span>=<span class="string">"22407872"</span> <span class="attr">data-za-element-name</span>=<span class="string">"Title"</span>&gt;</span></span><br><span class="line">如何看待星巴克被指含有致癌物质（丙烯酰胺Acrylamide）？</span><br><span class="line"><span class="tag">&lt;/<span class="name">a</span>&gt;</span><span class="tag">&lt;/<span class="name">h2</span>&gt;</span></span><br></pre></td></tr></table></figure><p>修改成下面,成功匹配</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">question_link(.*)&gt;(\r)(\n)(.*)</span><br></pre></td></tr></table></figure><p>完整代码为:</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 其中这段是从文件中摘录的,文件中查看特殊符号显示了换行包含两个字符 一个回车一个换行</span></span><br><span class="line">String s = <span class="string">"&lt;h2&gt;&lt;a class="</span>question_link<span class="string">" href="</span>/question/<span class="number">270597366</span>/answer/<span class="number">355546388</span><span class="string">" data-id="</span><span class="number">22407872</span><span class="string">" data-za-element-name="</span>Title<span class="string">"&gt;</span></span><br><span class="line"><span class="string">如何看待星巴克被指含有致癌物质（丙烯酰胺Acrylamide）？</span></span><br><span class="line"><span class="string">&lt;/a&gt;&lt;/h2&gt;"</span></span><br><span class="line">    </span><br><span class="line">String regex = <span class="string">"question_link(.*)&gt;(\\r)(\\n)(.*)"</span>;</span><br><span class="line">Pattern pattern = Pattern.compile(regex);</span><br><span class="line">Matcher matcher = pattern.matcher(sb.toString());</span><br><span class="line">matcher.find();</span><br><span class="line">String group = matcher.group(<span class="number">4</span>);</span><br><span class="line">System.out.println(group);</span><br><span class="line"></span><br><span class="line"><span class="comment">// 输出:</span></span><br><span class="line"><span class="comment">// 如何看待星巴克被指含有致癌物质（丙烯酰胺Acrylamide）？</span></span><br></pre></td></tr></table></figure><p>小示例:</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">String s1 = <span class="string">"\r1234\r567"</span>;</span><br><span class="line">String s2 = <span class="string">"\n12345"</span>;</span><br><span class="line">System.out.println(s1);</span><br><span class="line">System.out.println(s2);</span><br><span class="line"></span><br><span class="line"><span class="comment">// 输出:</span></span><br><span class="line"><span class="number">567</span></span><br><span class="line"></span><br><span class="line"><span class="number">12345</span></span><br></pre></td></tr></table></figure><p><strong>再次强调,回车和换行,”.”都不能匹配</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">String s1 = <span class="string">"\r1234\r567"</span>;</span><br><span class="line">String regex = <span class="string">".*"</span>;</span><br><span class="line">String regex1 = <span class="string">"\\r.*"</span>;</span><br><span class="line">Pattern pattern = Pattern.compile(regex1); <span class="comment">// 换成regex则下面的输出为空,也就是不能匹配</span></span><br><span class="line">Matcher matcher = pattern.matcher(s1);</span><br><span class="line">matcher.find();</span><br><span class="line">System.out.println(matcher.group());</span><br></pre></td></tr></table></figure><p>更多知识请参考:</p><p><a href="https://blog.csdn.net/fanwenbo/article/details/54848429" target="_blank" rel="noopener">终于搞懂了回车与换行的区别</a></p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;今天在做爬虫的时候,需要匹配下面Title中的内容,发现写的正则表达式&lt;strong&gt;question_link(.&lt;em&gt;)&amp;gt;(\n&lt;/em&gt;)(.+)(\n*)&amp;lt;&lt;/strong&gt;竟然匹配不上里面的中文,原来在win系统中文件中的换行其实包含了两个字符, &lt;
      
    
    </summary>
    
      <category term="其他" scheme="https://blueleer.github.io/categories/%E5%85%B6%E4%BB%96/"/>
    
    
      <category term="计算机" scheme="https://blueleer.github.io/tags/%E8%AE%A1%E7%AE%97%E6%9C%BA/"/>
    
      <category term="其他" scheme="https://blueleer.github.io/tags/%E5%85%B6%E4%BB%96/"/>
    
  </entry>
  
  <entry>
    <title>hexo主题之next主题的配置</title>
    <link href="https://blueleer.github.io/2018/04/06/hexo%E4%B8%BB%E9%A2%98%E4%B9%8Bnext%E4%B8%BB%E9%A2%98%E7%9A%84%E9%85%8D%E7%BD%AE/"/>
    <id>https://blueleer.github.io/2018/04/06/hexo主题之next主题的配置/</id>
    <published>2018-04-06T13:46:36.000Z</published>
    <updated>2018-04-06T15:48:33.471Z</updated>
    
    <content type="html"><![CDATA[<p>关于 hexo 主题之next主题</p><ul><li><a href="https://github.com/iissnan/hexo-theme-next" target="_blank" rel="noopener">GiuHub地址</a></li><li><a href="http://theme-next.iissnan.com/getting-started.html" target="_blank" rel="noopener">Next主题配置官网文档</a></li><li><a href="http://shenzekun.cn/hexo%E7%9A%84next%E4%B8%BB%E9%A2%98%E4%B8%AA%E6%80%A7%E5%8C%96%E9%85%8D%E7%BD%AE%E6%95%99%E7%A8%8B.html" target="_blank" rel="noopener">hexo的next主题个性化教程:打造炫酷网站</a></li></ul><p>另外附上大致的使用GitHub Pages建站的流程:</p><ol><li>注册GitHub账号</li><li>创建 YourName.github.io库,GitHub默认把它当做静态html托管仓库(我们实际上也仅仅是在它上面托管我们的静态网页,它还能够识别解析css和js文件)</li><li>在GitHub上生成 SSH Keys (后面使用的hexo在本地拥有了一个SSH Keys的拷贝,这样就可以实现快速部署到pages仓库)</li><li>安装hexo,推荐参考 <a href="https://hexo.io/zh-cn/docs/index.html" target="_blank" rel="noopener">hexo官方文档</a> 这样可以少走很多弯路,遇到问题了再去查解决方法</li><li>然后就可以找一款自己喜欢的主题啦 <a href="https://hexo.io/" target="_blank" rel="noopener">hexo官网</a>,这上面有很全的plug插件和theme主题,也可以参考别人的推荐,我就用的是GitHub上star数醉的的一款next</li></ol>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;关于 hexo 主题之next主题&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;&lt;a href=&quot;https://github.com/iissnan/hexo-theme-next&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;GiuHub地址&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;
      
    
    </summary>
    
      <category term="其他" scheme="https://blueleer.github.io/categories/%E5%85%B6%E4%BB%96/"/>
    
    
      <category term="hexo主题配置" scheme="https://blueleer.github.io/tags/hexo%E4%B8%BB%E9%A2%98%E9%85%8D%E7%BD%AE/"/>
    
  </entry>
  
  <entry>
    <title>Hibernate学习笔记4</title>
    <link href="https://blueleer.github.io/2017/05/12/Hibernate%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B04/"/>
    <id>https://blueleer.github.io/2017/05/12/Hibernate学习笔记4/</id>
    <published>2017-05-12T11:10:40.000Z</published>
    <updated>2018-04-27T09:45:54.293Z</updated>
    
    <content type="html"><![CDATA[<h1 id="Hibernate–4"><a href="#Hibernate–4" class="headerlink" title="Hibernate–4"></a>Hibernate–4</h1><p>JPA(<em>Java Persistence API</em>)：Java持久化API,用于规范ORM接口的一系列规范。</p><p>Hibernate中实现了JPA规范</p><h2 id="配置"><a href="#配置" class="headerlink" title="配置"></a>配置</h2><ul><li><p>项目引入jpa配置（persistence.xml）</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">&lt;?xml version="1.0" encoding="UTF-8" ?&gt;</span><br><span class="line"><span class="tag">&lt;<span class="name">persistence</span> <span class="attr">xmlns</span>=<span class="string">"http://xmlns.jcp.org/xml/ns/persistence"</span></span></span><br><span class="line"><span class="tag">             <span class="attr">xmlns:xsi</span>=<span class="string">"http://www.w3.org/2001/XMLSchema-instance"</span></span></span><br><span class="line"><span class="tag">             <span class="attr">xsi:schemaLocation</span>=<span class="string">"http://xmlns.jcp.org/xml/ns/persistence</span></span></span><br><span class="line"><span class="tag"><span class="string">          http://xmlns.jcp.org/xml/ns/persistence/persistence_2_1.xsd"</span></span></span><br><span class="line"><span class="tag">             <span class="attr">version</span>=<span class="string">"2.1"</span>&gt;</span></span><br><span class="line">    <span class="comment">&lt;!--</span></span><br><span class="line"><span class="comment">                        name : 用于指定持久化单元的名称(可以为空,必须配)</span></span><br><span class="line"><span class="comment">            transaction-type : 指定事务类型,取值为JTA(默认)、RESOURCE_LOCAL</span></span><br><span class="line"><span class="comment">    --&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">persistence-unit</span> <span class="attr">name</span>=<span class="string">"Unit1"</span> <span class="attr">transaction-type</span>=<span class="string">"RESOURCE_LOCAL"</span>&gt;</span></span><br><span class="line"></span><br><span class="line">        <span class="comment">&lt;!--javax.persistence.PersistenceProvider的一个实现类,用于创建EntityManagerFactory(用于产生实体类管理者工厂)--&gt;</span></span><br><span class="line">        <span class="comment">&lt;!--在Hibernate中实现了JPA规范,这个类其实也是默认的,可以不配--&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">provider</span>&gt;</span>org.hibernate.jpa.HibernatePersistenceProvider<span class="tag">&lt;/<span class="name">provider</span>&gt;</span></span><br></pre></td></tr></table></figure><pre><code>    &lt;!--罗列出需要持久化的类(在JavaEE环境下可以不配)--&gt;    &lt;class&gt;com.lee.cfgtest.Student&lt;/class&gt;    &lt;class&gt;com.lee.cfgtest.Teacher&lt;/class&gt;    &lt;class&gt;com.lee.one2many.Tenant&lt;/class&gt;    &lt;class&gt;com.lee.one2many.Landlord&lt;/class&gt;    &lt;!--JPA实现者专有配置,不同的JPA规范实现框架,可能配置的property值不一样--&gt;    &lt;!--参考hibernate.cfg.xml中的配置--&gt;    &lt;properties&gt;        &lt;!--DDL生成策略--&gt;        &lt;!--其中update表示:检测实体类和表结构是否一致,如果不一致,更新表结构达到一致,如果不存在该表,就创建一张表--&gt;        &lt;property name=&quot;hibernate.hbm2ddl.auto&quot; value=&quot;update&quot;/&gt;        &lt;!--第一部分:数据库连接配置--&gt;        &lt;property name=&quot;hibernate.connection.driver_class&quot; value=&quot;com.mysql.jdbc.Driver&quot;/&gt;        &lt;property name=&quot;hibernate.connection.url&quot; value=&quot;jdbc:mysql://localhost:3306/hibernate2&quot;/&gt;        &lt;property name=&quot;hibernate.connection.username&quot; value=&quot;root&quot;/&gt;        &lt;property name=&quot;hibernate.connection.password&quot; value=&quot;123&quot;/&gt;        &lt;!--第二部分 :配置数据库连接池:c3p0 (自由选择)--&gt;        &lt;property name=&quot;hibernate.connection.provider_class&quot;                  value=&quot;org.hibernate.connection.C3P0ConnectionProvider&quot;/&gt;        &lt;!--配置数据库方言--&gt;        &lt;property name=&quot;hibernate.dialect&quot; value=&quot;org.hibernate.dialect.MySQL55Dialect&quot;/&gt;        &lt;!--是否在控制台显示生成的sql语句--&gt;        &lt;property name=&quot;hibernate.show_sql&quot; value=&quot;true&quot;/&gt;        &lt;!--是否将控制台里的sql语句格式化输出--&gt;        &lt;!--&lt;property name=&quot;hibernate.format_sql&quot; value=&quot;true&quot;/&gt;--&gt;    &lt;/properties&gt;&lt;/persistence-unit&gt;</code></pre><h2 id="一对多关系配置"><a href="#一对多关系配置" class="headerlink" title="一对多关系配置"></a>一对多关系配置</h2></li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line">* 实体类中的配置(包含表之间一对多映射配置)</span><br><span class="line"></span><br><span class="line">  一对多关系中的<span class="string">"一"</span>的一方实体类配置</span><br><span class="line"></span><br><span class="line">  <span class="meta">@Entity</span></span><br><span class="line">  <span class="meta">@Table</span>(name = <span class="string">"hb_landlord"</span>)</span><br><span class="line">  <span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Landlord</span> </span>&#123;</span><br><span class="line">      <span class="meta">@Id</span></span><br><span class="line">      <span class="meta">@GeneratedValue</span>(strategy = GenerationType.IDENTITY)</span><br><span class="line">      <span class="meta">@Column</span>(name = <span class="string">"l_id"</span>)</span><br><span class="line">      <span class="keyword">private</span> Integer lid;</span><br><span class="line"></span><br><span class="line">      <span class="meta">@Column</span>(name = <span class="string">"l_name"</span>)</span><br><span class="line">      <span class="keyword">private</span> String lname;</span><br><span class="line"></span><br><span class="line">      <span class="meta">@Column</span>(name = <span class="string">"l_sex"</span>)</span><br><span class="line">      <span class="keyword">private</span> String lsex;</span><br><span class="line">      <span class="meta">@Column</span>(name = <span class="string">"l_age"</span>)</span><br><span class="line">      <span class="keyword">private</span> Integer lage;</span><br><span class="line">      <span class="meta">@Column</span>(name = <span class="string">"l_phone"</span>)</span><br><span class="line">      <span class="keyword">private</span> String lphone;</span><br><span class="line">      </span><br><span class="line">      <span class="comment">// 参数解释:</span></span><br><span class="line">      <span class="comment">// targetEntity:表示对应的"多"的一方的字节码文件,也可以不加</span></span><br><span class="line">      <span class="comment">// mappedBy:从表中引用的该实体属性名,如果配置了该项,表示放弃维护和从表之间的关联关系.在一对多配置中,一般"一"的一方会配置上该属性;如果没有配置该属性,会生成第三张表(类似于多对多中的中间表)来维护他们之间的关系</span></span><br><span class="line">      <span class="comment">// fetch:配置tenants的加载方式, OneToMany中fetch的默认值为LAZY</span></span><br><span class="line">      <span class="comment">// 还有其他属性:cascade:级联操作</span></span><br><span class="line">      <span class="meta">@OneToMany</span>(targetEntity = Tenant.class, fetch = FetchType.LAZY, mappedBy = <span class="string">"landlord"</span>)</span><br><span class="line">      <span class="keyword">private</span> Set&lt;Tenant&gt; tenants = <span class="keyword">new</span> HashSet&lt;&gt;(<span class="number">0</span>);</span><br><span class="line"></span><br><span class="line">      <span class="comment">// 省略默认构造方法,get/set方法,toString()方法</span></span><br><span class="line">  &#125;</span><br></pre></td></tr></table></figure><p><strong>注意:属性级别的注解，都是放在其对应的getter前。</strong></p><p>  一对多中”多”的一方的实体类配置</p>  <figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Entity</span></span><br><span class="line"><span class="meta">@Table</span>(name = <span class="string">"hb_tenant"</span>)</span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Tenant</span> </span>&#123;</span><br><span class="line">    <span class="meta">@Id</span></span><br><span class="line">    <span class="meta">@GeneratedValue</span>(strategy = GenerationType.IDENTITY)</span><br><span class="line">    <span class="meta">@Column</span>(name = <span class="string">"t_id"</span>)</span><br><span class="line">    <span class="keyword">private</span> Integer tid;</span><br><span class="line">    <span class="meta">@Column</span>(name = <span class="string">"t_name"</span>)</span><br><span class="line">    <span class="keyword">private</span> String tname;</span><br><span class="line">    <span class="meta">@Column</span>(name = <span class="string">"t_sex"</span>)</span><br><span class="line">    <span class="keyword">private</span> String tsex;</span><br><span class="line">    <span class="meta">@Column</span>(name = <span class="string">"t_age"</span>)</span><br><span class="line">    <span class="keyword">private</span> Integer tage;</span><br><span class="line">    <span class="meta">@Column</span>(name = <span class="string">"t_phone"</span>)</span><br><span class="line">    <span class="keyword">private</span> String tphone;</span><br><span class="line">    <span class="meta">@Column</span>(name = <span class="string">"t_job"</span>)</span><br><span class="line">    <span class="keyword">private</span> String tjob; <span class="comment">// 从事的工作</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">// 一位租户只能有一个房东,建立关系</span></span><br><span class="line">    <span class="meta">@ManyToOne</span>(targetEntity = Landlord.class, fetch = FetchType.LAZY)</span><br><span class="line">    <span class="comment">// 用于配置外键,如果不配置也会默认生成(最好自己配上,生成的外键字段可读性更好)</span></span><br><span class="line">    <span class="meta">@JoinColumn</span>(name = <span class="string">"land_tenant_fk"</span>, referencedColumnName = <span class="string">"l_id"</span>) </span><br><span class="line">    <span class="keyword">private</span> Landlord landlord;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 省略默认构造方法,get/set方法,toString()方法</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="多对多关系配置"><a href="#多对多关系配置" class="headerlink" title="多对多关系配置"></a>多对多关系配置</h2><p>多对多配置以后会生成一个中间表,中间表维护了两个表之间的关系.但是在配置的时候,要分清楚关系维护端(保留关联关系),<strong>任何两个表之间都有主从之分</strong></p><p><strong>主表:hb_teacher对应的实体表</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Entity</span> <span class="comment">// 指定这是一个实体类.在创建EntityManagerFactory的时候就会读取映射配置</span></span><br><span class="line"><span class="meta">@Table</span>(name = <span class="string">"hb_teacher"</span>) <span class="comment">// 指定该表所在数据库中的表名</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Teacher</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Id</span> <span class="comment">// 主键</span></span><br><span class="line">    <span class="meta">@GeneratedValue</span>(strategy = GenerationType.IDENTITY) <span class="comment">// 主键生成策略</span></span><br><span class="line">    <span class="meta">@Column</span>(name = <span class="string">"t_id"</span>) <span class="comment">// 主键在数据库中对应的字段名</span></span><br><span class="line">    <span class="keyword">private</span> Long tid;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    <span class="meta">@Column</span>(name = <span class="string">"t_name"</span>)</span><br><span class="line">    <span class="keyword">private</span> String tname;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Column</span>(name = <span class="string">"t_age"</span>)</span><br><span class="line">    <span class="keyword">private</span> String tage;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// targetEntity:映射的另一方实体的类</span></span><br><span class="line">    <span class="comment">// mappedBy : 被对方维护关联关系(也就是说放弃了维护关联关系的权利)</span></span><br><span class="line">    <span class="meta">@ManyToMany</span>(targetEntity = Student.class,mappedBy = <span class="string">"teachers"</span>)</span><br><span class="line">    <span class="keyword">private</span> Set&lt;Student&gt; students = <span class="keyword">new</span> HashSet&lt;&gt;(<span class="number">0</span>);</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">Teacher</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 省略get/set方法,省略toString方法</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>从表:hb_student表对应的实:</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Entity</span></span><br><span class="line"><span class="meta">@Table</span>(name = <span class="string">"hb_student"</span>)</span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Student</span> </span>&#123;</span><br><span class="line">    <span class="meta">@Id</span></span><br><span class="line">    <span class="meta">@GeneratedValue</span>(strategy = GenerationType.IDENTITY)</span><br><span class="line">    <span class="meta">@Column</span>(name = <span class="string">"s_id"</span>)</span><br><span class="line">    <span class="keyword">private</span> Long sid;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Column</span>(name = <span class="string">"s_name"</span>)</span><br><span class="line">    <span class="keyword">private</span> String sname;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Column</span>(name = <span class="string">"s_age"</span>)</span><br><span class="line">    <span class="keyword">private</span> String sage;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@ManyToMany</span>(targetEntity = Teacher.class)</span><br><span class="line">    <span class="meta">@JoinTable</span>(</span><br><span class="line">            name = <span class="string">"stu_tea_ref"</span>, <span class="comment">// 中间表的表名</span></span><br><span class="line">            joinColumns = &#123;</span><br><span class="line">                    <span class="comment">// 指定自己一方在表中维护的字段.name:字段名;referencedColumnName:关联的字段名称</span></span><br><span class="line">                    <span class="meta">@JoinColumn</span>(name = <span class="string">"stu_id"</span>, referencedColumnName = <span class="string">"s_id"</span>)</span><br><span class="line">            &#125;,</span><br><span class="line">            inverseJoinColumns = &#123;</span><br><span class="line">                    <span class="comment">// 指定对方在表中维护的字段.name:字段名;referencedColumnName:关联的字段的名称</span></span><br><span class="line">                    <span class="meta">@JoinColumn</span>(name = <span class="string">"tea_id"</span>, referencedColumnName = <span class="string">"t_id"</span>)</span><br><span class="line">            &#125;</span><br><span class="line">    )</span><br><span class="line">    <span class="keyword">private</span> Set&lt;Teacher&gt; teachers = <span class="keyword">new</span> HashSet&lt;&gt;(<span class="number">0</span>);</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">Student</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 省略get/set方法,省略toString()方法</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="在执行删除操作时"><a href="#在执行删除操作时" class="headerlink" title="在执行删除操作时:"></a>在执行删除操作时:</h2><p><strong>主控方(维护了关联关系的表)</strong>:</p><ul><li>可以同时将记录删除,并且删除中间表中的记录</li></ul><p><strong>从方(放弃维护关联关系的表):</strong></p><ul><li>如果该记录被中间表引用,不能删除</li><li><p>在从方配置了级联删除,会将该记录删除,中间表中的数据也会删除,但,<strong>同时会将主控方的表中也删除一条记录</strong>,这是不允许的</p><p>​</p></li></ul>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h1 id=&quot;Hibernate–4&quot;&gt;&lt;a href=&quot;#Hibernate–4&quot; class=&quot;headerlink&quot; title=&quot;Hibernate–4&quot;&gt;&lt;/a&gt;Hibernate–4&lt;/h1&gt;&lt;p&gt;JPA(&lt;em&gt;Java Persistence API&lt;/em&gt;)
      
    
    </summary>
    
    
      <category term="学习日记" scheme="https://blueleer.github.io/tags/%E5%AD%A6%E4%B9%A0%E6%97%A5%E8%AE%B0/"/>
    
      <category term="错误解决" scheme="https://blueleer.github.io/tags/%E9%94%99%E8%AF%AF%E8%A7%A3%E5%86%B3/"/>
    
      <category term="Hibernate" scheme="https://blueleer.github.io/tags/Hibernate/"/>
    
  </entry>
  
  <entry>
    <title>SSH项目搭建记录(基于Maven)</title>
    <link href="https://blueleer.github.io/2017/04/26/SSH%E9%A1%B9%E7%9B%AE%E6%90%AD%E5%BB%BA%E8%AE%B0%E5%BD%95/"/>
    <id>https://blueleer.github.io/2017/04/26/SSH项目搭建记录/</id>
    <published>2017-04-26T03:57:42.000Z</published>
    <updated>2018-04-26T16:05:21.159Z</updated>
    
    <content type="html"><![CDATA[<h1 id="框架版本选择"><a href="#框架版本选择" class="headerlink" title="框架版本选择"></a>框架版本选择</h1><ul><li>spring:<code>4.3.16</code></li><li>struts2:<code>2.5.16</code></li><li>hibernate:<code>5.2.16</code></li></ul>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h1 id=&quot;框架版本选择&quot;&gt;&lt;a href=&quot;#框架版本选择&quot; class=&quot;headerlink&quot; title=&quot;框架版本选择&quot;&gt;&lt;/a&gt;框架版本选择&lt;/h1&gt;&lt;ul&gt;
&lt;li&gt;spring:&lt;code&gt;4.3.16&lt;/code&gt;&lt;/li&gt;
&lt;li&gt;struts2:&lt;cod
      
    
    </summary>
    
    
      <category term="学习日记" scheme="https://blueleer.github.io/tags/%E5%AD%A6%E4%B9%A0%E6%97%A5%E8%AE%B0/"/>
    
      <category term="Hibernate" scheme="https://blueleer.github.io/tags/Hibernate/"/>
    
      <category term="Struts2" scheme="https://blueleer.github.io/tags/Struts2/"/>
    
      <category term="Spring" scheme="https://blueleer.github.io/tags/Spring/"/>
    
  </entry>
  
  <entry>
    <title>JPA概念解析-关联关系的维护</title>
    <link href="https://blueleer.github.io/2017/04/13/JPA%E6%A6%82%E5%BF%B5%E8%A7%A3%E6%9E%90-%E5%85%B3%E8%81%94%E5%85%B3%E7%B3%BB%E7%9A%84%E7%BB%B4%E6%8A%A4/"/>
    <id>https://blueleer.github.io/2017/04/13/JPA概念解析-关联关系的维护/</id>
    <published>2017-04-13T10:52:43.000Z</published>
    <updated>2018-04-13T12:10:17.988Z</updated>
    
    <content type="html"><![CDATA[<h1 id="JPA中的关联关系的维护"><a href="#JPA中的关联关系的维护" class="headerlink" title="JPA中的关联关系的维护"></a>JPA中的关联关系的维护</h1><p>数据库中的表之间一般有三种关系:一对一、一对多、多对多。</p><p>上面的三种关系都有主从表之分:例如</p><ul><li><p>一对一</p><p>客户表(cst_customer)和客户详情表(cst_info)：是先有的客户表，再有的客户详情表,因此客户表是主表，详情表是从表</p></li><li><p>一对多</p><p>房东表（landlord）和租户表（tenant）：是先有的房东表然后才有的租户表，房东表是主表，租户表是从表</p></li><li><p>多对多</p><p>老师表（teacher）和学生表（student）：是先有的老师表，才有的学生，所以老师表是主表，学生表是从表</p></li></ul><p>上面的分析只是从生活实际出发，因为从生活实际出发，这样就更好理解主表和从表之间的关系了。</p><p>从上面三种表关系的举例中，不知道大家有没有发现一个共同特点：主表相当于一个leader，二从表就是一个follower，似乎follower更关心它和leader之间的关系。</p><p>而在使用<code>JPA</code>时，把<strong>维护表之间关系的权利</strong>交给谁呢?</p><p>肯定是交给follower啦!!</p><p><strong>举例:(teacher和student,多对多关系)</strong></p><p><strong>老师表实体类:</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Entity</span> <span class="comment">// 指定这是一个实体类.在创建EntityManagerFactory的时候就会读取映射配置</span></span><br><span class="line"><span class="meta">@Table</span>(name = <span class="string">"hb_teacher"</span>) <span class="comment">// 指定该表所在数据库中的表名</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Teacher</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Id</span> <span class="comment">// 主键</span></span><br><span class="line">    <span class="meta">@GeneratedValue</span>(strategy = GenerationType.IDENTITY) <span class="comment">// 主键生成策略</span></span><br><span class="line">    <span class="meta">@Column</span>(name = <span class="string">"t_id"</span>) <span class="comment">// 主键在数据库中对应的字段名</span></span><br><span class="line">    <span class="keyword">private</span> Long tid;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    <span class="meta">@Column</span>(name = <span class="string">"t_name"</span>)</span><br><span class="line">    <span class="keyword">private</span> String tname;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Column</span>(name = <span class="string">"t_age"</span>)</span><br><span class="line">    <span class="keyword">private</span> String tage;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// targetEntity:映射的另一方实体的类</span></span><br><span class="line">    <span class="comment">// mappedBy : 生命关系的维护方(也就是说放弃了维护关联关系的权利)</span></span><br><span class="line">    <span class="meta">@ManyToMany</span>(targetEntity = Student.class,mappedBy = <span class="string">"teachers"</span>)</span><br><span class="line">    <span class="keyword">private</span> Set&lt;Student&gt; students = <span class="keyword">new</span> HashSet&lt;&gt;(<span class="number">0</span>);</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">Teacher</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 省略get/set方法,省略toString方法</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>老师放弃了维护表之间关系的权利,通过设定<code>mappedBy = &quot;teachers&quot;</code></p><p><strong>学生表实体类:</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Entity</span></span><br><span class="line"><span class="meta">@Table</span>(name = <span class="string">"hb_student"</span>)</span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Student</span> </span>&#123;</span><br><span class="line">    <span class="meta">@Id</span></span><br><span class="line">    <span class="meta">@GeneratedValue</span>(strategy = GenerationType.IDENTITY)</span><br><span class="line">    <span class="meta">@Column</span>(name = <span class="string">"s_id"</span>)</span><br><span class="line">    <span class="keyword">private</span> Long sid;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Column</span>(name = <span class="string">"s_name"</span>)</span><br><span class="line">    <span class="keyword">private</span> String sname;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Column</span>(name = <span class="string">"s_age"</span>)</span><br><span class="line">    <span class="keyword">private</span> String sage;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@ManyToMany</span>(targetEntity = Teacher.class,cascade = CascadeType.ALL)</span><br><span class="line">    <span class="meta">@JoinTable</span>(</span><br><span class="line">            name = <span class="string">"stu_tea_ref"</span>, <span class="comment">// 中间表的表名</span></span><br><span class="line">            joinColumns = &#123;</span><br><span class="line">                    <span class="comment">// 指定自己一方在表中维护的字段.name:字段名;referencedColumnName:关联的字段名称</span></span><br><span class="line">                    <span class="meta">@JoinColumn</span>(name = <span class="string">"stu_id"</span>, referencedColumnName = <span class="string">"s_id"</span>)</span><br><span class="line">            &#125;,</span><br><span class="line">            inverseJoinColumns = &#123;</span><br><span class="line">                    <span class="comment">// 指定对方在表中维护的字段.name:字段名;referencedColumnName:关联的字段的名称</span></span><br><span class="line">                    <span class="meta">@JoinColumn</span>(name = <span class="string">"tea_id"</span>, referencedColumnName = <span class="string">"t_id"</span>)</span><br><span class="line">            &#125;</span><br><span class="line">    )</span><br><span class="line">    <span class="keyword">private</span> Set&lt;Teacher&gt; teachers = <span class="keyword">new</span> HashSet&lt;&gt;(<span class="number">0</span>);</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">Student</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 省略get/set方法,省略toString方法</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>学生表维护了和老师表之间的关联关系,你看看它设置了那么多的字段,自己和老师在中间表中的字段都是自己负责设置的,通过设置字段<code>joinColumns</code>和<code>inverseJoinColumns</code>来指定。</p><p>实际上本应该就是这样，老师比少，学生比较多，让一个老师记住他教的所有的学生是很困难的，而把这个任务交个学生就相对简单多啦。</p><p>接下来，看看这样几种场景：</p><ol><li><p>删除teacher表中的一条记录，如果该记录被中间表引用，能不能删除呢？</p><p>答案是：如果没有设置级联删除，这个记录是不能删除的。试想他能删除，它删除以后，中间表中的数据怎么办，因为它是没有权利维护表关系的。</p></li><li><p>删除student表中的一条记录，如果该记录被中间表引用，能不能删除呢？</p><p>答案是：是可以删除的。他删除以后，会连同中间表中和自己相关的数据也删除掉。因为它负责维护量表之间的关系！！</p></li><li><p>针对第一种情况，能不能删除呢，答案是可以的，但是，不但要在Teacher中设置<code>@ManyToMany(targetEntity = Student.class, mappedBy = &quot;teachers&quot;)</code>标签中设置<code>cascade = CascadeType.REMOVE)</code>,因为仅仅只这样设置的话,级联关系是整个表的字段,仅仅这样设置是很危险的。还应该应该给中间表与teacher表相关联的联合主键<code>tea_id</code>加上级联删除</p><p><code>ALTER TABLE stu_tea_ref ADD CONSTRAINT tea_id FOREIGN KEY (tea_id) REFERENCES hb_teacher(t_id) ON DELETE CASCADE ;</code></p><p>说明:<code>stu_tea_ref</code>是中间表,<code>tea_id</code>是引用teacher表主键的联合主键</p><p>当删除teacher时,因为应用了级联删除,在中间表将与其主键值相同的相关记录也删除了,没有级联到其他的字段,student表不受影响.</p></li></ol><p>不严谨之处,敬请指出,请关注我的博客:</p><p><a href="https://blueleer.github.io/">Lee个人博客</a></p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h1 id=&quot;JPA中的关联关系的维护&quot;&gt;&lt;a href=&quot;#JPA中的关联关系的维护&quot; class=&quot;headerlink&quot; title=&quot;JPA中的关联关系的维护&quot;&gt;&lt;/a&gt;JPA中的关联关系的维护&lt;/h1&gt;&lt;p&gt;数据库中的表之间一般有三种关系:一对一、一对多、多对多。&lt;/
      
    
    </summary>
    
      <category term="数据库" scheme="https://blueleer.github.io/categories/%E6%95%B0%E6%8D%AE%E5%BA%93/"/>
    
    
      <category term="Hibernate" scheme="https://blueleer.github.io/tags/Hibernate/"/>
    
      <category term="数据库" scheme="https://blueleer.github.io/tags/%E6%95%B0%E6%8D%AE%E5%BA%93/"/>
    
  </entry>
  
  <entry>
    <title>JPA概念解析-CascadeType详解</title>
    <link href="https://blueleer.github.io/2017/04/13/JPA%E6%A6%82%E5%BF%B5%E8%A7%A3%E6%9E%90-CascadeType%E8%AF%A6%E8%A7%A3/"/>
    <id>https://blueleer.github.io/2017/04/13/JPA概念解析-CascadeType详解/</id>
    <published>2017-04-13T10:26:56.000Z</published>
    <updated>2018-04-13T12:10:24.879Z</updated>
    
    <content type="html"><![CDATA[<ul><li><p>CascadeType.REMOVE</p><p>Cascade remove operation，级联删除操作。<br>删除当前实体时，与它有映射关系的实体也会跟着被删除。</p></li><li><p>CascadeType.MERGE</p><p>Cascade merge operation，级联更新（合并）操作。<br>当Student中的数据改变，会相应地更新Course中的数据。</p></li><li><p>CascadeType.DETACH</p><p>Cascade detach operation，级联脱管/游离操作。<br>如果你要删除一个实体，但是它有外键无法删除，你就需要这个级联权限了。它会撤销所有相关的外键关联。</p></li><li><p>CascadeType.REFRESH</p><p>Cascade refresh operation，级联刷新操作。<br>假设场景 有一个订单,订单里面关联了许多商品,这个订单可以被很多人操作,那么这个时候A对此订单和关联的商品进行了修改,与此同时,B也进行了相同的操作,但是B先一步比A保存了数据,那么当A保存数据的时候,就需要先刷新订单信息及关联的商品信息后,再将订单及商品保存。</p></li><li><p>CascadeType.ALL</p><p>Cascade all operations，清晰明确，拥有以上所有级联操作权限。</p></li></ul>]]></content>
    
    <summary type="html">
    
      
      
        &lt;ul&gt;
&lt;li&gt;&lt;p&gt;CascadeType.REMOVE&lt;/p&gt;
&lt;p&gt;Cascade remove operation，级联删除操作。&lt;br&gt;删除当前实体时，与它有映射关系的实体也会跟着被删除。&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;&lt;p&gt;CascadeType.MERGE&lt;/p&gt;

      
    
    </summary>
    
      <category term="数据库" scheme="https://blueleer.github.io/categories/%E6%95%B0%E6%8D%AE%E5%BA%93/"/>
    
    
      <category term="Hibernate" scheme="https://blueleer.github.io/tags/Hibernate/"/>
    
      <category term="数据库" scheme="https://blueleer.github.io/tags/%E6%95%B0%E6%8D%AE%E5%BA%93/"/>
    
  </entry>
  
  <entry>
    <title>数据库引擎MyISAM和InnoDB及简单的源码分析</title>
    <link href="https://blueleer.github.io/2017/04/12/%E6%95%B0%E6%8D%AE%E5%BA%93%E5%BC%95%E6%93%8EMyISAM%E5%92%8CInnoDB/"/>
    <id>https://blueleer.github.io/2017/04/12/数据库引擎MyISAM和InnoDB/</id>
    <published>2017-04-12T15:38:22.000Z</published>
    <updated>2018-04-12T16:31:57.786Z</updated>
    
    <content type="html"><![CDATA[<p>问题描述:</p><ul><li><p>今天在使用Hibernate框架(版本为<code>5.2.16</code>),建立多表关联映射关系时,发现从表中没有创建关联外键约束,进而导致:从表中应用了主表的主键作为外键,此时删除主表中相关联的数据依然行得通,也就是说从表中的外键在主表中找不到对应的记录与之对应了.</p></li><li><p>检查了关联关系配置文件中没有问题</p></li><li><p>最后在这个地方找到了答案:发现数据库的 engine 是MyISAM类型的</p></li><li><p>MyISAM不支持外键!!!!</p></li><li><p>在配置文件中发现:</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">"hibernate.dialect.storage_engine"</span>&gt;</span></span><br><span class="line">    org.hibernate.dialect.MySQL5Dialect</span><br><span class="line"><span class="tag">&lt;/<span class="name">property</span>&gt;</span></span><br></pre></td></tr></table></figure><p>跟到源码中发现:配置了这一项默认使用的就是MyISAM引擎(源码在后面)</p></li><li><p>好啦,接下来对比下MyISAM和InnoDB:<em>**</em></p><p><strong>区别:</strong></p><blockquote><ol><li>InnoDB支持事务，MyISAM不支持，对于InnoDB每一条SQL语言都默认封装成事务，自动提交，这样会影响速度，所以最好把多条SQL语言放在begin和commit之间，组成一个事务；  </li><li>InnoDB支持外键，而MyISAM不支持。对一个包含外键的InnoDB表转为MYISAM会失败；  </li><li>InnoDB是聚集索引，数据文件是和索引绑在一起的，必须要有主键，通过主键索引效率很高。但是辅助索引需要两次查询，先查询到主键，然后再通过主键查询到数据。因此，主键不应该过大，因为主键太大，其他索引也都会很大。而MyISAM是非聚集索引，数据文件是分离的，索引保存的是数据文件的指针。主键索引和辅助索引是独立的。 </li><li>InnoDB不保存表的具体行数，执行select count(*) from table时需要全表扫描。而MyISAM用一个变量保存了整个表的行数，执行上述语句时只需要读出该变量即可，速度很快；  </li><li>Innodb不支持全文索引，而MyISAM支持全文索引，查询效率上MyISAM要高；  </li></ol></blockquote><p><strong>如何选择:</strong></p><blockquote><ol><li>是否要支持事务，如果要请选择innodb，如果不需要可以考虑MyISAM；</li><li>如果表中绝大多数都只是读查询，可以考虑MyISAM，如果既有读写也挺频繁，请使用InnoDB。</li><li>系统奔溃后，MyISAM恢复起来更困难，能否接受；</li><li>MySQL5.5版本开始Innodb已经成为Mysql的默认引擎(之前是MyISAM)，说明其优势是有目共睹的，如果你不知道用什么，那就用InnoDB，至少不会差。</li><li>另外:<code>mysql5.7</code>的innodb已支持全文索引</li></ol></blockquote></li></ul><p>为了保证支持<strong>事务</strong>、<strong>外键</strong>，在Hibernate的hibernate.cfg.xml中的<code>hibernate.dialect.storage_engine</code>配置中，应该这么配置:</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">"hibernate.dialect.storage_engine"</span>&gt;</span></span><br><span class="line">    org.hibernate.dialect.MySQL55Dialect</span><br><span class="line"><span class="tag">&lt;/<span class="name">property</span>&gt;</span></span><br><span class="line"><span class="comment">&lt;!--我的MySQL版本是5.5,而5.5默认的engine是InnoDB--&gt;</span></span><br></pre></td></tr></table></figure><p>而且注意:<code>org.hibernate.dialect.MySQLDialect</code>在<code>MySQL5.5</code>以上已经不能再使用了.</p><p>源码分析:</p><p><code>MySQL5Dialect</code>继承自<code>MySQLDialect</code>,没有重载构造方法</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">MySQL5Dialect</span> <span class="keyword">extends</span> <span class="title">MySQLDialect</span> </span>&#123;</span><br><span class="line">    ...</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>进入到<code>MySQLDialect</code>中</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Constructs a MySQLDialect</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="title">MySQLDialect</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">super</span>();</span><br><span class="line"></span><br><span class="line">    String storageEngine = Environment.getProperties().getProperty( Environment.STORAGE_ENGINE ); <span class="comment">// null</span></span><br><span class="line">    <span class="keyword">if</span>(storageEngine == <span class="keyword">null</span>) &#123;</span><br><span class="line">        storageEngine = System.getProperty( Environment.STORAGE_ENGINE );</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span>(storageEngine == <span class="keyword">null</span>) &#123;</span><br><span class="line">        <span class="keyword">this</span>.storageEngine = getDefaultMySQLStorageEngine(); <span class="comment">// 进入到此方法</span></span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// ...省略...</span></span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">protected</span> MySQLStorageEngine <span class="title">getDefaultMySQLStorageEngine</span><span class="params">()</span> </span>&#123;</span><br><span class="line"><span class="keyword">return</span> MyISAMStorageEngine.INSTANCE; <span class="comment">// 返回MyISAM引擎</span></span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;问题描述:&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;&lt;p&gt;今天在使用Hibernate框架(版本为&lt;code&gt;5.2.16&lt;/code&gt;),建立多表关联映射关系时,发现从表中没有创建关联外键约束,进而导致:从表中应用了主表的主键作为外键,此时删除主表中相关联的数据依然行得通,也就是说从表
      
    
    </summary>
    
      <category term="数据库" scheme="https://blueleer.github.io/categories/%E6%95%B0%E6%8D%AE%E5%BA%93/"/>
    
    
      <category term="错误解决" scheme="https://blueleer.github.io/tags/%E9%94%99%E8%AF%AF%E8%A7%A3%E5%86%B3/"/>
    
      <category term="数据库" scheme="https://blueleer.github.io/tags/%E6%95%B0%E6%8D%AE%E5%BA%93/"/>
    
      <category term="MySQL" scheme="https://blueleer.github.io/tags/MySQL/"/>
    
  </entry>
  
  <entry>
    <title>idea中Mark Directory As里的Sources Root、ReSources Root等的区别</title>
    <link href="https://blueleer.github.io/2017/04/10/idea%E4%B8%ADMark%20Directory%20As%E9%87%8C%E7%9A%84Sources%20Root%E3%80%81ReSources%20Root%E7%AD%89%E7%9A%84%E5%8C%BA%E5%88%AB/"/>
    <id>https://blueleer.github.io/2017/04/10/idea中Mark Directory As里的Sources Root、ReSources Root等的区别/</id>
    <published>2017-04-10T12:53:33.000Z</published>
    <updated>2018-04-20T08:50:22.945Z</updated>
    
    <content type="html"><![CDATA[<h2 id="1-Source-roots-or-source-folders"><a href="#1-Source-roots-or-source-folders" class="headerlink" title="1.Source roots (or source folders)"></a>1.Source roots (or source folders)</h2><p>通过这个类指定一个文件夹，你告诉IntelliJ IDEA，这个文件夹及其子文件夹中包含的源代码，可以编译为构建过程的一部分。</p><h2 id="2-Test-source-roots-or-test-source-folders-shown-as-rootTest"><a href="#2-Test-source-roots-or-test-source-folders-shown-as-rootTest" class="headerlink" title="2.Test source roots (or test source folders; shown as rootTest)"></a>2.Test source roots (or test source folders; shown as rootTest)</h2><p>这些根类似于源根，但用于用于测试的代码（例如用于单元测试）。测试源文件夹允许您将与测试相关的代码与生产代码分开。</p><p>通常，源和测试源的编译结果被放置在不同的文件夹中。</p><h2 id="3-Resource-roots"><a href="#3-Resource-roots" class="headerlink" title="3.Resource roots"></a>3.Resource roots</h2><p>用于应用程序中的资源文件（图像、各种配置XML和属性文件等）。</p><p>在构建过程中，资源文件夹的所有内容都复制到输出文件夹中。</p><p>类似于源，您可以指定生成资源。您还可以指定输出文件夹中的文件夹，您的资源应该复制到。</p><h2 id="4-Test-resource-roots"><a href="#4-Test-resource-roots" class="headerlink" title="4. Test resource roots"></a>4. Test resource roots</h2><p>（或测试资源文件夹；如roottestresourceij；只有在java模块）是资源文件与您的测试源有关。在所有其他方面，这些文件夹类似于资源文件夹。</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h2 id=&quot;1-Source-roots-or-source-folders&quot;&gt;&lt;a href=&quot;#1-Source-roots-or-source-folders&quot; class=&quot;headerlink&quot; title=&quot;1.Source roots (or source fo
      
    
    </summary>
    
    
      <category term="Intellij工具使用" scheme="https://blueleer.github.io/tags/Intellij%E5%B7%A5%E5%85%B7%E4%BD%BF%E7%94%A8/"/>
    
  </entry>
  
  <entry>
    <title>Struts2使用重点笔记</title>
    <link href="https://blueleer.github.io/2017/04/10/Struts2%E4%BD%BF%E7%94%A8%E7%AC%94%E8%AE%B0/"/>
    <id>https://blueleer.github.io/2017/04/10/Struts2使用笔记/</id>
    <published>2017-04-10T12:53:33.000Z</published>
    <updated>2018-04-27T06:15:10.617Z</updated>
    
    <content type="html"><![CDATA[<h2 id="Struts2使用笔记"><a href="#Struts2使用笔记" class="headerlink" title="Struts2使用笔记"></a>Struts2使用笔记</h2><ul><li><p>配置文件的加载顺序</p><p>struts.xml -&gt; struts.properties -&gt; web.xml</p><p>这三个文件都是可以修改 <code>struts2</code>常量的值，但是后面的重复的值会覆盖前面的值</p></li><li><p>在上面三个文件中都是可以配置常量值的</p></li><li><p>通常在struts.xml中配置常量或者其他的Action,项目比较大时,难免臃肿,此时可以使用include标签来引入其他的xml配置文件,其格式遵循struts.xml文件的格式</p></li><li><p>在struts.xml中配置action的三种方式:</p><ul><li><p>指定method</p></li><li><p>通过通配符”*”匹配</p></li><li><p>动态方法访问,注意:struts2.5以后默认关闭,需要配置打开,同时在package中配置</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">global-allowed-methods</span>&gt;</span>regex:.*<span class="tag">&lt;/<span class="name">global-allowed-methods</span>&gt;</span></span><br></pre></td></tr></table></figure><p>​</p><p>​</p></li></ul></li><li><hr><p>结果页面配置</p><ul><li><p>局部结果页面配置</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">action</span> <span class="attr">name</span>=<span class="string">"user_*"</span> <span class="attr">class</span>=<span class="string">"com.lee.struts2test.UserController"</span> <span class="attr">method</span>=<span class="string">"&#123;1&#125;"</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">result</span> <span class="attr">name</span>=<span class="string">"login_success"</span>&gt;</span></span><br><span class="line">        /index.jsp</span><br><span class="line">    <span class="tag">&lt;/<span class="name">result</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">result</span> <span class="attr">name</span>=<span class="string">"regist_success"</span>&gt;</span></span><br><span class="line">        /login.jsp</span><br><span class="line">    <span class="tag">&lt;/<span class="name">result</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">action</span>&gt;</span></span><br></pre></td></tr></table></figure><p>是在action中配置</p></li><li><p>全局结果页面配置</p><p>全局结果页面展示必须放在局部的action标签之前</p></li><li><p><code>result</code>标签中的type属性</p><ul><li>dispatcher:转发,默认</li><li>redirect:重定向</li></ul></li><li><p>​</p></li></ul></li><li><p>Action中常用的两个类</p><ul><li>ActionContext</li><li>ServletActionContext</li></ul></li><li><p>ServletRequestAware接口,在方法中获取HttpServletRequest对象</p></li><li><p>表单数据的封装</p><ul><li>原始方法,得到request中的参数</li><li>属性封装<ul><li>提供Entity中的属性和get/set方法,Action会自动调用给属性赋值(获取表单数据到成员变量里面,不能把数据直接封装到实体类里面)</li><li>表达式封装,在页面通过使用user.userName分方式来设置表单的name属性(在Action中必须提供get方法,返回user为属性名的一个实体)</li></ul></li><li>模型驱动封装<ul><li>可以直接把表单数据封装到实体类里面,一个Action类中只能有一个实体类对象</li></ul></li></ul></li><li><p>使用表达式封装,可以将数据封装到List或者Map中</p><p>​</p><p>​</p><p>​</p><p>​</p></li></ul><ol><li><strong>配置的时候,<code>Intellij</code>自动生成了全局过滤器</strong></li></ol><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">filter</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">filter-name</span>&gt;</span>struts2<span class="tag">&lt;/<span class="name">filter-name</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">filter-class</span>&gt;</span>org.apache.struts2.dispatcher.ng.filter.StrutsPrepareAndExecuteFilter<span class="tag">&lt;/<span class="name">filter-class</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">filter</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">filter-mapping</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">filter-name</span>&gt;</span>struts2<span class="tag">&lt;/<span class="name">filter-name</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">url-pattern</span>&gt;</span>/*<span class="tag">&lt;/<span class="name">url-pattern</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">filter-mapping</span>&gt;</span></span><br></pre></td></tr></table></figure><p>其中</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">org.apache.struts2.dispatcher.ng.filter.StrutsPrepareAndExecuteFilter</span><br></pre></td></tr></table></figure><p>爆红,原来如果jar包确认没问题的话,检查你的Struts2版本,如果是2.5版本以上的话,将<strong>.ng</strong>去掉,我的是2.5.14.1,修改成</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">filter</span>&gt;</span></span><br><span class="line">       <span class="tag">&lt;<span class="name">filter-name</span>&gt;</span>struts2<span class="tag">&lt;/<span class="name">filter-name</span>&gt;</span></span><br><span class="line">       <span class="tag">&lt;<span class="name">filter-class</span>&gt;</span>org.apache.struts2.dispatcher.filter.StrutsPrepareAndExecuteFilter<span class="tag">&lt;/<span class="name">filter-class</span>&gt;</span></span><br><span class="line">   <span class="tag">&lt;/<span class="name">filter</span>&gt;</span></span><br></pre></td></tr></table></figure><ol start="2"><li><p><strong>使用通配符”*”配置<code>struts.xml</code>中的action访问路径的时候,运行时出现异常,action映射的方法没有找到,解决办法:</strong></p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">action</span> <span class="attr">name</span>=<span class="string">"customer_*"</span> <span class="attr">class</span>=<span class="string">"com.lee.crm.customer.action.CustomerAction"</span> <span class="attr">method</span>=<span class="string">"&#123;1&#125;"</span>&gt;</span></span><br><span class="line">            <span class="comment">&lt;!--添加客户--&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">result</span> <span class="attr">name</span>=<span class="string">"add_success"</span>&gt;</span>/jsp/success.jsp<span class="tag">&lt;/<span class="name">result</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">result</span> <span class="attr">name</span>=<span class="string">"add_error"</span>&gt;</span>/jsp/customer/add.jsp<span class="tag">&lt;/<span class="name">result</span>&gt;</span></span><br><span class="line"></span><br><span class="line">            <span class="comment">&lt;!--客户列表--&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">result</span> <span class="attr">name</span>=<span class="string">"list_success"</span>&gt;</span>/jsp/customer/list.jsp<span class="tag">&lt;/<span class="name">result</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">result</span> <span class="attr">name</span>=<span class="string">"list_error"</span>&gt;</span>/jsp/error.jsp<span class="tag">&lt;/<span class="name">result</span>&gt;</span></span><br><span class="line">    <span class="comment">&lt;!--更新客户--&gt;</span></span><br><span class="line">           <span class="tag">&lt;<span class="name">result</span> <span class="attr">name</span>=<span class="string">"update_success"</span>&gt;</span>/jsp/customer/add.jsp<span class="tag">&lt;/<span class="name">result</span>&gt;</span></span><br><span class="line">           <span class="tag">&lt;<span class="name">result</span> <span class="attr">name</span>=<span class="string">"update_error"</span>&gt;</span>/jsp/error.jsp<span class="tag">&lt;/<span class="name">result</span>&gt;</span></span><br><span class="line"></span><br><span class="line">           <span class="comment">&lt;!--使用通配符匹配的时候,加上这一句--&gt;</span></span><br><span class="line">           <span class="tag">&lt;<span class="name">allowed-methods</span>&gt;</span>add,list,update<span class="tag">&lt;/<span class="name">allowed-methods</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">action</span>&gt;</span></span><br></pre></td></tr></table></figure></li></ol><p>加上<code>&lt;allowed-methods&gt;add,list,update&lt;/allowed-methods&gt;</code></p><ol start="3"><li><p>使用模型驱动封装表单数据,在需要对表单对应的实体进行更新的时候**</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">CustomerAction</span> <span class="keyword">extends</span> <span class="title">ActionSupport</span> <span class="keyword">implements</span> <span class="title">ModelDriven</span>&lt;<span class="title">Customer</span>&gt; </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> Customer customer = <span class="keyword">new</span> Customer();</span><br><span class="line">     <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> Customer <span class="title">getModel</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> customer;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">public</span> String <span class="title">preUpdate</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="comment">// 获取custid</span></span><br><span class="line">        String custId = ServletActionContext.getRequest().getParameter(<span class="string">"custId"</span>);</span><br><span class="line">        Customer customer = mCustomerService.findCustomerById(Long.parseLong(custId));</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 将customer对象设置到值栈中,更新model对象,回显</span></span><br><span class="line">        <span class="keyword">this</span>.customer = customer;</span><br><span class="line"><span class="comment">//        ActionContext.getContext().getValueStack().push(this.customer);</span></span><br><span class="line">        <span class="keyword">return</span> <span class="string">"pre_update_success"</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>发现从ValueStack中获取的值依然是更新之前的值.这是由于action中的customer的确是更新了,但是valuestack中的值依然是旧值,而在页面中通过<code>&lt;s:property value=&#39;custId&#39; /&gt;</code>获取的也是旧值</p><p>解决办法有多种,这里介绍两种常用的方法:</p><ul><li><p>第一种:</p><p><code>ActionContext.getContext().getValueStack().push(this.customer);</code></p><p>将新的值压入栈顶,页面获取的就是新的对象的值了</p></li><li><p>第二种:</p><p>在相应的action标签中加入</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">action</span> <span class="attr">name</span>=<span class="string">"customer_*"</span> <span class="attr">class</span>=<span class="string">"com.lee.crm.customer.action.CustomerAction"</span> <span class="attr">method</span>=<span class="string">"&#123;1&#125;"</span>&gt;</span></span><br><span class="line"></span><br><span class="line">            <span class="tag">&lt;<span class="name">interceptor-ref</span> <span class="attr">name</span>=<span class="string">"defaultStack"</span>&gt;</span></span><br><span class="line">                <span class="comment">&lt;!-- 渲染页面前刷新model在ValueStack的root的引用 --&gt;</span></span><br><span class="line">                <span class="comment">&lt;!--这样在valuestack中会自动压入一个新的值,跟手动调用push方法是一样的--&gt;</span></span><br><span class="line">                <span class="tag">&lt;<span class="name">param</span> <span class="attr">name</span>=<span class="string">"modelDriven.refreshModelBeforeResult"</span>&gt;</span>true<span class="tag">&lt;/<span class="name">param</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;/<span class="name">interceptor-ref</span>&gt;</span></span><br><span class="line"> <span class="tag">&lt;/<span class="name">action</span>&gt;</span></span><br></pre></td></tr></table></figure><p>同时在action中给对象赋上新的值</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">this</span>.customer = customer;</span><br></pre></td></tr></table></figure></li></ul><ol start="4"><li><p>ValueStack压入的对象是以对象的属性名作为key,属性值作为value存贮在map中的,所以在页面中取值的时候直接通过Property Name取值,具体可以多用用&lt;s:debug&gt;&lt;s:debug&gt;标签看看<code>Value Stack Contents</code>中值的存放形式</p></li><li><p>在使用struts.xml文件时，经常因为格式导致不必要的错误。<br>例：</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">package</span> <span class="attr">name</span>=<span class="string">"default"</span> <span class="attr">extends</span>=<span class="string">"struts-default"</span> <span class="attr">namespace</span>=<span class="string">"/namespace1"</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">action</span> <span class="attr">name</span>=<span class="string">"initFStree"</span> <span class="attr">class</span>=<span class="string">"InitFStree"</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">result</span> <span class="attr">name</span>=<span class="string">"success"</span>&gt;</span>pages/initFStree.jsp<span class="tag">&lt;/<span class="name">result</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;/<span class="name">action</span>&gt;</span></span><br><span class="line"> <span class="tag">&lt;/<span class="name">package</span>&gt;</span></span><br></pre></td></tr></table></figure><p>​</p><p>说明：</p><ol><li>namespace=”?”     ? : 需要以‘/‘开头，否则使用默认的namespace，即‘/‘</li><li><result name="success">?</result><br>  ? : <1> 如果以’/‘开始，则路径为相对于web根目录的路径<pre><code>&lt;2&gt; 如果不以&apos;/&apos;开始，则路径为相对于namespace的路径例：如上述代码的所表示的路径：/webroot/namespace1/pages/initFStree.jsp,如果你的文件在/webroot/pages/initFStree.jsp，则浏览器会显示找不到指定文件。</code></pre></1></li><li>如果在jsp页面里有引用相对地址，如：<br><script type="text/javascript" src="../jquey/jquery.js"></script><br>src指定的路径为相对于浏览器中URL，及与namespace有关，而于result指定的返回文件的路径无关。</li></ol></li></ol></li></ol>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h2 id=&quot;Struts2使用笔记&quot;&gt;&lt;a href=&quot;#Struts2使用笔记&quot; class=&quot;headerlink&quot; title=&quot;Struts2使用笔记&quot;&gt;&lt;/a&gt;Struts2使用笔记&lt;/h2&gt;&lt;ul&gt;
&lt;li&gt;&lt;p&gt;配置文件的加载顺序&lt;/p&gt;
&lt;p&gt;struts.x
      
    
    </summary>
    
    
      <category term="学习日记" scheme="https://blueleer.github.io/tags/%E5%AD%A6%E4%B9%A0%E6%97%A5%E8%AE%B0/"/>
    
      <category term="错误解决" scheme="https://blueleer.github.io/tags/%E9%94%99%E8%AF%AF%E8%A7%A3%E5%86%B3/"/>
    
      <category term="Struts2" scheme="https://blueleer.github.io/tags/Struts2/"/>
    
  </entry>
  
  <entry>
    <title>Hibernate学习笔记3</title>
    <link href="https://blueleer.github.io/2017/04/10/Hibernate%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B03/"/>
    <id>https://blueleer.github.io/2017/04/10/Hibernate学习笔记3/</id>
    <published>2017-04-10T12:53:33.000Z</published>
    <updated>2018-04-13T12:15:20.182Z</updated>
    
    <content type="html"><![CDATA[<h1 id="Hibernate–3"><a href="#Hibernate–3" class="headerlink" title="Hibernate–3"></a>Hibernate–3</h1><p>学习大纲:</p><ul><li><p>数据库中表的关系</p><ul><li><p>一对一</p></li><li><p>一对多</p></li><li><p>多对多</p><p>注意:不管是哪种关系,在逻辑上都有主表和从表之分</p></li></ul></li><li><p>外键 : 从表中的一列来源于主表的主键,或者为null,默认情况下外键是可以重复的</p></li><li><p>如何确立和实现表之间的关系</p><ul><li><p>确立:看表的外键90%的情况下能确立表之间的关系</p></li><li><p>实现:</p><ul><li><p>一对一 (A表和B表): </p><ul><li>B表中的外键是A表的主键,且此外键设置唯一约束,非空约束</li><li>B表的外键是A表的主键,同时又是主键</li></ul></li><li><p>一对多(A表和B表):</p><p>其中A表示主表,B表示从表,主表一般指的是一,从表指的是多</p><p>B表的外键是A表的主键,也可以为null</p></li><li><p>多对多(A表和B表)</p><p>维护一个第三表,该表只有两个字段,且都为主键,引用自A,B两个表的主键</p><p>任何一个多表和第三表之间的关系都是一对多的关系</p></li></ul></li></ul></li><li><p>使用Hibernate多表映射配置的步骤</p><ul><li>第一步:确立两张表之间的关系</li><li>第二步:在数据库中创建出这两张表,并实现两张表之间的关系</li><li>第三步:在实体类中描述出两个实体之间的关系</li><li>第四步:在映射配置文件中配置两张表之间的关系</li></ul></li></ul><h2 id="情景一-建立房东-landlord-数据表和租户-tenant-数据表"><a href="#情景一-建立房东-landlord-数据表和租户-tenant-数据表" class="headerlink" title="情景一:建立房东(landlord)数据表和租户(tenant)数据表"></a>情景一:建立房东(landlord)数据表和租户(tenant)数据表</h2><ul><li><p>第一步:确立两张表之间的关系</p><p>一个房东可以有多个租户</p><p>一个租户只能有一个房东</p><p>所以房东和租户之间是一对多的关系</p></li><li><p>第二步:在数据库中创建出这两张表,并实现两张表之间的关系</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/*房东信息表*/</span></span><br><span class="line"><span class="keyword">CREATE</span> <span class="keyword">TABLE</span> hb_landlord(</span><br><span class="line">    l_id <span class="built_in">INT</span> PRIMARY <span class="keyword">KEY</span> AUTO_INCREMENT,</span><br><span class="line">    l_name <span class="built_in">VARCHAR</span>(<span class="number">10</span>),</span><br><span class="line">    l_sex <span class="built_in">CHAR</span>(<span class="number">1</span>),</span><br><span class="line">    l_age <span class="built_in">INT</span>(<span class="number">3</span>),</span><br><span class="line">    l_phone <span class="built_in">VARCHAR</span>(<span class="number">15</span>)</span><br><span class="line">)</span><br><span class="line"></span><br><span class="line"><span class="comment">/*租户信息表*/</span></span><br><span class="line"><span class="keyword">CREATE</span> <span class="keyword">TABLE</span> hb_tenant(</span><br><span class="line">    t_id <span class="built_in">INT</span> PRIMARY <span class="keyword">KEY</span> AUTO_INCREMENT,</span><br><span class="line">    t_name <span class="built_in">VARCHAR</span>(<span class="number">10</span>),</span><br><span class="line">    t_sex <span class="built_in">CHAR</span>(<span class="number">1</span>),</span><br><span class="line">    t_age <span class="built_in">INT</span>(<span class="number">3</span>),</span><br><span class="line">    t_phone <span class="built_in">VARCHAR</span>(<span class="number">15</span>),</span><br><span class="line">    t_job <span class="built_in">VARCHAR</span>(<span class="number">10</span>)</span><br><span class="line">)</span><br></pre></td></tr></table></figure><p>只要在Hibernate中配置好表的映射配置文件以后,获取Session的时候,会自动加载配置文件,Hibernate检查表是否已经创建,如果没有创建就替我们创建表</p></li><li><p>第三步:在实体类中描述出两个实体之间的关系</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 房东 表</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Landlord</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> Integer lid;</span><br><span class="line">    <span class="keyword">private</span> String lname;</span><br><span class="line">    <span class="keyword">private</span> String lsex;</span><br><span class="line">    <span class="keyword">private</span> Integer lage;</span><br><span class="line">    <span class="keyword">private</span> String lphone;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 一位房东可以包含多位租客,建立一对多关系</span></span><br><span class="line">    <span class="comment">// 注意这里的处理方式:防止后面调用添加租客的时候报空指针异常(set还没有创建),提前将其创建出来</span></span><br><span class="line">    <span class="comment">// 如果数据众多的时候,会有多个tenants创建,会很占用内存,所以初始化的时候现将其初始容量设置成0</span></span><br><span class="line">    <span class="keyword">private</span> Set&lt;Tenant&gt; tenants = <span class="keyword">new</span> HashSet&lt;&gt;(<span class="number">0</span>);</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">Landlord</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> Set&lt;Tenant&gt; <span class="title">getTenants</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> tenants;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setTenants</span><span class="params">(Set&lt;Tenant&gt; tenants)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.tenants = tenants;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> Integer <span class="title">getLid</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> lid;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setLid</span><span class="params">(Integer lid)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.lid = lid;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> String <span class="title">getLname</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> lname;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setLname</span><span class="params">(String lname)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.lname = lname;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> String <span class="title">getLsex</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> lsex;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setLsex</span><span class="params">(String lsex)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.lsex = lsex;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> Integer <span class="title">getLage</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> lage;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setLage</span><span class="params">(Integer lage)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.lage = lage;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> String <span class="title">getLphone</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> lphone;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setLphone</span><span class="params">(String lphone)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.lphone = lphone;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> String <span class="title">toString</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="string">"Landlord&#123;"</span> +</span><br><span class="line">                <span class="string">"lid="</span> + lid +</span><br><span class="line">                <span class="string">", lname='"</span> + lname + <span class="string">'\''</span> +</span><br><span class="line">                <span class="string">", lsex='"</span> + lsex + <span class="string">'\''</span> +</span><br><span class="line">                <span class="string">", lage="</span> + lage +</span><br><span class="line">                <span class="string">", lphone='"</span> + lphone + <span class="string">'\''</span> +</span><br><span class="line">                <span class="string">'&#125;'</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//租户 表</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Tenant</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> Integer tid;</span><br><span class="line">    <span class="keyword">private</span> String tname;</span><br><span class="line">    <span class="keyword">private</span> String tsex;</span><br><span class="line">    <span class="keyword">private</span> Integer tage;</span><br><span class="line">    <span class="keyword">private</span> String tphone;</span><br><span class="line">    <span class="keyword">private</span> String tjob; <span class="comment">// 从事的工作</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">// 一位租户只能有一个房东,建立关系</span></span><br><span class="line">    <span class="keyword">private</span> Landlord landlord;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">Tenant</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> Integer <span class="title">getTid</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> tid;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setTid</span><span class="params">(Integer tid)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.tid = tid;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> String <span class="title">getTname</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> tname;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setTname</span><span class="params">(String tname)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.tname = tname;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> String <span class="title">getTsex</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> tsex;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setTsex</span><span class="params">(String tsex)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.tsex = tsex;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> Integer <span class="title">getTage</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> tage;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setTage</span><span class="params">(Integer tage)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.tage = tage;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> String <span class="title">getTphone</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> tphone;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setTphone</span><span class="params">(String tphone)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.tphone = tphone;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> String <span class="title">getTjob</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> tjob;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setTjob</span><span class="params">(String tjob)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.tjob = tjob;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> String <span class="title">toString</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="string">"Tenant&#123;"</span> +</span><br><span class="line">                <span class="string">"tid="</span> + tid +</span><br><span class="line">                <span class="string">", tname='"</span> + tname + <span class="string">'\''</span> +</span><br><span class="line">                <span class="string">", tsex='"</span> + tsex + <span class="string">'\''</span> +</span><br><span class="line">                <span class="string">", tage="</span> + tage +</span><br><span class="line">                <span class="string">", tphone='"</span> + tphone + <span class="string">'\''</span> +</span><br><span class="line">                <span class="string">", tjob='"</span> + tjob + <span class="string">'\''</span> +</span><br><span class="line">                <span class="string">'&#125;'</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>​</p></li><li><p>第四步:在映射配置文件中配置两张表之间的关系</p></li></ul><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br></pre></td><td class="code"><pre><span class="line">&lt;?xml version="1.0" encoding="UTF-8" ?&gt;</span><br><span class="line"><span class="comment">&lt;!--指定命名空间,从hibernate-core-5.2.16.Final包中找--&gt;</span></span><br><span class="line"><span class="meta">&lt;!DOCTYPE hibernate-mapping PUBLIC</span></span><br><span class="line"><span class="meta">        "-//Hibernate/Hibernate Mapping DTD 3.0//EN"</span></span><br><span class="line"><span class="meta">        "http://www.hibernate.org/dtd/hibernate-mapping-3.0.dtd"&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">hibernate-mapping</span> <span class="attr">package</span>=<span class="string">"com.lee.one2many"</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">class</span> <span class="attr">name</span>=<span class="string">"Landlord"</span> <span class="attr">table</span>=<span class="string">"hb_landlord"</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">id</span> <span class="attr">name</span>=<span class="string">"lid"</span> <span class="attr">column</span>=<span class="string">"l_id"</span>&gt;</span></span><br><span class="line">            <span class="comment">&lt;!--主键自增长,使用数据库本地的自增长能力--&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">generator</span> <span class="attr">class</span>=<span class="string">"native"</span>&gt;</span><span class="tag">&lt;/<span class="name">generator</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;/<span class="name">id</span>&gt;</span></span><br><span class="line"></span><br><span class="line">        <span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">"lname"</span> <span class="attr">column</span>=<span class="string">"l_name"</span>&gt;</span><span class="tag">&lt;/<span class="name">property</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">"lsex"</span> <span class="attr">column</span>=<span class="string">"l_sex"</span>&gt;</span><span class="tag">&lt;/<span class="name">property</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">"lage"</span> <span class="attr">column</span>=<span class="string">"l_age"</span>&gt;</span><span class="tag">&lt;/<span class="name">property</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">"lphone"</span> <span class="attr">column</span>=<span class="string">"l_phone"</span>&gt;</span><span class="tag">&lt;/<span class="name">property</span>&gt;</span></span><br><span class="line"></span><br><span class="line">        <span class="comment">&lt;!--</span></span><br><span class="line"><span class="comment">        set:配置set集合属性</span></span><br><span class="line"><span class="comment">            name:一对多关系中,维护的"多"对应的集合set的成员属性名:private Set&lt;Tenant&gt; tenants = new HashSet&lt;&gt;(0);</span></span><br><span class="line"><span class="comment">            table:对应的从表的表名(在一对多的配置中可以不写)</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">            key:用于映射从表的外键字段</span></span><br><span class="line"><span class="comment">                column:指定从表中外键的字段名称</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">            one-to-many:从表对应的实体类</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">            其他字段:</span></span><br><span class="line"><span class="comment">                lazy:是否懒加载,true:懒加载(延迟加载)-指的是是否延迟加载关联的从表记录</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">             inverse:true,代表放弃了外键的维护权,表示它不关心外键是否正确或null(默认为false)</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">             cascade : save-update:级联保存或者更新</span></span><br><span class="line"><span class="comment">                       delete:级联删除(慎用)</span></span><br><span class="line"><span class="comment">                       cascade="save-update,delete"</span></span><br><span class="line"><span class="comment">        --&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">set</span> <span class="attr">name</span>=<span class="string">"tenants"</span> <span class="attr">table</span>=<span class="string">"hb_tenant"</span> <span class="attr">cascade</span>=<span class="string">"save-update"</span> <span class="attr">lazy</span>=<span class="string">"false"</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">key</span> <span class="attr">column</span>=<span class="string">"ten_land_fk_id"</span>&gt;</span><span class="tag">&lt;/<span class="name">key</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">one-to-many</span> <span class="attr">class</span>=<span class="string">"Tenant"</span>&gt;</span><span class="tag">&lt;/<span class="name">one-to-many</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;/<span class="name">set</span>&gt;</span></span><br><span class="line"></span><br><span class="line">        <span class="comment">&lt;!--</span></span><br><span class="line"><span class="comment">        理解 : 因为维护了多的一方的集合,肯定要知道多的一方对应的实体类(!!必须配置实体类名)</span></span><br><span class="line"><span class="comment">            : 多的一方怎么跟我建立起关系的呢?因为它引用了我的主键作为它的外键(!!必须要知道外键对应的字段)</span></span><br><span class="line"><span class="comment">           : 因为已经指定了实体类,而实体类已经通过映射配置文件为其配置了对应的表名,因此表名可有可无</span></span><br><span class="line"><span class="comment">         --&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">class</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">hibernate-mapping</span>&gt;</span></span><br></pre></td></tr></table></figure><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line">&lt;?xml version="1.0" encoding="UTF-8" ?&gt;</span><br><span class="line"><span class="comment">&lt;!--指定命名空间,从hibernate-core-5.2.16.Final包中找--&gt;</span></span><br><span class="line"><span class="meta">&lt;!DOCTYPE hibernate-mapping PUBLIC</span></span><br><span class="line"><span class="meta">        "-//Hibernate/Hibernate Mapping DTD 3.0//EN"</span></span><br><span class="line"><span class="meta">        "http://www.hibernate.org/dtd/hibernate-mapping-3.0.dtd"&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">hibernate-mapping</span> <span class="attr">package</span>=<span class="string">"com.lee.one2many"</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">class</span> <span class="attr">name</span>=<span class="string">"Tenant"</span> <span class="attr">table</span>=<span class="string">"hb_tenant"</span> <span class="attr">lazy</span>=<span class="string">"false"</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">id</span> <span class="attr">name</span>=<span class="string">"tid"</span> <span class="attr">column</span>=<span class="string">"t_id"</span>&gt;</span></span><br><span class="line">            <span class="comment">&lt;!--主键自增长,使用数据库本地的自增长能力--&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">generator</span> <span class="attr">class</span>=<span class="string">"native"</span>&gt;</span><span class="tag">&lt;/<span class="name">generator</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;/<span class="name">id</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">"tname"</span> <span class="attr">column</span>=<span class="string">"t_name"</span>&gt;</span><span class="tag">&lt;/<span class="name">property</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">"tsex"</span> <span class="attr">column</span>=<span class="string">"t_sex"</span>&gt;</span><span class="tag">&lt;/<span class="name">property</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">"tage"</span> <span class="attr">column</span>=<span class="string">"t_age"</span>&gt;</span><span class="tag">&lt;/<span class="name">property</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">"tphone"</span> <span class="attr">column</span>=<span class="string">"t_phone"</span>&gt;</span><span class="tag">&lt;/<span class="name">property</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">"tjob"</span> <span class="attr">column</span>=<span class="string">"t_job"</span>&gt;</span><span class="tag">&lt;/<span class="name">property</span>&gt;</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">        <span class="comment">&lt;!--</span></span><br><span class="line"><span class="comment">        name : 多对一中,"一"对应的属性字段</span></span><br><span class="line"><span class="comment">        class : "一"对应的实体类</span></span><br><span class="line"><span class="comment">        column : 映射的外键</span></span><br><span class="line"><span class="comment">        lazy: proxy:代理,依赖主表实体类的加载模式(在主表映射配置文件的&lt;class&gt;标签中进行配置)</span></span><br><span class="line"><span class="comment">              false:立即加载</span></span><br><span class="line"><span class="comment">              no-proxy:</span></span><br><span class="line"><span class="comment">              默认为proxy</span></span><br><span class="line"><span class="comment">        --&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">many-to-one</span> <span class="attr">name</span>=<span class="string">"landlord"</span> <span class="attr">class</span>=<span class="string">"Landlord"</span> <span class="attr">column</span>=<span class="string">"ten_land_fk_id"</span> <span class="attr">lazy</span>=<span class="string">"proxy"</span>/&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">class</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">hibernate-mapping</span>&gt;</span></span><br></pre></td></tr></table></figure><h2 id="情景二-学生和老师的信息"><a href="#情景二-学生和老师的信息" class="headerlink" title="情景二:学生和老师的信息"></a>情景二:学生和老师的信息</h2><ul><li><p>第一步:确立两张表之间的关系</p><p>一位学生可以拥有多个老师</p><p>一位老师可以拥有多个学生</p><p>所以学生表和老师表是多对多的关系</p></li><li><p>第二步:在数据库中创建出这两张表,并实现两张表之间的关系</p><p>只要配置文件中没有出错,Hibernate就会创建出正确的表来</p></li><li><p>第三步:在实体类中描述出两个实体之间的关系</p><p>互相持有对方的一个Set集合引用</p></li><li><p>第四步:在映射配置文件中配置两张表之间的关系</p><p>Student实体对应的数据库表</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">&lt;?xml version="1.0" encoding="UTF-8" ?&gt;</span><br><span class="line"><span class="comment">&lt;!--指定命名空间,从hibernate-core-5.2.16.Final包中找--&gt;</span></span><br><span class="line"><span class="meta">&lt;!DOCTYPE hibernate-mapping PUBLIC</span></span><br><span class="line"><span class="meta">        "-//Hibernate/Hibernate Mapping DTD 3.0//EN"</span></span><br><span class="line"><span class="meta">        "http://www.hibernate.org/dtd/hibernate-mapping-3.0.dtd"&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">hibernate-mapping</span> <span class="attr">package</span>=<span class="string">"com.lee.many2many"</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">class</span> <span class="attr">name</span>=<span class="string">"Student"</span> <span class="attr">table</span>=<span class="string">"hb_student"</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">id</span> <span class="attr">name</span>=<span class="string">"sid"</span> <span class="attr">column</span>=<span class="string">"s_id"</span>&gt;</span></span><br><span class="line">            <span class="comment">&lt;!--主键自增长,使用数据库本地的自增长能力--&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">generator</span> <span class="attr">class</span>=<span class="string">"native"</span>&gt;</span><span class="tag">&lt;/<span class="name">generator</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;/<span class="name">id</span>&gt;</span></span><br><span class="line"></span><br><span class="line">        <span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">"sname"</span> <span class="attr">column</span>=<span class="string">"s_name"</span>&gt;</span><span class="tag">&lt;/<span class="name">property</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">"sage"</span> <span class="attr">column</span>=<span class="string">"s_age"</span>&gt;</span><span class="tag">&lt;/<span class="name">property</span>&gt;</span></span><br></pre></td></tr></table></figure><pre><code>    &lt;!--    set:用于配置映射的集合属性    name:指定当前映射实体类中对应集合属性的属性名称    table:指定生成中间表的表名    column:当前映射文件对应实体在中间表中的联合主键字段    class:指定集合属性所装的实体类型    column:指定对方在表中对应的字段名称    --&gt;    &lt;!--注意:多对多情况下慎用级联删除,可能会出现删除不需要删除的对象--&gt;    &lt;set name=&quot;teachers&quot; table=&quot;tea_stu_ref&quot;  cascade=&quot;save-update,delete&quot;&gt;        &lt;key column=&quot;stu_id&quot;&gt;&lt;/key&gt;        &lt;many-to-many class=&quot;Teacher&quot; column=&quot;tea_id&quot;&gt;&lt;/many-to-many&gt;    &lt;/set&gt;    &lt;!--    理解 : 因为维护了多的一方的集合,肯定要知道多的一方对应的实体类(!!必须配置实体类名)        : 多的一方怎么跟我建立起关系的呢?因为它引用了我的主键作为它的外键(!!必须要知道外键对应的字段)       : 因为已经指定了实体类,而实体类已经通过映射配置文件为其配置了对应的表名,因此表名可有可无     --&gt;&lt;/class&gt;</code></pre><p></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">Teacher实体对应的数据库表</span><br><span class="line"></span><br><span class="line">```xml</span><br><span class="line">&lt;?xml version=&quot;1.0&quot; encoding=&quot;UTF-8&quot; ?&gt;</span><br><span class="line">&lt;!DOCTYPE hibernate-mapping PUBLIC</span><br><span class="line">        &quot;-//Hibernate/Hibernate Mapping DTD 3.0//EN&quot;</span><br><span class="line">        &quot;http://www.hibernate.org/dtd/hibernate-mapping-3.0.dtd&quot;&gt;</span><br><span class="line">&lt;hibernate-mapping package=&quot;com.lee.many2many&quot;&gt;</span><br><span class="line">    &lt;class name=&quot;Teacher&quot; table=&quot;hb_teacher&quot;&gt;</span><br><span class="line">        &lt;id name=&quot;tid&quot; column=&quot;t_id&quot;&gt;</span><br><span class="line">            &lt;generator class=&quot;native&quot;&gt;&lt;/generator&gt;</span><br><span class="line">        &lt;/id&gt;</span><br><span class="line"></span><br><span class="line">        &lt;property name=&quot;tname&quot; column=&quot;t_name&quot;&gt;&lt;/property&gt;</span><br><span class="line">        &lt;property name=&quot;tage&quot; column=&quot;t_sex&quot;&gt;&lt;/property&gt;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">        &lt;!--注意:多对多情况下慎用级联删除,可能会出现删除不需要删除的对象--&gt;</span><br><span class="line">        &lt;set name=&quot;students&quot; table=&quot;tea_stu_ref&quot;&gt;</span><br><span class="line">            &lt;key column=&quot;tea_id&quot;&gt;&lt;/key&gt;</span><br><span class="line">            &lt;many-to-many class=&quot;Student&quot; column=&quot;stu_id&quot;&gt;&lt;/many-to-many&gt;</span><br><span class="line">        &lt;/set&gt;</span><br><span class="line"></span><br><span class="line">        &lt;!--</span><br><span class="line">        理解 : 因为维护了多的一方的集合,肯定要知道多的一方对应的实体类(!!必须配置实体类名)</span><br><span class="line">            : 多的一方怎么跟我建立起关系的呢?因为它引用了我的主键作为它的外键(!!必须要知道外键对应的字段)</span><br><span class="line">           : 因为已经指定了实体类,而实体类已经通过映射配置文件为其配置了对应的表名,因此表名可有可无</span><br><span class="line">         --&gt;</span><br><span class="line">    &lt;/class&gt;</span><br><span class="line">&lt;/hibernate-mapping&gt;</span><br></pre></td></tr></table></figure><p>​</p></li><li><p>延迟加载思想</p></li><li><p>导航查询思想</p></li><li><p>load方法和get方法的区别,get方法立即查询.get方法取决于当前实体类映射配置文件中<code>&lt;calss&gt;</code>标签中的lazy属性,true表示延迟加载.</p></li></ul>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h1 id=&quot;Hibernate–3&quot;&gt;&lt;a href=&quot;#Hibernate–3&quot; class=&quot;headerlink&quot; title=&quot;Hibernate–3&quot;&gt;&lt;/a&gt;Hibernate–3&lt;/h1&gt;&lt;p&gt;学习大纲:&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;&lt;p&gt;数据库中表的关系&lt;/p&gt;
      
    
    </summary>
    
    
      <category term="学习日记" scheme="https://blueleer.github.io/tags/%E5%AD%A6%E4%B9%A0%E6%97%A5%E8%AE%B0/"/>
    
      <category term="错误解决" scheme="https://blueleer.github.io/tags/%E9%94%99%E8%AF%AF%E8%A7%A3%E5%86%B3/"/>
    
      <category term="Hibernate" scheme="https://blueleer.github.io/tags/Hibernate/"/>
    
  </entry>
  
  <entry>
    <title>Hibernate学习笔记2</title>
    <link href="https://blueleer.github.io/2017/04/09/Hibernate%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B02/"/>
    <id>https://blueleer.github.io/2017/04/09/Hibernate学习笔记2/</id>
    <published>2017-04-09T03:57:42.000Z</published>
    <updated>2018-04-12T11:11:55.019Z</updated>
    
    <content type="html"><![CDATA[<h1 id="Hibernate–2"><a href="#Hibernate–2" class="headerlink" title="Hibernate–2"></a>Hibernate–2</h1><p>学习内容:</p><ol><li><p>实体类的编写规范(也称作为持久化类)</p><p>实体类的编写规范</p><ul><li>类的成员变量声明为private</li></ul></li></ol><ul><li><p>有默认的无参构造方法</p></li><li><p>可生成具有唯一标志oid的实例</p></li><li><p>提供get和set方法(也可以只设置只读方法或者只写方法)</p></li><li><p>用包装型数据类型替代基本类型,比如id类型应该用Long类型替代long类型</p></li><li><p>不要用final关键字修饰(否则延迟加载机制会失效)</p><p><strong>JavaBean</strong></p><p>指的是用Java语言编写的可重用</p></li></ul><ol start="2"><li><p>hibernate中的对象标识符</p><p>Hibernate中oid的:指的是表字段中的主键,这个主键交给数据库底层或者Hibernate去生成,这样能够保证oid的一致性,同时对于持久化类,应该将id对应的set方法设置成private类型的(反射能够访问private类型的成员)</p></li><li><p>hibernate中主键的生成方式</p><ol><li>Hibernate的主键生成方式</li><li>自然主键和代理主键的区别<ul><li>自然主键:区分记录,参与业务逻辑</li><li>代理主键:区分记录,不参与业务逻辑</li></ul></li></ol></li><li><p>hibernate的一级缓存和快照机制</p><ul><li>调用Session的update(),save(),saveOrUpdate()方法时,如果Session缓存中没有相应的对象,Hibernate会自动的将刚刚添加进(更新)的数据添加到Session缓存中,以防临近时机调用不用再重复访问数据库</li><li>注意:如果设置了主键自动增长,此时再给对象设置主键字段是无效的</li><li>快照区其实相当于数据库的一部分数据的拷贝,他保存了数据库真实的数据,每次commit时,都会检查缓存和快照区的数据时候一致,如果不一致,更新数据库,同时更新快照去</li></ul></li><li><p>hibernate中的对象状态(三种状态/四种状态)</p><ul><li>瞬时状态:没有OID,没有和Session建立关系</li><li>持久状态:有OID,有缓存,并且对应的Session也没有关闭,在数据库中有对应的记录,每条记录对应一个唯一的持久态对象,注意它是在事务未提交之前形成的持久态的</li><li>脱管状态:某个持久态的实例与其相关联的Session被关闭时就形成了脱管状态,此时他就是一条独立于Hibernate的数据,它的改变与数据库没有什么关系</li></ul></li><li><p>hibernate中的事务控制</p><ol><li>解决的问题:让Session对象也符合使用原则(即一个线程只有一个Session对象)</li></ol></li><li><p>hibernate中的查询方式</p><ol><li><p>查询多条记录的方式</p></li><li><p>共5种查询方式</p></li><li><ul><li><p>OID查询</p><p>使用session的get(),load()方法进行查询</p></li><li><p>SQL查询</p><ul><li>第一种:SQLQuery方式(使用的很少)</li><li>第二种:Session通过doWork()方法,可以拿到Connection对象</li></ul></li><li><p>HQL查询(官方推荐的查询方式)</p><p>Hibernate Query Language,使用Query对象查询</p></li><li><p>QBC查询</p><p>Query By Criteria,使用Criteria对象执行查询</p></li><li><p>对象导航查询</p><p>……</p></li></ul></li></ol></li><li><p><strong>hibernate中的Query对象(重点)</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@CreateAuthor</span>: KingIsHappy</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@CreateDate</span>: 2018/4/10</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@Description</span>: 使用Session中的Query进行查询</span></span><br><span class="line"><span class="comment"> * SQL:select * from cst_customer</span></span><br><span class="line"><span class="comment"> * HQL:select * from Customer</span></span><br><span class="line"><span class="comment"> * 将SQL中的表名换成映射的实体的类名,将将查询的字段名换成实体中对应的属性名</span></span><br><span class="line"><span class="comment"> * &lt;p&gt;</span></span><br><span class="line"><span class="comment"> * 基本查询</span></span><br><span class="line"><span class="comment"> * 条件查询</span></span><br><span class="line"><span class="comment"> * 分页查询</span></span><br><span class="line"><span class="comment"> * 排序查询</span></span><br><span class="line"><span class="comment"> * 统计查询</span></span><br><span class="line"><span class="comment"> * 投影查询</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Demo2</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/*</span></span><br><span class="line"><span class="comment">    基本查询</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="meta">@Test</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">test1</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        Session session = HibernateUtils.openSession();</span><br><span class="line">        Transaction transaction = session.beginTransaction();</span><br><span class="line"><span class="comment">//        Query query = session.createQuery("from Customer"); // 查询Customer实体对应的表中的所有的数据</span></span><br><span class="line">        Query query1 = session.createQuery(<span class="string">"select cname,cage from Customer"</span>); <span class="comment">// 查询两个指定字段</span></span><br><span class="line"></span><br><span class="line">        List&lt;Object[]&gt; list = query1.getResultList();</span><br><span class="line">        <span class="keyword">for</span> (Object[] ol : list) &#123;</span><br><span class="line">            <span class="keyword">for</span> (Object o : ol) &#123;</span><br><span class="line">                System.out.println(o);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        transaction.commit();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 条件查询</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="meta">@Test</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">test2</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        Session session = HibernateUtils.openSession();</span><br><span class="line">        Transaction ts = session.beginTransaction();</span><br><span class="line">        Query query = session.createQuery(<span class="string">"from Customer where cname = ?"</span>);</span><br><span class="line">        query.setParameter(<span class="number">0</span>, <span class="string">"马云"</span>); <span class="comment">// 从0开始(0代表第一个替换位置)</span></span><br><span class="line"></span><br><span class="line"><span class="comment">//        Query query = session.createQuery("from Customer where cname like ?");</span></span><br><span class="line"><span class="comment">//        query.setString(0,"%马%");</span></span><br><span class="line"></span><br><span class="line">        <span class="comment">// 在HQL中将参数设置别名,然后再给参数赋值</span></span><br><span class="line"><span class="comment">//        Query query = session.createQuery("from Customer where cname like :likename");</span></span><br><span class="line"><span class="comment">//        query.setString("likename", "%马%");</span></span><br><span class="line">        List&lt;Customer&gt; list = query.list();</span><br><span class="line">        <span class="keyword">for</span> (Customer c : list) &#123;</span><br><span class="line">            System.out.println(c);</span><br><span class="line">        &#125;</span><br><span class="line">        ts.commit();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 分页查询</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line"></span><br><span class="line">    <span class="meta">@Test</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">test3</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        Session session = HibernateUtils.openSession();</span><br><span class="line">        Transaction transaction = session.beginTransaction();</span><br><span class="line">        Query query = session.createQuery(<span class="string">"select cid,cname from Customer "</span>);</span><br><span class="line">        query.setFirstResult(<span class="number">5</span>);<span class="comment">// 从索引为5的位置开始查</span></span><br><span class="line">        <span class="comment">// 假如数据库中有1000条记录,你以此想把这1000条记录查出来,设置了setFetchSize(100)</span></span><br><span class="line">        <span class="comment">// 数据库每次回返回100条记录,当你需要下面的100条记录的时候,数据库才会加载下面的100条记录</span></span><br><span class="line"><span class="comment">//        query.setFetchSize(2);</span></span><br><span class="line">        query.setMaxResults(<span class="number">2</span>);<span class="comment">// 每次查询返回的条数</span></span><br><span class="line">        List&lt;Object[]&gt; list = query.getResultList();</span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span> (Object[] ol : list) &#123;</span><br><span class="line">            <span class="keyword">for</span> (Object o : ol) &#123;</span><br><span class="line">                System.out.println(o);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        transaction.commit();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 排序查询</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="meta">@Test</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">test4</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        Session session = HibernateUtils.openSession();</span><br><span class="line">        Transaction transaction = session.beginTransaction();</span><br><span class="line">        Query query = session.createQuery(<span class="string">"from Customer order by cid desc "</span>);</span><br><span class="line"></span><br><span class="line">        List&lt;Customer&gt; list = query.list();</span><br><span class="line">        <span class="keyword">for</span> (Customer c : list) &#123;</span><br><span class="line">            System.out.println(c);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        transaction.commit();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 统计查询</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line"></span><br><span class="line">    <span class="meta">@Test</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">test5</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        Session session = HibernateUtils.openSession();</span><br><span class="line">        Transaction transaction = session.beginTransaction();</span><br><span class="line"><span class="comment">//        Query query = session.createQuery("select count (*) from Customer ");</span></span><br><span class="line">        Query query = session.createQuery(<span class="string">"select avg (cage) from Customer "</span>);</span><br><span class="line">        <span class="comment">// getSingleResult()只能接收一个结果,当结果超过1一个时就会报错</span></span><br><span class="line">        Object result = query.getSingleResult();</span><br><span class="line">        Object o = query.uniqueResult();<span class="comment">// 效果和getSingleResult一样</span></span><br><span class="line">        System.out.println(result);</span><br><span class="line"></span><br><span class="line">        transaction.commit();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 投影查询</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line"></span><br><span class="line">    <span class="meta">@Test</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">test6</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        Session session = HibernateUtils.openSession();</span><br><span class="line">        Transaction transaction = session.beginTransaction();</span><br><span class="line">        <span class="comment">// 给HQL传参的时候,创建一个新的对象,指定要查询的字段的名称,执行查询以后,默认返回一个封装好了的实体</span></span><br><span class="line">        Query query = session.createQuery(<span class="string">"select new Customer (cname,cage) from Customer where cid = ?"</span>);</span><br><span class="line">        query.setParameter(<span class="number">0</span>, <span class="number">1L</span>);</span><br><span class="line">        Object result = query.getSingleResult();</span><br><span class="line">        System.out.println(result);</span><br><span class="line">        transaction.commit();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>​</p></li><li><p>hibernate中的Criteria(标准、准则)对象</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br><span class="line">144</span><br><span class="line">145</span><br><span class="line">146</span><br><span class="line">147</span><br><span class="line">148</span><br><span class="line">149</span><br><span class="line">150</span><br><span class="line">151</span><br><span class="line">152</span><br><span class="line">153</span><br><span class="line">154</span><br><span class="line">155</span><br><span class="line">156</span><br><span class="line">157</span><br><span class="line">158</span><br><span class="line">159</span><br><span class="line">160</span><br><span class="line">161</span><br><span class="line">162</span><br><span class="line">163</span><br><span class="line">164</span><br><span class="line">165</span><br><span class="line">166</span><br><span class="line">167</span><br><span class="line">168</span><br><span class="line">169</span><br><span class="line">170</span><br><span class="line">171</span><br><span class="line">172</span><br><span class="line">173</span><br><span class="line">174</span><br><span class="line">175</span><br><span class="line">176</span><br><span class="line">177</span><br><span class="line">178</span><br><span class="line">179</span><br><span class="line">180</span><br><span class="line">181</span><br><span class="line">182</span><br><span class="line">183</span><br><span class="line">184</span><br><span class="line">185</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@CreateAuthor</span>: KingIsHappy</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@CreateDate</span>: 2018/4/10</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@Description</span>: 使用Session创建的Criteria进行查询(QBC查询)</span></span><br><span class="line"><span class="comment"> * Criteria是一个完全面向对象,可扩展的条件查询API,他完全不用考虑数据库底层是如何实现,以及SQL如何编写</span></span><br><span class="line"><span class="comment"> * &lt;p&gt;</span></span><br><span class="line"><span class="comment"> * 基本查询</span></span><br><span class="line"><span class="comment"> * 条件查询</span></span><br><span class="line"><span class="comment"> * 分页查询</span></span><br><span class="line"><span class="comment"> * 排序查询</span></span><br><span class="line"><span class="comment"> * 统计查询</span></span><br><span class="line"><span class="comment"> * 离线查询(不依赖Session产生一个DetachedCriteria对象(new得到),然后设置查询参数及条件)</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Demo3</span> </span>&#123;</span><br><span class="line">    <span class="comment">//    * 基本查询(查询所有)</span></span><br><span class="line">    <span class="meta">@Test</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">test1</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        Session session = HibernateUtils.openSession();</span><br><span class="line">        Transaction transaction = session.beginTransaction();</span><br><span class="line">        <span class="comment">// 查询所有</span></span><br><span class="line">        Criteria criteria = session.createCriteria(Customer.class);</span><br><span class="line">        List&lt;Customer&gt; list = criteria.list();</span><br><span class="line">        <span class="keyword">for</span> (Customer c : list) &#123;</span><br><span class="line">            System.out.println(c);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        transaction.commit();</span><br><span class="line">        session.close();</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 基本查询(session的createCriteria()方法已经过时的解决办法),官方建议使用Query,这相当于一个折中的方案,CriteriaQuery可以向Criteria一样</span></span><br><span class="line"><span class="comment">     * 不用关心SQL怎么写,它可以像Criteria一样进行设置查询条件</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="meta">@Test</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">test11</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        Session session = HibernateUtils.openSession();</span><br><span class="line">        Transaction transaction = session.beginTransaction();</span><br><span class="line">        <span class="comment">// 查询所有</span></span><br><span class="line">        CriteriaQuery&lt;Customer&gt; cquery = session.getCriteriaBuilder().createQuery(Customer.class);</span><br><span class="line">        cquery.from(Customer.class);</span><br><span class="line">        cquery.where();</span><br><span class="line"><span class="comment">//        cquery.where();</span></span><br><span class="line">        Query&lt;Customer&gt; query = session.createQuery(cquery);</span><br><span class="line">        List&lt;Customer&gt; list = query.list();</span><br><span class="line">        <span class="keyword">for</span> (Customer c : list) &#123;</span><br><span class="line">            System.out.println(c);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        transaction.commit();</span><br><span class="line">        session.close();</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//    * 条件查询</span></span><br><span class="line">    <span class="meta">@Test</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">test2</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        Session session = HibernateUtils.openSession();</span><br><span class="line">        Transaction transaction = session.beginTransaction();</span><br><span class="line">        Criteria criteria = session.createCriteria(Customer.class);</span><br><span class="line">        criteria.add(Restrictions.eq(<span class="string">"cname"</span>, <span class="string">"马云"</span>));</span><br><span class="line">        List&lt;Customer&gt; list = criteria.list();</span><br><span class="line">        <span class="keyword">for</span> (Customer c : list) &#123;</span><br><span class="line">            System.out.println(c);</span><br><span class="line">        &#125;</span><br><span class="line">        transaction.commit();</span><br><span class="line">        session.close();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//    * 分页查询</span></span><br><span class="line">    <span class="meta">@Test</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">test3</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        Session session = HibernateUtils.openSession();</span><br><span class="line">        Transaction transaction = session.beginTransaction();</span><br><span class="line">        Criteria criteria = session.createCriteria(Customer.class);</span><br><span class="line">        criteria.setFirstResult(<span class="number">0</span>);</span><br><span class="line">        criteria.setMaxResults(<span class="number">5</span>);</span><br><span class="line">        List&lt;Customer&gt; list = criteria.list();</span><br><span class="line">        <span class="keyword">for</span> (Customer c : list) &#123;</span><br><span class="line">            System.out.println(c);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        transaction.commit();</span><br><span class="line">        session.close();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//    * 排序查询</span></span><br><span class="line">    <span class="meta">@Test</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">test4</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        Session session = HibernateUtils.openSession();</span><br><span class="line">        Transaction transaction = session.beginTransaction();</span><br><span class="line">        Criteria criteria = session.createCriteria(Customer.class);</span><br><span class="line">        criteria.addOrder(Order.desc(<span class="string">"cid"</span>)); <span class="comment">// 降序查询</span></span><br><span class="line">        List&lt;Customer&gt; list = criteria.list();</span><br><span class="line">        <span class="keyword">for</span> (Customer c : list) &#123;</span><br><span class="line">            System.out.println(c);</span><br><span class="line">        &#125;</span><br><span class="line">        transaction.commit();</span><br><span class="line">        session.close();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//    * 统计查询(投影查询)</span></span><br><span class="line">    <span class="meta">@Test</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">test5</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        Session session = HibernateUtils.openSession();</span><br><span class="line">        Transaction transaction = session.beginTransaction();</span><br><span class="line">        Criteria criteria = session.createCriteria(Customer.class);</span><br><span class="line">        <span class="comment">// 使用投影查询指定条目的个数</span></span><br><span class="line">        criteria.setProjection(Projections.count(<span class="string">"cname"</span>));</span><br><span class="line">        Object o = criteria.uniqueResult();</span><br><span class="line">        System.out.println(o);</span><br><span class="line">        transaction.commit();</span><br><span class="line">        session.close();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 使用投影查询,查询指定的列</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="meta">@Test</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">test55</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        Session session = HibernateUtils.openSession();</span><br><span class="line">        Transaction transaction = session.beginTransaction();</span><br><span class="line">        Criteria criteria = session.createCriteria(Customer.class);</span><br><span class="line">        criteria.setProjection(Projections.property(<span class="string">"cname"</span>));</span><br><span class="line"></span><br><span class="line">        List list = criteria.list();</span><br><span class="line">        <span class="keyword">for</span> (Object o : list) &#123;</span><br><span class="line">            System.out.println(o);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        transaction.commit();</span><br><span class="line">        session.close();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//    * 离线查询</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 思路:在表现层封装一个DetachedCriteria,将要封装的查询数据到其中</span></span><br><span class="line"><span class="comment">     * 传递给服务层,服务层再传递给DAO层,DAO层将DetachedCriteria激活,编程Criteria对象,然后执行查询</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="meta">@Test</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">test6</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        List list = testServlet();</span><br><span class="line">        <span class="keyword">for</span> (Object o : list) &#123;</span><br><span class="line">            System.out.println(o);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 模拟Servlet</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> List <span class="title">testServlet</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        DetachedCriteria detachedCriteria = DetachedCriteria.forClass(Customer.class);</span><br><span class="line">        detachedCriteria.add(Restrictions.eq(<span class="string">"cname"</span>, <span class="string">"马云"</span>));</span><br><span class="line">        List list = <span class="keyword">null</span>;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            list = testService(detachedCriteria);</span><br><span class="line">        &#125; <span class="keyword">catch</span> (Exception e) &#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> list;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 模拟Service</span></span><br><span class="line">    <span class="comment">// 在服务中开启事务,事务的处理在业务层</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> List <span class="title">testService</span><span class="params">(DetachedCriteria detachedCriteria)</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">        Session session = HibernateUtils.getCurrentSession();</span><br><span class="line">        Transaction transaction = <span class="keyword">null</span>;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            transaction = session.beginTransaction();</span><br><span class="line">            List list = testDao(detachedCriteria);</span><br><span class="line">            transaction.commit();</span><br><span class="line">            <span class="keyword">return</span> list;</span><br><span class="line">        &#125; <span class="keyword">catch</span> (HibernateException e) &#123;</span><br><span class="line">            transaction.rollback();</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> Exception(e);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 模拟DAO</span></span><br><span class="line">    <span class="function"><span class="keyword">private</span> List <span class="title">testDao</span><span class="params">(DetachedCriteria detachedCriteria)</span> </span>&#123;</span><br><span class="line">        Session session = HibernateUtils.getCurrentSession();</span><br><span class="line">        Criteria executableCriteria = detachedCriteria.getExecutableCriteria(session);</span><br><span class="line">        <span class="keyword">return</span> executableCriteria.list();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>​</p><p>​</p><p>​</p><p>​</p><p>​</p></li></ol>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h1 id=&quot;Hibernate–2&quot;&gt;&lt;a href=&quot;#Hibernate–2&quot; class=&quot;headerlink&quot; title=&quot;Hibernate–2&quot;&gt;&lt;/a&gt;Hibernate–2&lt;/h1&gt;&lt;p&gt;学习内容:&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;&lt;p&gt;实体类的编写规范(也称作
      
    
    </summary>
    
    
      <category term="学习日记" scheme="https://blueleer.github.io/tags/%E5%AD%A6%E4%B9%A0%E6%97%A5%E8%AE%B0/"/>
    
      <category term="错误解决" scheme="https://blueleer.github.io/tags/%E9%94%99%E8%AF%AF%E8%A7%A3%E5%86%B3/"/>
    
      <category term="Hibernate" scheme="https://blueleer.github.io/tags/Hibernate/"/>
    
  </entry>
  
  <entry>
    <title>Hibernate学习笔记1</title>
    <link href="https://blueleer.github.io/2017/04/08/Hibernate%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B01/"/>
    <id>https://blueleer.github.io/2017/04/08/Hibernate学习笔记1/</id>
    <published>2017-04-08T15:57:47.000Z</published>
    <updated>2018-04-12T16:30:53.473Z</updated>
    
    <content type="html"><![CDATA[<h1 id="Hibernate–1"><a href="#Hibernate–1" class="headerlink" title="Hibernate–1"></a>Hibernate–1</h1><p>学习内容:</p><ol><li><p>Hibernate相关jar包的依赖</p></li><li><p>创建表和实体之间的映射配置文件<code>Student.hbm.xml</code></p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">&lt;?xml version="1.0" encoding="UTF-8" ?&gt;</span><br><span class="line"><span class="comment">&lt;!--指定命名空间,从hibernate-core-5.2.16.Final包中找--&gt;</span></span><br><span class="line"><span class="meta">&lt;!DOCTYPE hibernate-mapping PUBLIC</span></span><br><span class="line"><span class="meta">        "-//Hibernate/Hibernate Mapping DTD 3.0//EN"</span></span><br><span class="line"><span class="meta">        "http://www.hibernate.org/dtd/hibernate-mapping-3.0.dtd"&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">hibernate-mapping</span> <span class="attr">package</span>=<span class="string">"com.lee.hibernate1.domain"</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">class</span> <span class="attr">name</span>=<span class="string">"Student"</span> <span class="attr">table</span>=<span class="string">"student"</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">id</span> <span class="attr">name</span>=<span class="string">"sid"</span> <span class="attr">column</span>=<span class="string">"sid"</span>&gt;</span></span><br><span class="line">            <span class="comment">&lt;!--主键自增长,使用数据库本地的自增长能力--&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">generator</span> <span class="attr">class</span>=<span class="string">"native"</span>&gt;</span><span class="tag">&lt;/<span class="name">generator</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;/<span class="name">id</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">"name"</span> <span class="attr">column</span>=<span class="string">"sname"</span>&gt;</span><span class="tag">&lt;/<span class="name">property</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">"sex"</span> <span class="attr">column</span>=<span class="string">"ssex"</span>&gt;</span><span class="tag">&lt;/<span class="name">property</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">"age"</span> <span class="attr">column</span>=<span class="string">"sage"</span>&gt;</span><span class="tag">&lt;/<span class="name">property</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">"address"</span> <span class="attr">column</span>=<span class="string">"saddress"</span>&gt;</span><span class="tag">&lt;/<span class="name">property</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">class</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">hibernate-mapping</span>&gt;</span></span><br></pre></td></tr></table></figure><p>​</p></li><li><p>创建<code>hibernate.cfg.xml</code>配置文件</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br></pre></td><td class="code"><pre><span class="line">&lt;?xml version="1.0" encoding="UTF-8" ?&gt;</span><br><span class="line"><span class="comment">&lt;!--导入约束文件文件 ,从从hibernate-core-5.2.16.Final包中找到--&gt;</span></span><br><span class="line"><span class="meta">&lt;!DOCTYPE hibernate-configuration PUBLIC</span></span><br><span class="line"><span class="meta">        "-//Hibernate/Hibernate Configuration DTD 3.0//EN"</span></span><br><span class="line"><span class="meta">        "http://www.hibernate.org/dtd/hibernate-configuration-3.0.dtd"&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">hibernate-configuration</span>&gt;</span></span><br><span class="line">    <span class="comment">&lt;!--配置SessionFactory,它是数据库连接的会话对象,它是执行CRUD的对象--&gt;</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">&lt;!--创建SessionFactory对象的三部分必须配置:</span></span><br><span class="line"><span class="comment">    1.第一部分:</span></span><br><span class="line"><span class="comment">        连接数据库的信息</span></span><br><span class="line"><span class="comment">    2.第二部分</span></span><br><span class="line"><span class="comment">        hibernate的可选配置</span></span><br><span class="line"><span class="comment">    3.第三部分</span></span><br><span class="line"><span class="comment">        映射配置文件的位置</span></span><br><span class="line"><span class="comment">    --&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">session-factory</span>&gt;</span></span><br><span class="line">        <span class="comment">&lt;!--第一部分--&gt;</span></span><br><span class="line">        <span class="comment">&lt;!--JDBC驱动--&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">"hibernate.connection.driver_class"</span>&gt;</span>com.mysql.jdbc.Driver<span class="tag">&lt;/<span class="name">property</span>&gt;</span></span><br><span class="line">        <span class="comment">&lt;!--连接数据库的url--&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">"hibernate.connection.url"</span>&gt;</span>jdbc:mysql://localhost:3306/hibernate<span class="tag">&lt;/<span class="name">property</span>&gt;</span></span><br><span class="line">        <span class="comment">&lt;!--数据库的用户名--&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">"hibernate.connection.username"</span>&gt;</span>root<span class="tag">&lt;/<span class="name">property</span>&gt;</span></span><br><span class="line">        <span class="comment">&lt;!--登录数据库的密码--&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">"hibernate.connection.password"</span>&gt;</span>123<span class="tag">&lt;/<span class="name">property</span>&gt;</span></span><br><span class="line">        <span class="comment">&lt;!--#hibernate.dialect org.hibernate.dialect.MySQLDialect--&gt;</span></span><br><span class="line">        <span class="comment">&lt;!--&amp;lt;!&amp;ndash;配置数据库方言&amp;ndash;&amp;gt;--&gt;</span></span><br><span class="line">        <span class="comment">&lt;!--&lt;property name="hibernate.dialect"&gt;org.hibernate.dialect.MySQL55Dialect&lt;/property&gt;--&gt;</span></span><br><span class="line"></span><br><span class="line">        <span class="comment">&lt;!--第二部分--&gt;</span></span><br><span class="line">        <span class="comment">&lt;!--是否在控制台显示生成的sql语句--&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">"hibernate.show_sql"</span>&gt;</span>true<span class="tag">&lt;/<span class="name">property</span>&gt;</span></span><br><span class="line">        <span class="comment">&lt;!--是否将控制台里的sql语句格式化输出--&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">"hibernate.format_sql"</span>&gt;</span>true<span class="tag">&lt;/<span class="name">property</span>&gt;</span></span><br><span class="line">        <span class="comment">&lt;!--采用何种方式生成DDL语句--&gt;</span></span><br><span class="line">        <span class="comment">&lt;!--其中update表示:检测实体类和表结构是否一致,如果不一致,更新表结构达到一致,如果不存在该表,就创建一张表--&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">"hibernate.hbm2ddl.auto"</span>&gt;</span>update<span class="tag">&lt;/<span class="name">property</span>&gt;</span></span><br><span class="line"></span><br><span class="line">        <span class="comment">&lt;!--第三部分--&gt;</span></span><br><span class="line">        <span class="comment">&lt;!--指定映射的bean配置文件的位置--&gt;</span></span><br><span class="line">        <span class="comment">&lt;!--如果有多个,就配置多个--&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">mapping</span> <span class="attr">resource</span>=<span class="string">"com/lee/hibernate1/Student.hbm.xml"</span>/&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">session-factory</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">hibernate-configuration</span>&gt;</span></span><br></pre></td></tr></table></figure><p>​</p></li><li><p>使用hibernate向数据库中插入数据的小练习</p></li></ol><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">test1</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        Student student = <span class="keyword">new</span> Student();</span><br><span class="line">        student.setName(<span class="string">"Lee"</span>);</span><br><span class="line">        student.setAddress(<span class="string">"安康市"</span>);</span><br><span class="line">        student.setSex(<span class="string">"男"</span>);</span><br><span class="line"></span><br><span class="line"><span class="comment">//        1. 解析主配置文件</span></span><br><span class="line">        Configuration configuration = <span class="keyword">new</span> Configuration();</span><br><span class="line">        configuration.configure(); <span class="comment">// 配置默认的配置文件,即为根目录下的hibernate.cfg.xml文件</span></span><br><span class="line"><span class="comment">//        2.根据主配置文件,创建SessionFaction对象</span></span><br><span class="line">        SessionFactory factory = configuration.buildSessionFactory();</span><br><span class="line"><span class="comment">//        3.创建Session</span></span><br><span class="line">        Session session = factory.openSession();</span><br><span class="line"><span class="comment">//        4.开启事务</span></span><br><span class="line">        Transaction transaction = session.beginTransaction();</span><br><span class="line"><span class="comment">//        5.执行插入</span></span><br><span class="line">        session.save(student);</span><br><span class="line"><span class="comment">//        6.提交事务</span></span><br><span class="line">        transaction.commit();</span><br><span class="line"><span class="comment">//        7.释放资源</span></span><br><span class="line">        session.close();</span><br><span class="line">        factory.close();</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure><h2 id="Configuration"><a href="#Configuration" class="headerlink" title="Configuration"></a>Configuration</h2><p>配置配置文件</p><p>一般在hibernate.cfg.xml中配置的东西,在该对象中都是可以配置的,但是不推荐这么做,硬编码,后期维护升级很费事</p><h2 id="SessionFactory"><a href="#SessionFactory" class="headerlink" title="SessionFactory"></a>SessionFactory</h2><ul><li>该对象在服务器启动(应用启动)的时候创建,在服务器关闭(应用卸载)的时候销毁,一个应用只存在一个实例</li><li>它是线程安全的</li><li>在创建SessionFactory以后对配置文件进行更改,将不会影响到该factory</li></ul><h2 id="Session"><a href="#Session" class="headerlink" title="Session"></a>Session</h2><ul><li>一个线程只有一个对象</li></ul><h2 id="Transaction"><a href="#Transaction" class="headerlink" title="Transaction"></a>Transaction</h2><h3 id="Hibernate工具类"><a href="#Hibernate工具类" class="headerlink" title="Hibernate工具类"></a>Hibernate工具类</h3><h3 id="Hibernate中CRUD操作"><a href="#Hibernate中CRUD操作" class="headerlink" title="Hibernate中CRUD操作"></a>Hibernate中CRUD操作</h3><h2 id="Hibernate中的异常处理"><a href="#Hibernate中的异常处理" class="headerlink" title="Hibernate中的异常处理"></a>Hibernate中的异常处理</h2><p>HibernateException继承了RuntimeException,这个异常可以不用捕获</p><h1 id="Hibernate中配置c3p0连接池"><a href="#Hibernate中配置c3p0连接池" class="headerlink" title="Hibernate中配置c3p0连接池"></a>Hibernate中配置c3p0连接池</h1><p>F:\java资料\SSH框架\hibernate-release-5.2.16.Final\project\etc/hibernate.properties文件中查找配置格式(搜索c3p0)</p><h3 id="Hibernate中查询的get和load方法的区别"><a href="#Hibernate中查询的get和load方法的区别" class="headerlink" title="Hibernate中查询的get和load方法的区别"></a>Hibernate中查询的get和load方法的区别</h3><p><em>查询时机不同,返回查询的结果不一样</em></p><ul><li>get:立即加载</li><li>load:延迟加载(懒加载,惰性加载),返回的对象是增强对象(动态代理),增强了toString()方法;他也可以通过配置的方式改为立即加载</li></ul><p>学习中遇到的问题及其结局方案:</p><h3 id="使用的MySQL版本为5-5-使用Hibernate的版本为5-2-16-在配置hibernate-cfg-xml的时候"><a href="#使用的MySQL版本为5-5-使用Hibernate的版本为5-2-16-在配置hibernate-cfg-xml的时候" class="headerlink" title="使用的MySQL版本为5.5,使用Hibernate的版本为5.2.16,在配置hibernate.cfg.xml的时候"></a>使用的MySQL版本为5.5,使用Hibernate的版本为5.2.16,在配置<code>hibernate.cfg.xml</code>的时候</h3><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">&lt;!--配置数据库方言--&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">"hibernate.dialect"</span>&gt;</span>org.hibernate.dialect.MySQL5Dialect<span class="tag">&lt;/<span class="name">property</span>&gt;</span></span><br></pre></td></tr></table></figure><p>在MySQL版本为<code>5.5</code>及以上时,如果配置数据库方言,将<code>org.hibernate.dialect.MySQLDialect</code>改为上面的</p><p><code>org.hibernate.dialect.MySQL5Dialect</code> 不然在hibernate创建表格的时候会报错.</p><p>或者这个配置项直接不配置也是可以的</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h1 id=&quot;Hibernate–1&quot;&gt;&lt;a href=&quot;#Hibernate–1&quot; class=&quot;headerlink&quot; title=&quot;Hibernate–1&quot;&gt;&lt;/a&gt;Hibernate–1&lt;/h1&gt;&lt;p&gt;学习内容:&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;&lt;p&gt;Hibernate相关j
      
    
    </summary>
    
    
      <category term="学习日记" scheme="https://blueleer.github.io/tags/%E5%AD%A6%E4%B9%A0%E6%97%A5%E8%AE%B0/"/>
    
      <category term="错误解决" scheme="https://blueleer.github.io/tags/%E9%94%99%E8%AF%AF%E8%A7%A3%E5%86%B3/"/>
    
      <category term="Hibernate" scheme="https://blueleer.github.io/tags/Hibernate/"/>
    
  </entry>
  
  <entry>
    <title>Java中的Pattern、Matcher、常用的正则表达式</title>
    <link href="https://blueleer.github.io/2017/04/06/Java%E4%B8%AD%E7%9A%84Pattern%E3%80%81Matcher%E3%80%81%E5%B8%B8%E7%94%A8%E7%9A%84%E6%AD%A3%E5%88%99%E8%A1%A8%E8%BE%BE%E5%BC%8F/"/>
    <id>https://blueleer.github.io/2017/04/06/Java中的Pattern、Matcher、常用的正则表达式/</id>
    <published>2017-04-06T08:20:55.000Z</published>
    <updated>2018-04-13T12:10:31.304Z</updated>
    
    <content type="html"><![CDATA[<h1 id="Java中的Pattern、Matcher、常用的正则表达式"><a href="#Java中的Pattern、Matcher、常用的正则表达式" class="headerlink" title="Java中的Pattern、Matcher、常用的正则表达式"></a>Java中的Pattern、Matcher、常用的正则表达式</h1><p><strong>Java中的字符串已经有了直接调用简单匹配方法,matches方法(内部也是使用了Pattern.matches()方法)</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">String s = <span class="string">"Java12Java34"</span>;</span><br><span class="line"><span class="comment">// 精确匹配,返回regex和s串是否完全匹配</span></span><br><span class="line"><span class="keyword">boolean</span> isMatch = s.matches(<span class="string">"Java"</span>); <span class="comment">// 这里返回false</span></span><br><span class="line"><span class="comment">// 在一定的范围内进行匹配</span></span><br><span class="line"><span class="comment">// 参数的含义: 是否忽略大小写,s串的起始位置(offset),regex字符串,regex字符串的起始位置,取regex串的长度</span></span><br><span class="line"><span class="keyword">boolean</span> isMatch2 = s.regionMatches(<span class="keyword">true</span>, <span class="number">6</span>, <span class="string">"Java"</span>, <span class="number">0</span>, <span class="string">"Java"</span>.length()); <span class="comment">// 返回true</span></span><br></pre></td></tr></table></figure><p>但是很多时候String自带的这些方法不足于我们使用,此时Java中提供了Pattern和Matcher两个与正则表达式相关的类供我们使用</p><h2 id="Pattern类"><a href="#Pattern类" class="headerlink" title="Pattern类"></a>Pattern类</h2><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">String regex = <span class="string">"Java"</span>;</span><br><span class="line">Pattern pattern = Pattern.compile(regex);</span><br></pre></td></tr></table></figure><h3 id="Pattern-matches-静态方法"><a href="#Pattern-matches-静态方法" class="headerlink" title="Pattern.matches()静态方法"></a>Pattern.matches()静态方法</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">String regex = <span class="string">"Java"</span>;</span><br><span class="line">String s2 = <span class="string">"Java123Java456Java789"</span>;</span><br><span class="line">Pattern.matches(<span class="string">"Java"</span>, s2); <span class="comment">// 注意这里也是全串精确匹配</span></span><br></pre></td></tr></table></figure><p>其实这个方法和String中的matches()方法一致,其实String.matches()方法内部就是调用了此方法</p><h3 id="split"><a href="#split" class="headerlink" title="split"></a>split</h3><p>顾名思义就是分割字符串的方法,其中regex就是分割字符串的”刀”,注意当regex和字符串开始或者结尾部分匹配的时候会得到空字符串</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">String regex = <span class="string">"Java"</span>;</span><br><span class="line">String s2 = <span class="string">"Java123Java456Java789"</span>;</span><br><span class="line">Pattern pattern = Pattern.compile(<span class="string">"Java"</span>);</span><br><span class="line"></span><br><span class="line"><span class="comment">// split(input),分割字符串得到String数组</span></span><br><span class="line">String[] split = pattern.split(s2);</span><br><span class="line">System.out.println(split.length); <span class="comment">// 输出3,[空串,123,456,789]</span></span><br><span class="line"></span><br><span class="line">String[] split1 = pattern.split(regex, <span class="number">2</span>);</span><br><span class="line">System.out.println(<span class="string">"split1的长度为 : "</span> + split1.length); <span class="comment">// 输出2,[空串,123Java456Java789],想想limit设置成3会怎样?</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 注意:limit设置成0或者负数,效果默认一样,也就是和pattern.split(s2)一样</span></span><br></pre></td></tr></table></figure><p>关于Pattern只介绍这两个方法,其他的可以自行创建demo试试</p><h2 id="Matcher类"><a href="#Matcher类" class="headerlink" title="Matcher类"></a>Matcher类</h2><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">String regex = <span class="string">"Java"</span>;</span><br><span class="line">String s = <span class="string">"Java123Java456Java789"</span>;</span><br><span class="line">Pattern pattern = Pattern.compile(regex);</span><br><span class="line">Matcher matcher1 = pattern.matcher(s);</span><br></pre></td></tr></table></figure><ul><li>find()：尝试查找与该模式匹配的输入序列的的下一个子序列。重要,下面重点说</li><li>find(int start)：重置此匹配器，然后尝试查找匹配该模式、从指定索引开始的输入序列的下一个子序列。</li><li>group()：匹配成功返回的组,重要,下面重点说</li><li>start()：返回先前匹配的起始位置的索引。</li><li>end()：返回最后匹配字符的索引加一。</li><li>matches()：尝试将整个区域与模式匹配。匹配成功返回true</li><li>lookingAt()：尝试将从区域开头开始的输入序列与该模式匹配。</li><li>replaceFirst()：替换掉匹配的第一个子序列</li><li>replaceAll()：替换掉匹配的全部子序列</li><li>appendReplacement：重要，下面重点说</li><li>appendTail(StringBuffer buf)：重要，下面重点说</li><li>reset():重置匹配器,从起始位置重新开始</li><li>reset(CharSequence input):重置匹配器,放入新的待匹配的串</li></ul><p><strong>部分方法解析</strong></p><ol><li><p><strong>find()方法</strong></p><p>注意:该方法尝试查找与该模式匹配的输入序列的下一个子序列.此方法从匹配器区域的开头开始，如果该方法的前一次调用成功了,并且从那时开始匹配器没有被重置，则从以前匹配操作没有匹配的第一个字符开始</p></li></ol><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">String regex = <span class="string">"Java."</span>;</span><br><span class="line">String s = <span class="string">"Java1Java2"</span>;</span><br><span class="line">Pattern pattern = Pattern.compile(regex);</span><br><span class="line">Matcher matcher1 = pattern.matcher(s);</span><br><span class="line">matcher1.find(); <span class="comment">// 这里返回true</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 其实此时我们可以使用下面的方式来循环获取匹配得到的子串</span></span><br><span class="line"><span class="keyword">while</span>(matcher.find)&#123; <span class="comment">// 循环查找,本次查找结束了,下次如果想获得查找结果应该重新执行find()方法</span></span><br><span class="line">    System.out.println(matcher.group()); <span class="comment">// 关于group方法将在下面介绍</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 上面的方法输出:</span></span><br><span class="line">Java1</span><br><span class="line">Java2</span><br></pre></td></tr></table></figure><ol start="2"><li><p><strong>group()方法</strong></p><p><em>这里介绍下组的概念：组是用括号划分的正则表达式，可以根据组的编号来引用这个组。组号为0表示整个表达式，组号为1表示被第一对括号括起的组，依次类推，例如A(B(C))D，组0是ABCD，组1是BC，组2是C。</em></p><p><em>Matcher类提供了start()，end()，group()分别用于返回字符串的起始索引，结束索引，以及匹配到到的字符串。</em></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">String regex = <span class="string">"(Java).*(Java)"</span>;</span><br><span class="line">String s = <span class="string">"Java123Java456"</span>;</span><br><span class="line">Pattern pattern = Pattern.compile(regex);</span><br><span class="line">Matcher matcher2 = pattern.matcher(s);</span><br><span class="line">matcher2.find(); <span class="comment">// 注意,这里需要先执行find方法</span></span><br><span class="line">System.out.println(matcher2.group()); <span class="comment">// 如果find()方法执行返回true,则group()或者group(0)代表整个字符串s:Java123Java456</span></span><br><span class="line">System.out.println(matcher2.group(<span class="number">1</span>)); <span class="comment">// 输出 Java123</span></span><br><span class="line">System.out.println(matcher2.group(<span class="number">2</span>)); <span class="comment">// 输出Java456</span></span><br></pre></td></tr></table></figure></li><li><p>appendReplacement(StringBuffer sb,String replacement)方法</p><p>先从字符串中执行查找,查找到了,替换成replacement,并从开始匹配的位置处将字符串写入StringBuffer中,示例入下:</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line">String s = <span class="string">"2018-4-10 15-45-30"</span>;</span><br><span class="line">String regex = <span class="string">"-"</span>;</span><br><span class="line">Pattern pattern = Pattern.compile(regex);</span><br><span class="line">Matcher matcher = pattern.matcher(s);</span><br><span class="line">StringBuffer sb = <span class="keyword">new</span> StringBuffer();</span><br><span class="line">matcher.find();</span><br><span class="line">matcher.appendReplacement(sb, <span class="string">":"</span>);</span><br><span class="line">System.out.println(sb.toString());</span><br><span class="line">matcher.find();</span><br><span class="line">matcher.appendReplacement(sb, <span class="string">":"</span>);</span><br><span class="line">System.out.println(sb.toString());</span><br><span class="line">matcher.find();</span><br><span class="line">matcher.appendReplacement(sb, <span class="string">":"</span>);</span><br><span class="line">System.out.println(sb.toString());</span><br><span class="line"></span><br><span class="line">输出入下:</span><br><span class="line"><span class="number">2018</span>:</span><br><span class="line"><span class="number">2018</span>:<span class="number">4</span>:</span><br><span class="line"><span class="number">2018</span>:<span class="number">4</span>:<span class="number">10</span> <span class="number">15</span>:</span><br></pre></td></tr></table></figure><p>可以看到,它比String的replaceAll()或者replace()方法更加灵活</p><h2 id="正则表达式语法"><a href="#正则表达式语法" class="headerlink" title="正则表达式语法"></a>正则表达式语法</h2><p>请参考 <a href="http://www.runoob.com/java/java-regular-expressions.html" target="_blank" rel="noopener">Java 正则表达式</a></p></li></ol>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h1 id=&quot;Java中的Pattern、Matcher、常用的正则表达式&quot;&gt;&lt;a href=&quot;#Java中的Pattern、Matcher、常用的正则表达式&quot; class=&quot;headerlink&quot; title=&quot;Java中的Pattern、Matcher、常用的正则表达式&quot;&gt;
      
    
    </summary>
    
      <category term="Java" scheme="https://blueleer.github.io/categories/Java/"/>
    
    
      <category term="Java" scheme="https://blueleer.github.io/tags/Java/"/>
    
      <category term="Java正则表达式" scheme="https://blueleer.github.io/tags/Java%E6%AD%A3%E5%88%99%E8%A1%A8%E8%BE%BE%E5%BC%8F/"/>
    
  </entry>
  
  <entry>
    <title>基于JDBC的Spring中数据库事务的相关操作</title>
    <link href="https://blueleer.github.io/2017/04/06/Spring%E4%B8%AD%E6%95%B0%E6%8D%AE%E5%BA%93%E7%9A%84%E7%9B%B8%E5%85%B3%E6%93%8D%E4%BD%9C/"/>
    <id>https://blueleer.github.io/2017/04/06/Spring中数据库的相关操作/</id>
    <published>2017-04-06T08:20:55.000Z</published>
    <updated>2018-04-26T14:11:26.489Z</updated>
    
    <content type="html"><![CDATA[<h1 id="数据库事务的四大特性-ACID"><a href="#数据库事务的四大特性-ACID" class="headerlink" title="数据库事务的四大特性(ACID)"></a>数据库事务的四大特性(ACID)</h1><ol><li><strong>原子性（Atomicity）</strong>事务是一个原子操作，由一系列动作组成。事务的原子性确保动作要么全部完成，要么完全不起作用。</li><li><strong>一致性（Consistency）</strong>事务在完成时，必须是所有的数据都保持一致状态。</li><li><strong>隔离性（Isolation）</strong>并发事务执行之间无影响，在一个事务内部的操作对其他事务是不产生影响，这需要事务隔离级别来指定隔离性。</li><li><strong>持久性（Durability）</strong>一旦事务完成，数据库的改变必须是持久化的。</li></ol><h1 id="并发访问数据库导致的问题"><a href="#并发访问数据库导致的问题" class="headerlink" title="并发访问数据库导致的问题"></a>并发访问数据库导致的问题</h1><p>在企业级应用中，多用户访问数据库是常见的场景，这就是所谓的事务的并发。事务并发所可能存在的问题：</p><ol><li><strong>脏读</strong>：一个事务读到另一个事务未提交的更新数据。 </li><li><strong>不可重复读</strong>：一个事务两次读同一行数据，可是这两次读到的数据不一样。 </li><li><strong>幻读</strong>：一个事务执行两次查询，但第二次查询比第一次查询多出了一些数据行。 </li><li><strong>丢失更新</strong>：撤消一个事务时，把其它事务已提交的更新的数据覆盖了。</li></ol><h1 id="应对并发访问导致问题的举措"><a href="#应对并发访问导致问题的举措" class="headerlink" title="应对并发访问导致问题的举措"></a>应对并发访问导致问题的举措</h1><p>上述四种并发访问数据库导致的问题是并发情况下难免会发生的,但是又是不得不解决的问题。在JDBC中，数据库事务有四大隔离级别：</p><ul><li><strong>SERIALIZABLE（串行化）</strong> <ul><li>不会出现任何并发问题，因为它是对同一数据的访问是串行的，非并发访问的；</li><li>性能最差；</li></ul></li></ul><ul><li><strong>REPEATABLE READ （可重复读）（MySQL）</strong><ul><li>防止脏读和不可重复读，不能处理幻读问题；</li><li>性能比SERIALIZABLE好</li></ul></li><li><strong>READ COMMITTED （读已提交数据）（Oracle）</strong><ul><li>防止脏读，没有处理不可重复读，也没有处理幻读；</li><li>性能比REPEATABLE READ好</li></ul></li><li><strong>READ UNCOMMITTED （读未提交数据）</strong><ul><li>可能出现任何事务并发问题</li><li>性能最好</li></ul></li></ul><p>理解：例如当数据库事务的隔离级别是<code>读已提交</code>,那么当前事务对数据进行了更改,只要是该事务还没有提交,那么其他事务对数据的更改是看不见的.</p><h1 id="Spring中对事务的处理"><a href="#Spring中对事务的处理" class="headerlink" title="Spring中对事务的处理"></a>Spring中对事务的处理</h1><p>Spring事务管理高层抽象主要包括3个接口：</p><ul><li><p>PlatformTransactionManager 事务管理器</p><p>我们常常使用的DataSourceTransactionManager就是它的一个间接子类</p></li><li><p>TransactionDefinition 事务定义信息（隔离、传播、超时、只读）</p><p>主要定义了它自己的传播行为和隔离级别</p></li><li><p>TransactionStatus 事务具体运行状态</p><p>主要方法：</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">void flush();               //如果适用的话，这个方法用于刷新底层会话中的修改到数据库，例如，所有受影响的Hibernate/JPA会话。</span><br><span class="line">boolean hasSavepoint();     // 是否有恢复点</span><br><span class="line">boolean isCompleted();      // 是否已完成</span><br><span class="line">boolean isNewTransaction(); // 是否是新的事务</span><br><span class="line">boolean isRollbackOnly();   // 是否为只回滚</span><br><span class="line">void setRollbackOnly();     // 设置为只回滚</span><br></pre></td></tr></table></figure></li></ul><h2 id="声明式事务管理"><a href="#声明式事务管理" class="headerlink" title="声明式事务管理"></a>声明式事务管理</h2><p><strong>声明式事务管理是非侵入式的</strong></p><h3 id="xml方式配置"><a href="#xml方式配置" class="headerlink" title="xml方式配置"></a>xml方式配置</h3><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;/<span class="name">beans</span>&gt;</span> </span><br><span class="line">......</span><br><span class="line"><span class="comment">&lt;!--配置事务--&gt;</span></span><br><span class="line">    <span class="comment">&lt;!--第一步:配置事务管理器--&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">bean</span> <span class="attr">id</span>=<span class="string">"transactionManager"</span> <span class="attr">class</span>=<span class="string">"org.springframework.jdbc.datasource.DataSourceTransactionManager"</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">"dataSource"</span> <span class="attr">ref</span>=<span class="string">"jdbcDatasource"</span>/&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">bean</span>&gt;</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">&lt;!--第二步:配置事务增强--&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">tx:advice</span> <span class="attr">id</span>=<span class="string">"advice"</span> <span class="attr">transaction-manager</span>=<span class="string">"transactionManager"</span>&gt;</span></span><br><span class="line">        <span class="comment">&lt;!--做事务操作--&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">tx:attributes</span>&gt;</span></span><br><span class="line">            <span class="comment">&lt;!--设置事务操作的方法匹配规则--&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">tx:method</span> <span class="attr">name</span>=<span class="string">"add*"</span>/&gt;</span></span><br><span class="line">        <span class="tag">&lt;/<span class="name">tx:attributes</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">tx:advice</span>&gt;</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">&lt;!--第三步:配置切面--&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">aop:config</span>&gt;</span></span><br><span class="line">        <span class="comment">&lt;!--com.lee.JDBCTransaction包下的所有的类中的方法都会和事务增强中设置的匹配规则进行匹配--&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">aop:pointcut</span> <span class="attr">id</span>=<span class="string">"tx_pt"</span> <span class="attr">expression</span>=<span class="string">"execution(* com.lee.JDBCTransaction.*.*(..))"</span>/&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">aop:advisor</span> <span class="attr">advice-ref</span>=<span class="string">"advice"</span> <span class="attr">pointcut-ref</span>=<span class="string">"tx_pt"</span>/&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">aop:config</span>&gt;</span></span><br><span class="line">......</span><br><span class="line"><span class="tag">&lt;/<span class="name">beans</span>&gt;</span></span><br></pre></td></tr></table></figure><h3 id="基于注解的配置方式"><a href="#基于注解的配置方式" class="headerlink" title="基于注解的配置方式"></a>基于注解的配置方式</h3><p>基于注解的方式简单好理解,是常用的方式</p><p>在xml配置文件中:</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">beans</span>&gt;</span></span><br><span class="line"><span class="comment">&lt;!--基于注解配置事务--&gt;</span></span><br><span class="line">    <span class="comment">&lt;!--配置事务管理器--&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">bean</span> <span class="attr">id</span>=<span class="string">"transactionManager"</span> <span class="attr">class</span>=<span class="string">"org.springframework.jdbc.datasource.DataSourceTransactionManager"</span>&gt;</span></span><br><span class="line">        <span class="comment">&lt;!--配置数据源--&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">"dataSource"</span> <span class="attr">ref</span>=<span class="string">"jdbcDatasource"</span>/&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">bean</span>&gt;</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">&lt;!--开启对注解事务管理器的支持--&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">tx:annotation-driven</span> <span class="attr">transaction-manager</span>=<span class="string">"transactionManager"</span>/&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="tag">&lt;/<span class="name">beans</span>&gt;</span></span><br></pre></td></tr></table></figure><p>然后在业务层中开启事务</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">UserServiceImpl2</span> <span class="keyword">implements</span> <span class="title">UserService</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> UserDao mUserDao;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 模拟逻辑,向数据库中插入条相同的记录,并在第二条记录上打上"--copy"的标记</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="meta">@Transactional</span> <span class="comment">// 开启事务</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">addTwoSimpleUser</span><span class="params">(User user)</span> </span>&#123;</span><br><span class="line">        mUserDao.add(user);</span><br><span class="line"></span><br><span class="line">        user.setUsername(user.getUsername() + <span class="string">"--copy"</span>);</span><br><span class="line">        <span class="keyword">int</span> error = <span class="number">2</span> / <span class="number">0</span>;</span><br><span class="line">        mUserDao.add(user);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><code>@Transactional</code>可以标记在方法上,当标记在方法上的时候,代表此方法作为一个事务的原子操作,该方法中的内容是事务中事务体.</p><p><code>@Transactional</code>也可以标记在类上,当标记在类上面的时候,代表此类中的所有方法都开启了事务.</p><h2 id="编程式事务管理"><a href="#编程式事务管理" class="headerlink" title="编程式事务管理"></a>编程式事务管理</h2><p><strong>编程式事务管理是侵入性的,用的不多</strong></p><p>请参考 <a href="https://blog.csdn.net/donggua3694857/article/details/69858827" target="_blank" rel="noopener">Spring事务管理详解</a></p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h1 id=&quot;数据库事务的四大特性-ACID&quot;&gt;&lt;a href=&quot;#数据库事务的四大特性-ACID&quot; class=&quot;headerlink&quot; title=&quot;数据库事务的四大特性(ACID)&quot;&gt;&lt;/a&gt;数据库事务的四大特性(ACID)&lt;/h1&gt;&lt;ol&gt;
&lt;li&gt;&lt;strong&gt;原子
      
    
    </summary>
    
      <category term="Spring" scheme="https://blueleer.github.io/categories/Spring/"/>
    
    
      <category term="数据库" scheme="https://blueleer.github.io/tags/%E6%95%B0%E6%8D%AE%E5%BA%93/"/>
    
      <category term="Spring" scheme="https://blueleer.github.io/tags/Spring/"/>
    
  </entry>
  
  <entry>
    <title>Git版本控制工具的简单使用</title>
    <link href="https://blueleer.github.io/2016/11/07/Git%E7%89%88%E6%9C%AC%E6%8E%A7%E5%88%B6%E5%B7%A5%E5%85%B7%E7%9A%84%E7%AE%80%E5%8D%95%E4%BD%BF%E7%94%A8/"/>
    <id>https://blueleer.github.io/2016/11/07/Git版本控制工具的简单使用/</id>
    <published>2016-11-07T14:08:04.000Z</published>
    <updated>2018-04-27T16:03:18.846Z</updated>
    
    <content type="html"><![CDATA[<p><em>虽然在Windows系统上安装的<strong>Git</strong>是可以在图形界面上进行操作的,但是我们并不应该这么做,<strong>Git</strong>的各种命令才是我们应该掌握的,而且将来我们不管换成什么样的操作系统,使用<strong>Git</strong>命令来操作都是通用的</em></p><h3 id="1-创建代码仓库"><a href="#1-创建代码仓库" class="headerlink" title="1. 创建代码仓库"></a>1. 创建代码仓库</h3><p>初次打开Bash的时候我们应该配置身份</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">git confing --global user.name "yourname"</span><br><span class="line">git confing --global user.email "your email address"</span><br></pre></td></tr></table></figure><p>然后切换到你要上传到github的项目的根目录下,例如下面这个项目:</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">cd f:</span><br><span class="line">cd android/BroadcastTest/</span><br></pre></td></tr></table></figure><p>然后输入下面的命令:</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">git init</span><br></pre></td></tr></table></figure><p>这样会在BroadcastTest目录下生成一个 .git 文件夹</p><h3 id="2-提交本地代码"><a href="#2-提交本地代码" class="headerlink" title="2. 提交本地代码"></a>2. 提交本地代码</h3><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">git add AndroidManifest.xml   # 将AndroidManifest.xml文件添加进本地仓库</span><br><span class="line">git add src # 将src目录添加进本地仓库</span><br><span class="line">git add . # 添加所有的文件到本地仓库</span><br></pre></td></tr></table></figure><p>上面的添加只是将文件/文件夹添加到本地仓库,并没有提交:</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">git commit -m "first commit" # 其中"first commit"是本次提交的描述,建议加上此次提交的描述,将来我们可以很方便的看到提交了什么</span><br></pre></td></tr></table></figure><h3 id="3-忽略文件"><a href="#3-忽略文件" class="headerlink" title="3. 忽略文件"></a>3. 忽略文件</h3><p><em>我们提交的时候,并不是该项目下所有的文件都得提交,例如 .idea 文件夹是不需要提交的,它是IDE自动生成的,那么怎么忽略掉这些文件呢?</em></p><p><strong>第一步: 在BroadcastTest目录下创建 .gitignore文件</strong></p><p><em>注意可能你在创建该文件的时候提示你”必须键入文件名,解决方法是:</em></p><ol><li><em>在项目根目录下面创建gitignore.txt文件</em></li><li><em>把你需要排除的文件名保存到gitignore.txt文件</em></li><li><em>在项目根目录下面按住Shift键并鼠标右键选择“在此处打开命令窗口”</em></li><li><em>执行命令 <code>ren gitignore.txt .gitignore</code></em></li></ol><p><strong>第二步:编辑.gitignore文件,将你想要忽略提交的文件或者文件夹加入</strong></p><p>例如:</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">bin/</span><br><span class="line">gen/</span><br><span class="line">*.html # 忽略所有的html文件,其中 "*" 为通配符,表示任意多个字符, "?" 代表一个字符, 方括号 [abc]代表可选字符范围</span><br></pre></td></tr></table></figure><p>编辑好上面的.gitignore文件以后,执行 <code>git add .</code>就会自动将匹配上的文件或者文件夹忽略,然后执行</p><p><code>git commit -m &quot;Second commit with ignore&quot;</code> 大功告成!</p><h3 id="4-查看修改内容"><a href="#4-查看修改内容" class="headerlink" title="4. 查看修改内容"></a>4. 查看修改内容</h3><p>在项目的开发阶段我们经常提交代码到仓库,理想的情况是每当完成了一小块功能的时候,就执行一次提交.当某个功能修改比较多的时候,写到后面可能我们已经忘记了本次到底修改了什么内容了,此时Git在帮你记着.</p><p><code>git status</code>    查看本次更改的概况</p><p><code>git diff   src/lee/com/broadcasttest/Main.java</code>     查看某个文件具体修改的内容,其中,减号代表删除的内容,加号代表添加的内容</p><h3 id="5-撤销未提交的修改"><a href="#5-撤销未提交的修改" class="headerlink" title="5. 撤销未提交的修改"></a>5. 撤销未提交的修改</h3><p>每次完成一个功能以后,都会先执行 <code>add</code>命令添加进本地仓库</p><p>本次代码修改以后,只要未提交(也就是未执行<code>add</code>命令),都可以运行</p><p><code>git checkout src/lee/com/broadcasttest/Main.java</code> 来撤销更改</p><p>上面的命令只能针对那些没有执行过<code>add</code>命令的文件有效,当某个文件已经<code>add</code>过了,此时需要先对其进行取消添加</p><p><code>git  reset HEAD src/lee/com/broadcast/Main.java</code>,然后在执行上面的</p><p><code>git checkout src/lee/com/broadcasttest/Main.java</code>命令</p><h3 id="6-查看提交记录"><a href="#6-查看提交记录" class="headerlink" title="6. 查看提交记录"></a>6. 查看提交记录</h3><p><code>git log</code></p><p>当我们的提交较多的时候,可以指定该记录的id:</p><p><code>git log 提交记录的id -1</code>(注意这里要添加上-1)</p><p>在命令中添加<code>-p</code>参数,查看该条记录具体修改的内容:</p><p><code>git log 提交记录的id -1 -p</code></p><h3 id="7-分支的用法"><a href="#7-分支的用法" class="headerlink" title="7. 分支的用法"></a>7. 分支的用法</h3><p><code>git branch -a</code>  查看当前的版本库中有哪些分支,版本库创建的时候默认只有一个分支 <strong>master</strong></p><p><code>git branch version1.0</code>  创建一个名为 <strong>version1.0</strong>  的分支,虽然此时创建了一个新的分支version1.0,但是当前你所在的分支依然是master,使用下面的命令进行切花分支</p><p><code>git checkout version1.0</code> 切换到<strong>version1.0</strong>的分支上</p><p><strong>当你想把version1.0分支上所做的修改合并到master分支上,使用下面的命令进行</strong></p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">git checkout master   # 先切换到master分支上</span><br><span class="line">git merge version1.0  # 合并merge分支上的修改到master分支上,此时version1.0分支上的代码不会受到影响</span><br><span class="line"># 另外,合并分支的时候可能会出现代码冲突的情况,此时应该慢慢查找那些冲突的代码,git  无力帮助我们</span><br></pre></td></tr></table></figure><p><code>git branch -D version1.0</code>  删除version1.0的分支</p><h3 id="8-与远程版本库协作"><a href="#8-与远程版本库协作" class="headerlink" title="8. 与远程版本库协作"></a>8. 与远程版本库协作</h3><p><strong>上面的操作都是在本地完成的,只适合个人作为项目版本的控制方法</strong></p><p>所有的版本控制工具最重要的一个特点就是可以使用它来进行团队合作开发,每个人的电脑上都会有一份代码,当团队的某个成员在自己的电脑上编写完成了某个功能后,就将代码提交到服务器,其他的成员只需要将服务器上的代码同步到本地,就能保证整个团队所有人的代码都相同.这样的话,每个成员就可以各司其职,完成每个人负责的模块,这样就可以共同完成一个庞大的项目.</p><p>现在,项目负责人在Git上创建了一个项目,项目地址为:<a href="https://github.com/BlueLeer/Crawler" target="_blank" rel="noopener">https://github.com/BlueLeer/Crawler</a></p><p><strong>将代码下载到本地</strong>:</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">git clone https://github.com/BlueLeer/Crawler.git</span><br></pre></td></tr></table></figure><p><strong>之后,当你在这份代码的基础上完成了一些修改,使用下面的命令将本地修改的内容同步到版本库:</strong></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">git push origin master  # 注意:该命令应该在上面本地代码根目录上执行,origin指的是远程Git地址,master指的是master分支,当然也可以是其他的分支</span><br></pre></td></tr></table></figure><p>团队的其他成员对Git版本库中的代码也进行了修改,我们应该要养成经常从版本库中获取最新代码的习惯,那么怎么讲远程版本库中的修改同步到本地呢?使用下面的命令:</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">git fetch origin master </span><br><span class="line"># fetch意为获取之意,但是注意:同步下来的代码并不会合并到本地的任何分支上,而是会存放在一个 origin/master</span><br><span class="line"># 分支上,此时可以先调用 git diff origin/master 查看远程版本库中到底修改了什么内容</span><br></pre></td></tr></table></figure><p>之后调用 <code>merge</code>命令将<code>origin/master</code>分支上的修改合并到本地的master分支上即可:</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">git merge origin/master</span><br></pre></td></tr></table></figure><p>推荐使用上面的方法,当然下面的方法更简单,一步到位,那就是<code>pull</code>命令了,它其实相当于将<code>fetch</code>和<code>merge</code>两个命令放在一起执行了,它从远程的版本苦衷获取罪行的代码并合并到本地:</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">git pull origin master</span><br></pre></td></tr></table></figure><h3 id="9-上传本地项目到代码仓库"><a href="#9-上传本地项目到代码仓库" class="headerlink" title="9.上传本地项目到代码仓库"></a>9.上传本地项目到代码仓库</h3><p>步骤:</p><ol><li>在待上传的项目根目录下执行(会生成一个.git目录):<code>git init</code></li><li>添加文件到本地仓库:<code>git add .</code></li><li>提交到本地仓库:<code>git commit -m &quot;提交到本地仓库&quot;</code></li><li>建立和远程仓库的联系:<code>git remote add origin git@github.com:BlueLeer/SSHMerge.git</code></li><li>关键的一步,将远程仓库最新的文件pull到本地,并和本地的合并,普通的合并是<code>git pull origin master</code>,但是,注意啦,这里的拉取合并指令为<strong>:<code>git pull --rebase origin master</code></strong></li><li>上传:<code>git push origin master</code></li></ol><p>参考:<a href="https://www.cnblogs.com/specter45/p/github.html" target="_blank" rel="noopener">github入门到上传本地项目</a></p><p>注意:此博客中操作步骤可能会导致问题</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;&lt;em&gt;虽然在Windows系统上安装的&lt;strong&gt;Git&lt;/strong&gt;是可以在图形界面上进行操作的,但是我们并不应该这么做,&lt;strong&gt;Git&lt;/strong&gt;的各种命令才是我们应该掌握的,而且将来我们不管换成什么样的操作系统,使用&lt;strong&gt;Git&lt;/s
      
    
    </summary>
    
      <category term="其他" scheme="https://blueleer.github.io/categories/%E5%85%B6%E4%BB%96/"/>
    
    
      <category term="GitHub" scheme="https://blueleer.github.io/tags/GitHub/"/>
    
  </entry>
  
  <entry>
    <title>在活动中使用菜单Menu和PopupMenu</title>
    <link href="https://blueleer.github.io/2016/11/01/%E5%9C%A8%E6%B4%BB%E5%8A%A8%E4%B8%AD%E4%BD%BF%E7%94%A8%E8%8F%9C%E5%8D%95Menu%E5%92%8CPopupMenu/"/>
    <id>https://blueleer.github.io/2016/11/01/在活动中使用菜单Menu和PopupMenu/</id>
    <published>2016-11-01T15:55:32.000Z</published>
    <updated>2018-04-06T16:05:39.468Z</updated>
    
    <content type="html"><![CDATA[<h3 id="在Activity中使用Menu和PopupMenu"><a href="#在Activity中使用Menu和PopupMenu" class="headerlink" title="在Activity中使用Menu和PopupMenu"></a>在Activity中使用Menu和PopupMenu</h3><p>流程:</p><ol><li>点击<strong>res</strong>目录新建<strong>Android resouce file</strong>文件,选择<strong>resoucetype</strong>为<strong>menu</strong>,然后可以创建如下菜单的布局:</li></ol><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">&lt;?xml version="1.0" encoding="utf-8"?&gt;</span><br><span class="line"><span class="tag">&lt;<span class="name">menu</span> <span class="attr">xmlns:android</span>=<span class="string">"http://schemas.android.com/apk/res/android"</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">item</span></span></span><br><span class="line"><span class="tag">        <span class="attr">android:id</span>=<span class="string">"@+id/refresh_item"</span></span></span><br><span class="line"><span class="tag">        <span class="attr">android:title</span>=<span class="string">"刷新"</span>/&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">item</span> <span class="attr">android:id</span>=<span class="string">"@+id/change_city"</span></span></span><br><span class="line"><span class="tag">        <span class="attr">android:title</span>=<span class="string">"选择城市"</span>/&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">menu</span>&gt;</span></span><br></pre></td></tr></table></figure><ol start="2"><li><p>然后在活动中重写<strong>onCreateOptionsMenu(Menu menu)</strong>方法:</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">onCreateOptionsMenu</span><span class="params">(Menu menu)</span> </span>&#123;</span><br><span class="line">    <span class="comment">//R.menu.menu就是menu的布局文件</span></span><br><span class="line">    getMenuInflater().inflate(R.menu.menu,menu);</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>​</p></li><li><p>然后在手机上点击”菜单”就可以弹出菜单了,该菜单是从屏幕底部弹出的.</p></li></ol><p>当然我们也可以为点击菜单上的项目注册响应事件,通过重写<strong>onOptionsItemSelected()</strong>方法:</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">onOptionsItemSelected</span><span class="params">(MenuItem item)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">switch</span>(item.getItemId())&#123;</span><br><span class="line">        <span class="keyword">case</span> R.id.refresh_item:</span><br><span class="line">            <span class="comment">//加入逻辑</span></span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">        <span class="keyword">case</span>  R.id.change_city:</span><br><span class="line">            <span class="comment">//加入逻辑</span></span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">super</span>.onOptionsItemSelected(item);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ol start="4"><li><p>有时候我们希望通过点击屏幕上自己定义的一个组件弹出一个菜单来,并且这个菜单就在这个组件的周围,那么可以这么来写(还是使用刚刚我们定义的<strong>menu</strong>布局文件):</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">Button button = (Button)findViewById(R.id.refresh);</span><br><span class="line"><span class="comment">//点击这个按钮就能弹出一个菜单来</span></span><br><span class="line">button.setOnClickListener(<span class="keyword">new</span> View.OnClickListener()&#123;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">onClick</span><span class="params">(View view)</span> </span>&#123;</span><br><span class="line">        PopupMenu popupMenu = <span class="keyword">new</span> PopupMenu(MainActivity.<span class="keyword">this</span>,view);</span><br><span class="line">        popupMenu.getMenuInflater().inflate(R.menu.menu,popupMenu.getMenu());</span><br><span class="line">        popupMenu.show();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure><p>​</p></li></ol><p>​     在刷新按钮的周围弹出了一个菜单</p><p><img src="1.jpg" alt="弹出popupMenu"></p><p>​     当然我们也可以为PopupMenu响应点击事件:</p><pre><code><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">popupMenu.setOnMenuItemClickListener(<span class="keyword">new</span> PopupMenu.OnMenuItemClickListener()  &#123;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">onMenuItemClick</span><span class="params">(MenuItem menuItem)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">switch</span>(menuItem.getId())&#123;</span><br><span class="line">            <span class="keyword">case</span> R.id.refresh_item</span><br><span class="line">                <span class="comment">//加入自己的逻辑(点击以后发生的事件)</span></span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure></code></pre>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h3 id=&quot;在Activity中使用Menu和PopupMenu&quot;&gt;&lt;a href=&quot;#在Activity中使用Menu和PopupMenu&quot; class=&quot;headerlink&quot; title=&quot;在Activity中使用Menu和PopupMenu&quot;&gt;&lt;/a&gt;在Activit
      
    
    </summary>
    
      <category term="Android" scheme="https://blueleer.github.io/categories/Android/"/>
    
    
      <category term="Android" scheme="https://blueleer.github.io/tags/Android/"/>
    
  </entry>
  
</feed>
