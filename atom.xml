<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>Coding...Coding...</title>
  <icon>https://www.gravatar.com/avatar/186e8a9967ddc3f700ba1e47b6be9b34</icon>
  <subtitle>个人博客</subtitle>
  <link href="/atom.xml" rel="self"/>
  
  <link href="https://blueleer.github.io/"/>
  <updated>2018-04-09T03:31:39.630Z</updated>
  <id>https://blueleer.github.io/</id>
  
  <author>
    <name>KingIsHappy</name>
    <email>251668577@qq.com</email>
  </author>
  
  <generator uri="http://hexo.io/">Hexo</generator>
  
  <entry>
    <title>Hibernate学习笔记</title>
    <link href="https://blueleer.github.io/2018/04/08/Hibernate%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/"/>
    <id>https://blueleer.github.io/2018/04/08/Hibernate学习笔记/</id>
    <published>2018-04-08T15:57:47.000Z</published>
    <updated>2018-04-09T03:31:39.630Z</updated>
    
    <content type="html"><![CDATA[<h1 id="Hibernate"><a href="#Hibernate" class="headerlink" title="Hibernate"></a>Hibernate</h1><p>学习内容:</p><ol><li><p>Hibernate相关jar包的依赖</p></li><li><p>创建表和实体之间的映射配置文件<code>Student.hbm.xml</code></p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">&lt;?xml version="1.0" encoding="UTF-8" ?&gt;</span><br><span class="line"><span class="comment">&lt;!--指定命名空间,从hibernate-core-5.2.16.Final包中找--&gt;</span></span><br><span class="line"><span class="meta">&lt;!DOCTYPE hibernate-mapping PUBLIC</span></span><br><span class="line"><span class="meta">        "-//Hibernate/Hibernate Mapping DTD 3.0//EN"</span></span><br><span class="line"><span class="meta">        "http://www.hibernate.org/dtd/hibernate-mapping-3.0.dtd"&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">hibernate-mapping</span> <span class="attr">package</span>=<span class="string">"com.lee.hibernate1.domain"</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">class</span> <span class="attr">name</span>=<span class="string">"Student"</span> <span class="attr">table</span>=<span class="string">"student"</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">id</span> <span class="attr">name</span>=<span class="string">"sid"</span> <span class="attr">column</span>=<span class="string">"sid"</span>&gt;</span></span><br><span class="line">            <span class="comment">&lt;!--主键自增长,使用数据库本地的自增长能力--&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">generator</span> <span class="attr">class</span>=<span class="string">"native"</span>&gt;</span><span class="tag">&lt;/<span class="name">generator</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;/<span class="name">id</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">"name"</span> <span class="attr">column</span>=<span class="string">"sname"</span>&gt;</span><span class="tag">&lt;/<span class="name">property</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">"sex"</span> <span class="attr">column</span>=<span class="string">"ssex"</span>&gt;</span><span class="tag">&lt;/<span class="name">property</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">"age"</span> <span class="attr">column</span>=<span class="string">"sage"</span>&gt;</span><span class="tag">&lt;/<span class="name">property</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">"address"</span> <span class="attr">column</span>=<span class="string">"saddress"</span>&gt;</span><span class="tag">&lt;/<span class="name">property</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">class</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">hibernate-mapping</span>&gt;</span></span><br></pre></td></tr></table></figure><p>​</p></li><li><p>创建<code>hibernate.cfg.xml</code>配置文件</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br></pre></td><td class="code"><pre><span class="line">&lt;?xml version="1.0" encoding="UTF-8" ?&gt;</span><br><span class="line"><span class="comment">&lt;!--导入约束文件文件 ,从从hibernate-core-5.2.16.Final包中找到--&gt;</span></span><br><span class="line"><span class="meta">&lt;!DOCTYPE hibernate-configuration PUBLIC</span></span><br><span class="line"><span class="meta">        "-//Hibernate/Hibernate Configuration DTD 3.0//EN"</span></span><br><span class="line"><span class="meta">        "http://www.hibernate.org/dtd/hibernate-configuration-3.0.dtd"&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">hibernate-configuration</span>&gt;</span></span><br><span class="line">    <span class="comment">&lt;!--配置SessionFactory,它是数据库连接的会话对象,它是执行CRUD的对象--&gt;</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">&lt;!--创建SessionFactory对象的三部分必须配置:</span></span><br><span class="line"><span class="comment">    1.第一部分:</span></span><br><span class="line"><span class="comment">        连接数据库的信息</span></span><br><span class="line"><span class="comment">    2.第二部分</span></span><br><span class="line"><span class="comment">        hibernate的可选配置</span></span><br><span class="line"><span class="comment">    3.第三部分</span></span><br><span class="line"><span class="comment">        映射配置文件的位置</span></span><br><span class="line"><span class="comment">    --&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">session-factory</span>&gt;</span></span><br><span class="line">        <span class="comment">&lt;!--第一部分--&gt;</span></span><br><span class="line">        <span class="comment">&lt;!--JDBC驱动--&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">"hibernate.connection.driver_class"</span>&gt;</span>com.mysql.jdbc.Driver<span class="tag">&lt;/<span class="name">property</span>&gt;</span></span><br><span class="line">        <span class="comment">&lt;!--连接数据库的url--&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">"hibernate.connection.url"</span>&gt;</span>jdbc:mysql://localhost:3306/hibernate<span class="tag">&lt;/<span class="name">property</span>&gt;</span></span><br><span class="line">        <span class="comment">&lt;!--数据库的用户名--&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">"hibernate.connection.username"</span>&gt;</span>root<span class="tag">&lt;/<span class="name">property</span>&gt;</span></span><br><span class="line">        <span class="comment">&lt;!--登录数据库的密码--&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">"hibernate.connection.password"</span>&gt;</span>123<span class="tag">&lt;/<span class="name">property</span>&gt;</span></span><br><span class="line">        <span class="comment">&lt;!--#hibernate.dialect org.hibernate.dialect.MySQLDialect--&gt;</span></span><br><span class="line">        <span class="comment">&lt;!--&amp;lt;!&amp;ndash;配置数据库方言&amp;ndash;&amp;gt;--&gt;</span></span><br><span class="line">        <span class="comment">&lt;!--&lt;property name="hibernate.dialect"&gt;org.hibernate.dialect.MySQL5Dialect&lt;/property&gt;--&gt;</span></span><br><span class="line"></span><br><span class="line">        <span class="comment">&lt;!--第二部分--&gt;</span></span><br><span class="line">        <span class="comment">&lt;!--是否在控制台显示生成的sql语句--&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">"hibernate.show_sql"</span>&gt;</span>true<span class="tag">&lt;/<span class="name">property</span>&gt;</span></span><br><span class="line">        <span class="comment">&lt;!--是否将控制台里的sql语句格式化输出--&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">"hibernate.format_sql"</span>&gt;</span>true<span class="tag">&lt;/<span class="name">property</span>&gt;</span></span><br><span class="line">        <span class="comment">&lt;!--采用何种方式生成DDL语句--&gt;</span></span><br><span class="line">        <span class="comment">&lt;!--其中update表示:检测实体类和表结构是否一致,如果不一致,更新表结构达到一致,如果不存在该表,就创建一张表--&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">"hibernate.hbm2ddl.auto"</span>&gt;</span>update<span class="tag">&lt;/<span class="name">property</span>&gt;</span></span><br><span class="line"></span><br><span class="line">        <span class="comment">&lt;!--第三部分--&gt;</span></span><br><span class="line">        <span class="comment">&lt;!--指定映射的bean配置文件的位置--&gt;</span></span><br><span class="line">        <span class="comment">&lt;!--如果有多个,就配置多个--&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">mapping</span> <span class="attr">resource</span>=<span class="string">"com/lee/hibernate1/Student.hbm.xml"</span>/&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">session-factory</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">hibernate-configuration</span>&gt;</span></span><br></pre></td></tr></table></figure><p>​</p></li><li><p>使用hibernate向数据库中插入数据的小练习</p></li></ol><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">test1</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        Student student = <span class="keyword">new</span> Student();</span><br><span class="line">        student.setName(<span class="string">"Lee"</span>);</span><br><span class="line">        student.setAddress(<span class="string">"安康市"</span>);</span><br><span class="line">        student.setSex(<span class="string">"男"</span>);</span><br><span class="line"></span><br><span class="line"><span class="comment">//        1. 解析主配置文件</span></span><br><span class="line">        Configuration configuration = <span class="keyword">new</span> Configuration();</span><br><span class="line">        configuration.configure(); <span class="comment">// 配置默认的配置文件,即为根目录下的hibernate.cfg.xml文件</span></span><br><span class="line"><span class="comment">//        2.根据主配置文件,创建SessionFaction对象</span></span><br><span class="line">        SessionFactory factory = configuration.buildSessionFactory();</span><br><span class="line"><span class="comment">//        3.创建Session</span></span><br><span class="line">        Session session = factory.openSession();</span><br><span class="line"><span class="comment">//        4.开启事务</span></span><br><span class="line">        Transaction transaction = session.beginTransaction();</span><br><span class="line"><span class="comment">//        5.执行插入</span></span><br><span class="line">        session.save(student);</span><br><span class="line"><span class="comment">//        6.提交事务</span></span><br><span class="line">        transaction.commit();</span><br><span class="line"><span class="comment">//        7.释放资源</span></span><br><span class="line">        session.close();</span><br><span class="line">        factory.close();</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure><h2 id="Configuration"><a href="#Configuration" class="headerlink" title="Configuration"></a>Configuration</h2><p>配置配置文件</p><p>一般在hibernate.cfg.xml中配置的东西,在该对象中都是可以配置的,但是不推荐这么做,硬编码,后期维护升级很费事</p><h2 id="SessionFactory"><a href="#SessionFactory" class="headerlink" title="SessionFactory"></a>SessionFactory</h2><ul><li>该对象在服务器启动(应用启动)的时候创建,在服务器关闭(应用卸载)的时候销毁,一个应用只存在一个实例</li><li>它是线程安全的</li><li>在创建SessionFactory以后对配置文件进行更改,将不会影响到该factory</li></ul><h2 id="Session"><a href="#Session" class="headerlink" title="Session"></a>Session</h2><ul><li>一个线程只有一个对象</li></ul><h2 id="Transaction"><a href="#Transaction" class="headerlink" title="Transaction"></a>Transaction</h2><h3 id="Hibernate工具类"><a href="#Hibernate工具类" class="headerlink" title="Hibernate工具类"></a>Hibernate工具类</h3><h3 id="Hibernate中CRUD操作"><a href="#Hibernate中CRUD操作" class="headerlink" title="Hibernate中CRUD操作"></a>Hibernate中CRUD操作</h3><h2 id="Hibernate中的异常处理"><a href="#Hibernate中的异常处理" class="headerlink" title="Hibernate中的异常处理"></a>Hibernate中的异常处理</h2><p>HibernateException继承了RuntimeException,这个异常可以不用捕获</p><h1 id="Hibernate中配置c3p0连接池"><a href="#Hibernate中配置c3p0连接池" class="headerlink" title="Hibernate中配置c3p0连接池"></a>Hibernate中配置c3p0连接池</h1><p>F:\java资料\SSH框架\hibernate-release-5.2.16.Final\project\etc/hibernate.properties文件中查找配置格式(搜索c3p0)</p><h3 id="Hibernate中查询的get和load方法的区别"><a href="#Hibernate中查询的get和load方法的区别" class="headerlink" title="Hibernate中查询的get和load方法的区别"></a>Hibernate中查询的get和load方法的区别</h3><p><em>查询时机不同,返回查询的结果不一样</em></p><ul><li>get:立即加载</li><li>load:延迟加载(懒加载,惰性加载),返回的对象是增强对象(动态代理),增强了toString()方法;他也可以通过配置的方式改为立即加载</li></ul><p>学习中遇到的问题及其结局方案:</p><h3 id="使用的MySQL版本为5-5-使用Hibernate的版本为5-2-16-在配置hibernate-cfg-xml的时候"><a href="#使用的MySQL版本为5-5-使用Hibernate的版本为5-2-16-在配置hibernate-cfg-xml的时候" class="headerlink" title="使用的MySQL版本为5.5,使用Hibernate的版本为5.2.16,在配置hibernate.cfg.xml的时候"></a>使用的MySQL版本为5.5,使用Hibernate的版本为5.2.16,在配置<code>hibernate.cfg.xml</code>的时候</h3><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">&lt;!--配置数据库方言--&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">"hibernate.dialect"</span>&gt;</span>org.hibernate.dialect.MySQL5Dialect<span class="tag">&lt;/<span class="name">property</span>&gt;</span></span><br></pre></td></tr></table></figure><p>在MySQL版本为<code>5.5</code>及以上时,如果配置数据库方言,将<code>org.hibernate.dialect.MySQLDialect</code>改为上面的</p><p><code>org.hibernate.dialect.MySQL5Dialect</code> 不然在hibernate创建表格的时候会报错.</p><p>或者这个配置项直接不配置也是可以的</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h1 id=&quot;Hibernate&quot;&gt;&lt;a href=&quot;#Hibernate&quot; class=&quot;headerlink&quot; title=&quot;Hibernate&quot;&gt;&lt;/a&gt;Hibernate&lt;/h1&gt;&lt;p&gt;学习内容:&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;&lt;p&gt;Hibernate相关jar包的依赖&lt;/
      
    
    </summary>
    
    
      <category term="学习日记" scheme="https://blueleer.github.io/tags/%E5%AD%A6%E4%B9%A0%E6%97%A5%E8%AE%B0/"/>
    
      <category term="错误解决" scheme="https://blueleer.github.io/tags/%E9%94%99%E8%AF%AF%E8%A7%A3%E5%86%B3/"/>
    
  </entry>
  
  <entry>
    <title>SSH框架学习之Struts2--第一天</title>
    <link href="https://blueleer.github.io/2018/04/08/SSH%E6%A1%86%E6%9E%B6%E5%AD%A6%E4%B9%A0%E4%B9%8BStruts2-%E7%AC%AC%E4%B8%80%E5%A4%A9/"/>
    <id>https://blueleer.github.io/2018/04/08/SSH框架学习之Struts2-第一天/</id>
    <published>2018-04-08T05:10:07.000Z</published>
    <updated>2018-04-08T08:30:50.604Z</updated>
    
    <summary type="html">
    
    </summary>
    
      <category term="Java" scheme="https://blueleer.github.io/categories/Java/"/>
    
    
      <category term="Struts2" scheme="https://blueleer.github.io/tags/Struts2/"/>
    
  </entry>
  
  <entry>
    <title>回车和换行</title>
    <link href="https://blueleer.github.io/2018/04/07/%E5%9B%9E%E8%BD%A6%E5%92%8C%E6%8D%A2%E8%A1%8C/"/>
    <id>https://blueleer.github.io/2018/04/07/回车和换行/</id>
    <published>2018-04-07T03:43:40.000Z</published>
    <updated>2018-04-07T17:06:23.583Z</updated>
    
    <content type="html"><![CDATA[<p>今天在做爬虫的时候,需要匹配下面Title中的内容,发现写的正则表达式<strong>question_link(.<em>)&gt;(\n</em>)(.+)(\n*)&lt;</strong>竟然匹配不上里面的中文,原来在win系统中文件中的换行其实包含了两个字符, <strong>/CR(回车),/LF(换行)</strong>,这两个”.”都是匹配不上的.</p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">h2</span>&gt;</span><span class="tag">&lt;<span class="name">a</span> <span class="attr">class</span>=<span class="string">"question_link"</span> <span class="attr">href</span>=<span class="string">"/question/270597366/answer/355546388"</span> <span class="attr">data-id</span>=<span class="string">"22407872"</span> <span class="attr">data-za-element-name</span>=<span class="string">"Title"</span>&gt;</span></span><br><span class="line">如何看待星巴克被指含有致癌物质（丙烯酰胺Acrylamide）？</span><br><span class="line"><span class="tag">&lt;/<span class="name">a</span>&gt;</span><span class="tag">&lt;/<span class="name">h2</span>&gt;</span></span><br></pre></td></tr></table></figure><p>修改成下面,成功匹配</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">question_link(.*)&gt;(\r)(\n)(.*)</span><br></pre></td></tr></table></figure><p>完整代码为:</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 其中这段是从文件中摘录的,文件中查看特殊符号显示了换行包含两个字符 一个回车一个换行</span></span><br><span class="line">String s = <span class="string">"&lt;h2&gt;&lt;a class="</span>question_link<span class="string">" href="</span>/question/<span class="number">270597366</span>/answer/<span class="number">355546388</span><span class="string">" data-id="</span><span class="number">22407872</span><span class="string">" data-za-element-name="</span>Title<span class="string">"&gt;</span></span><br><span class="line"><span class="string">如何看待星巴克被指含有致癌物质（丙烯酰胺Acrylamide）？</span></span><br><span class="line"><span class="string">&lt;/a&gt;&lt;/h2&gt;"</span></span><br><span class="line">    </span><br><span class="line">String regex = <span class="string">"question_link(.*)&gt;(\\r)(\\n)(.*)"</span>;</span><br><span class="line">Pattern pattern = Pattern.compile(regex);</span><br><span class="line">Matcher matcher = pattern.matcher(sb.toString());</span><br><span class="line">matcher.find();</span><br><span class="line">String group = matcher.group(<span class="number">4</span>);</span><br><span class="line">System.out.println(group);</span><br><span class="line"></span><br><span class="line"><span class="comment">// 输出:</span></span><br><span class="line"><span class="comment">// 如何看待星巴克被指含有致癌物质（丙烯酰胺Acrylamide）？</span></span><br></pre></td></tr></table></figure><p>小示例:</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">String s1 = <span class="string">"\r1234\r567"</span>;</span><br><span class="line">String s2 = <span class="string">"\n12345"</span>;</span><br><span class="line">System.out.println(s1);</span><br><span class="line">System.out.println(s2);</span><br><span class="line"></span><br><span class="line"><span class="comment">// 输出:</span></span><br><span class="line"><span class="number">567</span></span><br><span class="line"></span><br><span class="line"><span class="number">12345</span></span><br></pre></td></tr></table></figure><p><strong>再次强调,回车和换行,”.”都不能匹配</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">String s1 = <span class="string">"\r1234\r567"</span>;</span><br><span class="line">String regex = <span class="string">".*"</span>;</span><br><span class="line">String regex1 = <span class="string">"\\r.*"</span>;</span><br><span class="line">Pattern pattern = Pattern.compile(regex1); <span class="comment">// 换成regex则下面的输出为空,也就是不能匹配</span></span><br><span class="line">Matcher matcher = pattern.matcher(s1);</span><br><span class="line">matcher.find();</span><br><span class="line">System.out.println(matcher.group());</span><br></pre></td></tr></table></figure><p>更多知识请参考:</p><p><a href="https://blog.csdn.net/fanwenbo/article/details/54848429" target="_blank" rel="noopener">终于搞懂了回车与换行的区别</a></p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;今天在做爬虫的时候,需要匹配下面Title中的内容,发现写的正则表达式&lt;strong&gt;question_link(.&lt;em&gt;)&amp;gt;(\n&lt;/em&gt;)(.+)(\n*)&amp;lt;&lt;/strong&gt;竟然匹配不上里面的中文,原来在win系统中文件中的换行其实包含了两个字符, &lt;
      
    
    </summary>
    
      <category term="其他" scheme="https://blueleer.github.io/categories/%E5%85%B6%E4%BB%96/"/>
    
    
      <category term="计算机" scheme="https://blueleer.github.io/tags/%E8%AE%A1%E7%AE%97%E6%9C%BA/"/>
    
      <category term="其他" scheme="https://blueleer.github.io/tags/%E5%85%B6%E4%BB%96/"/>
    
  </entry>
  
  <entry>
    <title>hexo主题之next主题的配置</title>
    <link href="https://blueleer.github.io/2018/04/06/hexo%E4%B8%BB%E9%A2%98%E4%B9%8Bnext%E4%B8%BB%E9%A2%98%E7%9A%84%E9%85%8D%E7%BD%AE/"/>
    <id>https://blueleer.github.io/2018/04/06/hexo主题之next主题的配置/</id>
    <published>2018-04-06T13:46:36.000Z</published>
    <updated>2018-04-06T15:48:33.471Z</updated>
    
    <content type="html"><![CDATA[<p>关于 hexo 主题之next主题</p><ul><li><a href="https://github.com/iissnan/hexo-theme-next" target="_blank" rel="noopener">GiuHub地址</a></li><li><a href="http://theme-next.iissnan.com/getting-started.html" target="_blank" rel="noopener">Next主题配置官网文档</a></li><li><a href="http://shenzekun.cn/hexo%E7%9A%84next%E4%B8%BB%E9%A2%98%E4%B8%AA%E6%80%A7%E5%8C%96%E9%85%8D%E7%BD%AE%E6%95%99%E7%A8%8B.html" target="_blank" rel="noopener">hexo的next主题个性化教程:打造炫酷网站</a></li></ul><p>另外附上大致的使用GitHub Pages建站的流程:</p><ol><li>注册GitHub账号</li><li>创建 YourName.github.io库,GitHub默认把它当做静态html托管仓库(我们实际上也仅仅是在它上面托管我们的静态网页,它还能够识别解析css和js文件)</li><li>在GitHub上生成 SSH Keys (后面使用的hexo在本地拥有了一个SSH Keys的拷贝,这样就可以实现快速部署到pages仓库)</li><li>安装hexo,推荐参考 <a href="https://hexo.io/zh-cn/docs/index.html" target="_blank" rel="noopener">hexo官方文档</a> 这样可以少走很多弯路,遇到问题了再去查解决方法</li><li>然后就可以找一款自己喜欢的主题啦 <a href="https://hexo.io/" target="_blank" rel="noopener">hexo官网</a>,这上面有很全的plug插件和theme主题,也可以参考别人的推荐,我就用的是GitHub上star数醉的的一款next</li></ol>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;关于 hexo 主题之next主题&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;&lt;a href=&quot;https://github.com/iissnan/hexo-theme-next&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;GiuHub地址&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;
      
    
    </summary>
    
      <category term="其他" scheme="https://blueleer.github.io/categories/%E5%85%B6%E4%BB%96/"/>
    
    
      <category term="hexo主题配置" scheme="https://blueleer.github.io/tags/hexo%E4%B8%BB%E9%A2%98%E9%85%8D%E7%BD%AE/"/>
    
  </entry>
  
  <entry>
    <title>Java中的Pattern、Matcher、常用的正则表达式</title>
    <link href="https://blueleer.github.io/2018/04/06/Java%E4%B8%AD%E7%9A%84Pattern%E3%80%81Matcher%E3%80%81%E5%B8%B8%E7%94%A8%E7%9A%84%E6%AD%A3%E5%88%99%E8%A1%A8%E8%BE%BE%E5%BC%8F/"/>
    <id>https://blueleer.github.io/2018/04/06/Java中的Pattern、Matcher、常用的正则表达式/</id>
    <published>2018-04-06T08:20:55.000Z</published>
    <updated>2018-04-06T08:23:37.992Z</updated>
    
    <content type="html"><![CDATA[<h1 id="Java中的Pattern、Matcher、常用的正则表达式"><a href="#Java中的Pattern、Matcher、常用的正则表达式" class="headerlink" title="Java中的Pattern、Matcher、常用的正则表达式"></a>Java中的Pattern、Matcher、常用的正则表达式</h1><p><strong>Java中的字符串已经有了直接调用简单匹配方法,matches方法(内部也是使用了Pattern.matches()方法)</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">String s = <span class="string">"Java12Java34"</span>;</span><br><span class="line"><span class="comment">// 精确匹配,返回regex和s串是否完全匹配</span></span><br><span class="line"><span class="keyword">boolean</span> isMatch = s.matches(<span class="string">"Java"</span>); <span class="comment">// 这里返回false</span></span><br><span class="line"><span class="comment">// 在一定的范围内进行匹配</span></span><br><span class="line"><span class="comment">// 参数的含义: 是否忽略大小写,s串的起始位置(offset),regex字符串,regex字符串的起始位置,取regex串的长度</span></span><br><span class="line"><span class="keyword">boolean</span> isMatch2 = s.regionMatches(<span class="keyword">true</span>, <span class="number">6</span>, <span class="string">"Java"</span>, <span class="number">0</span>, <span class="string">"Java"</span>.length()); <span class="comment">// 返回true</span></span><br></pre></td></tr></table></figure><p>但是很多时候String自带的这些方法不足于我们使用,此时Java中提供了Pattern和Matcher两个与正则表达式相关的类供我们使用</p><h2 id="Pattern类"><a href="#Pattern类" class="headerlink" title="Pattern类"></a>Pattern类</h2><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">String regex = <span class="string">"Java"</span>;</span><br><span class="line">Pattern pattern = Pattern.compile(regex);</span><br></pre></td></tr></table></figure><h3 id="Pattern-matches-静态方法"><a href="#Pattern-matches-静态方法" class="headerlink" title="Pattern.matches()静态方法"></a>Pattern.matches()静态方法</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">String regex = <span class="string">"Java"</span>;</span><br><span class="line">String s2 = <span class="string">"Java123Java456Java789"</span>;</span><br><span class="line">Pattern.matches(<span class="string">"Java"</span>, s2); <span class="comment">// 注意这里也是全串精确匹配</span></span><br></pre></td></tr></table></figure><p>其实这个方法和String中的matches()方法一致,其实String.matches()方法内部就是调用了此方法</p><h3 id="split"><a href="#split" class="headerlink" title="split"></a>split</h3><p>顾名思义就是分割字符串的方法,其中regex就是分割字符串的”刀”,注意当regex和字符串开始或者结尾部分匹配的时候会得到空字符串</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">String regex = <span class="string">"Java"</span>;</span><br><span class="line">String s2 = <span class="string">"Java123Java456Java789"</span>;</span><br><span class="line">Pattern pattern = Pattern.compile(<span class="string">"Java"</span>);</span><br><span class="line"></span><br><span class="line"><span class="comment">// split(input),分割字符串得到String数组</span></span><br><span class="line">String[] split = pattern.split(s2);</span><br><span class="line">System.out.println(split.length); <span class="comment">// 输出3,[空串,123,456,789]</span></span><br><span class="line"></span><br><span class="line">String[] split1 = pattern.split(regex, <span class="number">2</span>);</span><br><span class="line">System.out.println(<span class="string">"split1的长度为 : "</span> + split1.length); <span class="comment">// 输出2,[空串,123Java456Java789],想想limit设置成3会怎样?</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 注意:limit设置成0或者负数,效果默认一样,也就是和pattern.split(s2)一样</span></span><br></pre></td></tr></table></figure><p>关于Pattern只介绍这两个方法,其他的可以自行创建demo试试</p><h2 id="Matcher类"><a href="#Matcher类" class="headerlink" title="Matcher类"></a>Matcher类</h2><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">String regex = <span class="string">"Java"</span>;</span><br><span class="line">String s = <span class="string">"Java123Java456Java789"</span>;</span><br><span class="line">Pattern pattern = Pattern.compile(regex);</span><br><span class="line">Matcher matcher1 = pattern.matcher(s);</span><br></pre></td></tr></table></figure><ul><li>find()：尝试查找与该模式匹配的输入序列的的下一个子序列。重要,下面重点说</li><li>find(int start)：重置此匹配器，然后尝试查找匹配该模式、从指定索引开始的输入序列的下一个子序列。</li><li>group()：匹配成功返回的组,重要,下面重点说</li><li>start()：返回先前匹配的起始位置的索引。</li><li>end()：返回最后匹配字符的索引加一。</li><li>matches()：尝试将整个区域与模式匹配。匹配成功返回true</li><li>lookingAt()：尝试将从区域开头开始的输入序列与该模式匹配。</li><li>replaceFirst()：替换掉匹配的第一个子序列</li><li>replaceAll()：替换掉匹配的全部子序列</li><li>appendReplacement：重要，下面重点说</li><li>appendTail(StringBuffer buf)：重要，下面重点说</li><li>reset():重置匹配器,从起始位置重新开始</li><li>reset(CharSequence input):重置匹配器,放入新的待匹配的串</li></ul><p><strong>部分方法解析</strong></p><ol><li><p><strong>find()方法</strong></p><p>注意:该方法尝试查找与该模式匹配的输入序列的下一个子序列.此方法从匹配器区域的开头开始，如果该方法的前一次调用成功了,并且从那时开始匹配器没有被重置，则从以前匹配操作没有匹配的第一个字符开始</p></li></ol><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">String regex = <span class="string">"Java."</span>;</span><br><span class="line">String s = <span class="string">"Java1Java2"</span>;</span><br><span class="line">Pattern pattern = Pattern.compile(regex);</span><br><span class="line">Matcher matcher1 = pattern.matcher(s);</span><br><span class="line">matcher1.find(); <span class="comment">// 这里返回true</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 其实此时我们可以使用下面的方式来循环获取匹配得到的子串</span></span><br><span class="line"><span class="keyword">while</span>(matcher.find)&#123; <span class="comment">// 循环查找,本次查找结束了,下次如果想获得查找结果应该重新执行find()方法</span></span><br><span class="line">    System.out.println(matcher.group()); <span class="comment">// 关于group方法将在下面介绍</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 上面的方法输出:</span></span><br><span class="line">Java1</span><br><span class="line">Java2</span><br></pre></td></tr></table></figure><ol start="2"><li><p><strong>group()方法</strong></p><p><em>这里介绍下组的概念：组是用括号划分的正则表达式，可以根据组的编号来引用这个组。组号为0表示整个表达式，组号为1表示被第一对括号括起的组，依次类推，例如A(B(C))D，组0是ABCD，组1是BC，组2是C。</em></p><p><em>Matcher类提供了start()，end()，group()分别用于返回字符串的起始索引，结束索引，以及匹配到到的字符串。</em></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">String regex = <span class="string">"(Java).*(Java)"</span>;</span><br><span class="line">String s = <span class="string">"Java123Java456"</span>;</span><br><span class="line">Pattern pattern = Pattern.compile(regex);</span><br><span class="line">Matcher matcher2 = pattern.matcher(s);</span><br><span class="line">matcher2.find(); <span class="comment">// 注意,这里需要先执行find方法</span></span><br><span class="line">System.out.println(matcher2.group()); <span class="comment">// 如果find()方法执行返回true,则group()或者group(0)代表整个字符串s:Java123Java456</span></span><br><span class="line">System.out.println(matcher2.group(<span class="number">1</span>)); <span class="comment">// 输出 Java123</span></span><br><span class="line">System.out.println(matcher2.group(<span class="number">2</span>)); <span class="comment">// 输出Java456</span></span><br></pre></td></tr></table></figure></li><li><p>appendReplacement(StringBuffer sb,String replacement)方法</p><p>先从字符串中执行查找,查找到了,替换成replacement,并从开始匹配的位置处将字符串写入StringBuffer中,示例入下:</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line">String s = <span class="string">"2018-4-10 15-45-30"</span>;</span><br><span class="line">String regex = <span class="string">"-"</span>;</span><br><span class="line">Pattern pattern = Pattern.compile(regex);</span><br><span class="line">Matcher matcher = pattern.matcher(s);</span><br><span class="line">StringBuffer sb = <span class="keyword">new</span> StringBuffer();</span><br><span class="line">matcher.find();</span><br><span class="line">matcher.appendReplacement(sb, <span class="string">":"</span>);</span><br><span class="line">System.out.println(sb.toString());</span><br><span class="line">matcher.find();</span><br><span class="line">matcher.appendReplacement(sb, <span class="string">":"</span>);</span><br><span class="line">System.out.println(sb.toString());</span><br><span class="line">matcher.find();</span><br><span class="line">matcher.appendReplacement(sb, <span class="string">":"</span>);</span><br><span class="line">System.out.println(sb.toString());</span><br><span class="line"></span><br><span class="line">输出入下:</span><br><span class="line"><span class="number">2018</span>:</span><br><span class="line"><span class="number">2018</span>:<span class="number">4</span>:</span><br><span class="line"><span class="number">2018</span>:<span class="number">4</span>:<span class="number">10</span> <span class="number">15</span>:</span><br></pre></td></tr></table></figure><p>可以看到,它比String的replaceAll()或者replace()方法更加灵活</p><h2 id="正则表达式语法"><a href="#正则表达式语法" class="headerlink" title="正则表达式语法"></a>正则表达式语法</h2><p>请参考 <a href="http://www.runoob.com/java/java-regular-expressions.html" target="_blank" rel="noopener">Java 正则表达式</a></p></li></ol>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h1 id=&quot;Java中的Pattern、Matcher、常用的正则表达式&quot;&gt;&lt;a href=&quot;#Java中的Pattern、Matcher、常用的正则表达式&quot; class=&quot;headerlink&quot; title=&quot;Java中的Pattern、Matcher、常用的正则表达式&quot;&gt;
      
    
    </summary>
    
      <category term="Java" scheme="https://blueleer.github.io/categories/Java/"/>
    
    
      <category term="Java" scheme="https://blueleer.github.io/tags/Java/"/>
    
      <category term="Java正则表达式" scheme="https://blueleer.github.io/tags/Java%E6%AD%A3%E5%88%99%E8%A1%A8%E8%BE%BE%E5%BC%8F/"/>
    
  </entry>
  
  <entry>
    <title>Git版本控制工具的简单使用</title>
    <link href="https://blueleer.github.io/2016/11/07/Git%E7%89%88%E6%9C%AC%E6%8E%A7%E5%88%B6%E5%B7%A5%E5%85%B7%E7%9A%84%E7%AE%80%E5%8D%95%E4%BD%BF%E7%94%A8/"/>
    <id>https://blueleer.github.io/2016/11/07/Git版本控制工具的简单使用/</id>
    <published>2016-11-07T14:08:04.000Z</published>
    <updated>2018-04-07T17:02:45.970Z</updated>
    
    <content type="html"><![CDATA[<p><em>虽然在Windows系统上安装的<strong>Git</strong>是可以在图形界面上进行操作的,但是我们并不应该这么做,<strong>Git</strong>的各种命令才是我们应该掌握的,而且将来我们不管换成什么样的操作系统,使用<strong>Git</strong>命令来操作都是通用的</em></p><h3 id="1-创建代码仓库"><a href="#1-创建代码仓库" class="headerlink" title="1. 创建代码仓库"></a>1. 创建代码仓库</h3><p>初次打开Bash的时候我们应该配置身份</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">git confing --global user.name "yourname"</span><br><span class="line">git confing --global user.email "your email address"</span><br></pre></td></tr></table></figure><p>然后切换到你要上传到github的项目的根目录下,例如下面这个项目:</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">cd f:</span><br><span class="line">cd android/BroadcastTest/</span><br></pre></td></tr></table></figure><p>然后输入下面的命令:</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">git init</span><br></pre></td></tr></table></figure><p>这样会在BroadcastTest目录下生成一个 .git 文件夹</p><h3 id="2-提交本地代码"><a href="#2-提交本地代码" class="headerlink" title="2. 提交本地代码"></a>2. 提交本地代码</h3><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">git add AndroidManifest.xml   # 将AndroidManifest.xml文件添加进本地仓库</span><br><span class="line">git add src # 将src目录添加进本地仓库</span><br><span class="line">git add . # 添加所有的文件到本地仓库</span><br></pre></td></tr></table></figure><p>上面的添加只是将文件/文件夹添加到本地仓库,并没有提交:</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">git commit -m "first commit" # 其中"first commit"是本次提交的描述,建议加上此次提交的描述,将来我们可以很方便的看到提交了什么</span><br></pre></td></tr></table></figure><h3 id="3-忽略文件"><a href="#3-忽略文件" class="headerlink" title="3. 忽略文件"></a>3. 忽略文件</h3><p><em>我们提交的时候,并不是该项目下所有的文件都得提交,例如 .idea 文件夹是不需要提交的,它是IDE自动生成的,那么怎么忽略掉这些文件呢?</em></p><p><strong>第一步: 在BroadcastTest目录下创建 .gitignore文件</strong></p><p><em>注意可能你在创建该文件的时候提示你”必须键入文件名,解决方法是:</em></p><ol><li><em>在项目根目录下面创建gitignore.txt文件</em></li><li><em>把你需要排除的文件名保存到gitignore.txt文件</em></li><li><em>在项目根目录下面按住Shift键并鼠标右键选择“在此处打开命令窗口”</em></li><li><em>执行命令 <code>ren gitignore.txt .gitignore</code></em></li></ol><p><strong>第二步:编辑.gitignore文件,将你想要忽略提交的文件或者文件夹加入</strong></p><p>例如:</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">bin/</span><br><span class="line">gen/</span><br><span class="line">*.html # 忽略所有的html文件,其中 "*" 为通配符,表示任意多个字符, "?" 代表一个字符, 方括号 [abc]代表可选字符范围</span><br></pre></td></tr></table></figure><p>编辑好上面的.gitignore文件以后,执行 <code>git add .</code>就会自动将匹配上的文件或者文件夹忽略,然后执行</p><p><code>git commit -m &quot;Second commit with ignore&quot;</code> 大功告成!</p><h3 id="4-查看修改内容"><a href="#4-查看修改内容" class="headerlink" title="4. 查看修改内容"></a>4. 查看修改内容</h3><p>在项目的开发阶段我们经常提交代码到仓库,理想的情况是每当完成了一小块功能的时候,就执行一次提交.当某个功能修改比较多的时候,写到后面可能我们已经忘记了本次到底修改了什么内容了,此时Git在帮你记着.</p><p><code>git status</code>    查看本次更改的概况</p><p><code>git diff   src/lee/com/broadcasttest/Main.java</code>     查看某个文件具体修改的内容,其中,减号代表删除的内容,加号代表添加的内容</p><h3 id="5-撤销未提交的修改"><a href="#5-撤销未提交的修改" class="headerlink" title="5. 撤销未提交的修改"></a>5. 撤销未提交的修改</h3><p>每次完成一个功能以后,都会先执行 <code>add</code>命令添加进本地仓库</p><p>本次代码修改以后,只要未提交(也就是未执行<code>add</code>命令),都可以运行</p><p><code>git checkout src/lee/com/broadcasttest/Main.java</code> 来撤销更改</p><p>上面的命令只能针对那些没有执行过<code>add</code>命令的文件有效,当某个文件已经<code>add</code>过了,此时需要先对其进行取消添加</p><p><code>git  reset HEAD src/lee/com/broadcast/Main.java</code>,然后在执行上面的</p><p><code>git checkout src/lee/com/broadcasttest/Main.java</code>命令</p><h3 id="6-查看提交记录"><a href="#6-查看提交记录" class="headerlink" title="6. 查看提交记录"></a>6. 查看提交记录</h3><p><code>git log</code></p><p>当我们的提交较多的时候,可以指定该记录的id:</p><p><code>git log 提交记录的id -1</code>(注意这里要添加上-1)</p><p>在命令中添加<code>-p</code>参数,查看该条记录具体修改的内容:</p><p><code>git log 提交记录的id -1 -p</code></p><h3 id="7-分支的用法"><a href="#7-分支的用法" class="headerlink" title="7. 分支的用法"></a>7. 分支的用法</h3><p><code>git branch -a</code>  查看当前的版本库中有哪些分支,版本库创建的时候默认只有一个分支 <strong>master</strong></p><p><code>git branch version1.0</code>  创建一个名为 <strong>version1.0</strong>  的分支,虽然此时创建了一个新的分支version1.0,但是当前你所在的分支依然是master,使用下面的命令进行切花分支</p><p><code>git checkout version1.0</code> 切换到<strong>version1.0</strong>的分支上</p><p><strong>当你想把version1.0分支上所做的修改合并到master分支上,使用下面的命令进行</strong></p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">git checkout master   # 先切换到master分支上</span><br><span class="line">git merge version1.0  # 合并merge分支上的修改到master分支上,此时version1.0分支上的代码不会受到影响</span><br><span class="line"># 另外,合并分支的时候可能会出现代码冲突的情况,此时应该慢慢查找那些冲突的代码,git  无力帮助我们</span><br></pre></td></tr></table></figure><p><code>git branch -D version1.0</code>  删除version1.0的分支</p><h3 id="8-与远程版本库协作"><a href="#8-与远程版本库协作" class="headerlink" title="8. 与远程版本库协作"></a>8. 与远程版本库协作</h3><p><strong>上面的操作都是在本地完成的,只适合个人作为项目版本的控制方法</strong></p><p>所有的版本控制工具最重要的一个特点就是可以使用它来进行团队合作开发,每个人的电脑上都会有一份代码,当团队的某个成员在自己的电脑上编写完成了某个功能后,就将代码提交到服务器,其他的成员只需要将服务器上的代码同步到本地,就能保证整个团队所有人的代码都相同.这样的话,每个成员就可以各司其职,完成每个人负责的模块,这样就可以共同完成一个庞大的项目.</p><p>现在,项目负责人在Git上创建了一个项目,项目地址为:<a href="https://github.com/BlueLeer/Crawler" target="_blank" rel="noopener">https://github.com/BlueLeer/Crawler</a></p><p><strong>将代码下载到本地</strong>:</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">git clone https://github.com/BlueLeer/Crawler.git</span><br></pre></td></tr></table></figure><p><strong>之后,当你在这份代码的基础上完成了一些修改,使用下面的命令将本地修改的内容同步到版本库:</strong></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">git push origin master  # 注意:该命令应该在上面本地代码根目录上执行,origin指的是远程Git地址,master指的是master分支,当然也可以是其他的分支</span><br></pre></td></tr></table></figure><p>团队的其他成员对Git版本库中的代码也进行了修改,我们应该要养成经常从版本库中获取最新代码的习惯,那么怎么讲远程版本库中的修改同步到本地呢?使用下面的命令:</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">git fetch origin master </span><br><span class="line"># fetch意为获取之意,但是注意:同步下来的代码并不会合并到本地的任何分支上,而是会存放在一个 origin/master</span><br><span class="line"># 分支上,此时可以先调用 git diff origin/master 查看远程版本库中到底修改了什么内容</span><br></pre></td></tr></table></figure><p>之后调用 <code>merge</code>命令将<code>origin/master</code>分支上的修改合并到本地的master分支上即可:</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">git merge origin/master</span><br></pre></td></tr></table></figure><p>推荐使用上面的方法,当然下面的方法更简单,一步到位,那就是<code>pull</code>命令了,它其实相当于将<code>fetch</code>和<code>merge</code>两个命令放在一起执行了,它从远程的版本苦衷获取罪行的代码并合并到本地:</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">git pull origin master</span><br></pre></td></tr></table></figure><h3 id="9-上传本地项目"><a href="#9-上传本地项目" class="headerlink" title="9.上传本地项目"></a>9.上传本地项目</h3><p>参考:<a href="https://www.cnblogs.com/specter45/p/github.html" target="_blank" rel="noopener">github入门到上传本地项目</a></p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;&lt;em&gt;虽然在Windows系统上安装的&lt;strong&gt;Git&lt;/strong&gt;是可以在图形界面上进行操作的,但是我们并不应该这么做,&lt;strong&gt;Git&lt;/strong&gt;的各种命令才是我们应该掌握的,而且将来我们不管换成什么样的操作系统,使用&lt;strong&gt;Git&lt;/s
      
    
    </summary>
    
      <category term="其他" scheme="https://blueleer.github.io/categories/%E5%85%B6%E4%BB%96/"/>
    
    
      <category term="GitHub" scheme="https://blueleer.github.io/tags/GitHub/"/>
    
  </entry>
  
  <entry>
    <title>在活动中使用菜单Menu和PopupMenu</title>
    <link href="https://blueleer.github.io/2016/11/01/%E5%9C%A8%E6%B4%BB%E5%8A%A8%E4%B8%AD%E4%BD%BF%E7%94%A8%E8%8F%9C%E5%8D%95Menu%E5%92%8CPopupMenu/"/>
    <id>https://blueleer.github.io/2016/11/01/在活动中使用菜单Menu和PopupMenu/</id>
    <published>2016-11-01T15:55:32.000Z</published>
    <updated>2018-04-06T16:05:39.468Z</updated>
    
    <content type="html"><![CDATA[<h3 id="在Activity中使用Menu和PopupMenu"><a href="#在Activity中使用Menu和PopupMenu" class="headerlink" title="在Activity中使用Menu和PopupMenu"></a>在Activity中使用Menu和PopupMenu</h3><p>流程:</p><ol><li>点击<strong>res</strong>目录新建<strong>Android resouce file</strong>文件,选择<strong>resoucetype</strong>为<strong>menu</strong>,然后可以创建如下菜单的布局:</li></ol><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">&lt;?xml version="1.0" encoding="utf-8"?&gt;</span><br><span class="line"><span class="tag">&lt;<span class="name">menu</span> <span class="attr">xmlns:android</span>=<span class="string">"http://schemas.android.com/apk/res/android"</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">item</span></span></span><br><span class="line"><span class="tag">        <span class="attr">android:id</span>=<span class="string">"@+id/refresh_item"</span></span></span><br><span class="line"><span class="tag">        <span class="attr">android:title</span>=<span class="string">"刷新"</span>/&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">item</span> <span class="attr">android:id</span>=<span class="string">"@+id/change_city"</span></span></span><br><span class="line"><span class="tag">        <span class="attr">android:title</span>=<span class="string">"选择城市"</span>/&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">menu</span>&gt;</span></span><br></pre></td></tr></table></figure><ol start="2"><li><p>然后在活动中重写<strong>onCreateOptionsMenu(Menu menu)</strong>方法:</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">onCreateOptionsMenu</span><span class="params">(Menu menu)</span> </span>&#123;</span><br><span class="line">    <span class="comment">//R.menu.menu就是menu的布局文件</span></span><br><span class="line">    getMenuInflater().inflate(R.menu.menu,menu);</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>​</p></li><li><p>然后在手机上点击”菜单”就可以弹出菜单了,该菜单是从屏幕底部弹出的.</p></li></ol><p>当然我们也可以为点击菜单上的项目注册响应事件,通过重写<strong>onOptionsItemSelected()</strong>方法:</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">onOptionsItemSelected</span><span class="params">(MenuItem item)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">switch</span>(item.getItemId())&#123;</span><br><span class="line">        <span class="keyword">case</span> R.id.refresh_item:</span><br><span class="line">            <span class="comment">//加入逻辑</span></span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">        <span class="keyword">case</span>  R.id.change_city:</span><br><span class="line">            <span class="comment">//加入逻辑</span></span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">super</span>.onOptionsItemSelected(item);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ol start="4"><li><p>有时候我们希望通过点击屏幕上自己定义的一个组件弹出一个菜单来,并且这个菜单就在这个组件的周围,那么可以这么来写(还是使用刚刚我们定义的<strong>menu</strong>布局文件):</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">Button button = (Button)findViewById(R.id.refresh);</span><br><span class="line"><span class="comment">//点击这个按钮就能弹出一个菜单来</span></span><br><span class="line">button.setOnClickListener(<span class="keyword">new</span> View.OnClickListener()&#123;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">onClick</span><span class="params">(View view)</span> </span>&#123;</span><br><span class="line">        PopupMenu popupMenu = <span class="keyword">new</span> PopupMenu(MainActivity.<span class="keyword">this</span>,view);</span><br><span class="line">        popupMenu.getMenuInflater().inflate(R.menu.menu,popupMenu.getMenu());</span><br><span class="line">        popupMenu.show();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure><p>​</p></li></ol><p>​     在刷新按钮的周围弹出了一个菜单</p><p><img src="1.jpg" alt="弹出popupMenu"></p><p>​     当然我们也可以为PopupMenu响应点击事件:</p><pre><code><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">popupMenu.setOnMenuItemClickListener(<span class="keyword">new</span> PopupMenu.OnMenuItemClickListener()  &#123;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">onMenuItemClick</span><span class="params">(MenuItem menuItem)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">switch</span>(menuItem.getId())&#123;</span><br><span class="line">            <span class="keyword">case</span> R.id.refresh_item</span><br><span class="line">                <span class="comment">//加入自己的逻辑(点击以后发生的事件)</span></span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure></code></pre>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h3 id=&quot;在Activity中使用Menu和PopupMenu&quot;&gt;&lt;a href=&quot;#在Activity中使用Menu和PopupMenu&quot; class=&quot;headerlink&quot; title=&quot;在Activity中使用Menu和PopupMenu&quot;&gt;&lt;/a&gt;在Activit
      
    
    </summary>
    
      <category term="Android" scheme="https://blueleer.github.io/categories/Android/"/>
    
    
      <category term="Android" scheme="https://blueleer.github.io/tags/Android/"/>
    
  </entry>
  
</feed>
