<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>Coding...Coding...</title>
  <icon>https://www.gravatar.com/avatar/186e8a9967ddc3f700ba1e47b6be9b34</icon>
  <subtitle>个人博客</subtitle>
  <link href="/atom.xml" rel="self"/>
  
  <link href="https://blueleer.github.io/"/>
  <updated>2018-04-06T15:48:33.471Z</updated>
  <id>https://blueleer.github.io/</id>
  
  <author>
    <name>KingIsHappy</name>
    <email>251668577@qq.com</email>
  </author>
  
  <generator uri="http://hexo.io/">Hexo</generator>
  
  <entry>
    <title>hexo主题之next主题的配置</title>
    <link href="https://blueleer.github.io/2018/04/06/hexo%E4%B8%BB%E9%A2%98%E4%B9%8Bnext%E4%B8%BB%E9%A2%98%E7%9A%84%E9%85%8D%E7%BD%AE/"/>
    <id>https://blueleer.github.io/2018/04/06/hexo主题之next主题的配置/</id>
    <published>2018-04-06T13:46:36.000Z</published>
    <updated>2018-04-06T15:48:33.471Z</updated>
    
    <content type="html"><![CDATA[<p>关于 hexo 主题之next主题</p><ul><li><a href="https://github.com/iissnan/hexo-theme-next" target="_blank" rel="noopener">GiuHub地址</a></li><li><a href="http://theme-next.iissnan.com/getting-started.html" target="_blank" rel="noopener">Next主题配置官网文档</a></li><li><a href="http://shenzekun.cn/hexo%E7%9A%84next%E4%B8%BB%E9%A2%98%E4%B8%AA%E6%80%A7%E5%8C%96%E9%85%8D%E7%BD%AE%E6%95%99%E7%A8%8B.html" target="_blank" rel="noopener">hexo的next主题个性化教程:打造炫酷网站</a></li></ul><p>另外附上大致的使用GitHub Pages建站的流程:</p><ol><li>注册GitHub账号</li><li>创建 YourName.github.io库,GitHub默认把它当做静态html托管仓库(我们实际上也仅仅是在它上面托管我们的静态网页,它还能够识别解析css和js文件)</li><li>在GitHub上生成 SSH Keys (后面使用的hexo在本地拥有了一个SSH Keys的拷贝,这样就可以实现快速部署到pages仓库)</li><li>安装hexo,推荐参考 <a href="https://hexo.io/zh-cn/docs/index.html" target="_blank" rel="noopener">hexo官方文档</a> 这样可以少走很多弯路,遇到问题了再去查解决方法</li><li>然后就可以找一款自己喜欢的主题啦 <a href="https://hexo.io/" target="_blank" rel="noopener">hexo官网</a>,这上面有很全的plug插件和theme主题,也可以参考别人的推荐,我就用的是GitHub上star数醉的的一款next</li></ol>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;关于 hexo 主题之next主题&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;&lt;a href=&quot;https://github.com/iissnan/hexo-theme-next&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;GiuHub地址&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;
      
    
    </summary>
    
      <category term="其他" scheme="https://blueleer.github.io/categories/%E5%85%B6%E4%BB%96/"/>
    
    
      <category term="hexo主题配置" scheme="https://blueleer.github.io/tags/hexo%E4%B8%BB%E9%A2%98%E9%85%8D%E7%BD%AE/"/>
    
  </entry>
  
  <entry>
    <title>Java中的Pattern、Matcher、常用的正则表达式</title>
    <link href="https://blueleer.github.io/2018/04/06/Java%E4%B8%AD%E7%9A%84Pattern%E3%80%81Matcher%E3%80%81%E5%B8%B8%E7%94%A8%E7%9A%84%E6%AD%A3%E5%88%99%E8%A1%A8%E8%BE%BE%E5%BC%8F/"/>
    <id>https://blueleer.github.io/2018/04/06/Java中的Pattern、Matcher、常用的正则表达式/</id>
    <published>2018-04-06T08:20:55.000Z</published>
    <updated>2018-04-06T08:23:37.992Z</updated>
    
    <content type="html"><![CDATA[<h1 id="Java中的Pattern、Matcher、常用的正则表达式"><a href="#Java中的Pattern、Matcher、常用的正则表达式" class="headerlink" title="Java中的Pattern、Matcher、常用的正则表达式"></a>Java中的Pattern、Matcher、常用的正则表达式</h1><p><strong>Java中的字符串已经有了直接调用简单匹配方法,matches方法(内部也是使用了Pattern.matches()方法)</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">String s = <span class="string">"Java12Java34"</span>;</span><br><span class="line"><span class="comment">// 精确匹配,返回regex和s串是否完全匹配</span></span><br><span class="line"><span class="keyword">boolean</span> isMatch = s.matches(<span class="string">"Java"</span>); <span class="comment">// 这里返回false</span></span><br><span class="line"><span class="comment">// 在一定的范围内进行匹配</span></span><br><span class="line"><span class="comment">// 参数的含义: 是否忽略大小写,s串的起始位置(offset),regex字符串,regex字符串的起始位置,取regex串的长度</span></span><br><span class="line"><span class="keyword">boolean</span> isMatch2 = s.regionMatches(<span class="keyword">true</span>, <span class="number">6</span>, <span class="string">"Java"</span>, <span class="number">0</span>, <span class="string">"Java"</span>.length()); <span class="comment">// 返回true</span></span><br></pre></td></tr></table></figure><p>但是很多时候String自带的这些方法不足于我们使用,此时Java中提供了Pattern和Matcher两个与正则表达式相关的类供我们使用</p><h2 id="Pattern类"><a href="#Pattern类" class="headerlink" title="Pattern类"></a>Pattern类</h2><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">String regex = <span class="string">"Java"</span>;</span><br><span class="line">Pattern pattern = Pattern.compile(regex);</span><br></pre></td></tr></table></figure><h3 id="Pattern-matches-静态方法"><a href="#Pattern-matches-静态方法" class="headerlink" title="Pattern.matches()静态方法"></a>Pattern.matches()静态方法</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">String regex = <span class="string">"Java"</span>;</span><br><span class="line">String s2 = <span class="string">"Java123Java456Java789"</span>;</span><br><span class="line">Pattern.matches(<span class="string">"Java"</span>, s2); <span class="comment">// 注意这里也是全串精确匹配</span></span><br></pre></td></tr></table></figure><p>其实这个方法和String中的matches()方法一致,其实String.matches()方法内部就是调用了此方法</p><h3 id="split"><a href="#split" class="headerlink" title="split"></a>split</h3><p>顾名思义就是分割字符串的方法,其中regex就是分割字符串的”刀”,注意当regex和字符串开始或者结尾部分匹配的时候会得到空字符串</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">String regex = <span class="string">"Java"</span>;</span><br><span class="line">String s2 = <span class="string">"Java123Java456Java789"</span>;</span><br><span class="line">Pattern pattern = Pattern.compile(<span class="string">"Java"</span>);</span><br><span class="line"></span><br><span class="line"><span class="comment">// split(input),分割字符串得到String数组</span></span><br><span class="line">String[] split = pattern.split(s2);</span><br><span class="line">System.out.println(split.length); <span class="comment">// 输出3,[空串,123,456,789]</span></span><br><span class="line"></span><br><span class="line">String[] split1 = pattern.split(regex, <span class="number">2</span>);</span><br><span class="line">System.out.println(<span class="string">"split1的长度为 : "</span> + split1.length); <span class="comment">// 输出2,[空串,123Java456Java789],想想limit设置成3会怎样?</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 注意:limit设置成0或者负数,效果默认一样,也就是和pattern.split(s2)一样</span></span><br></pre></td></tr></table></figure><p>关于Pattern只介绍这两个方法,其他的可以自行创建demo试试</p><h2 id="Matcher类"><a href="#Matcher类" class="headerlink" title="Matcher类"></a>Matcher类</h2><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">String regex = <span class="string">"Java"</span>;</span><br><span class="line">String s = <span class="string">"Java123Java456Java789"</span>;</span><br><span class="line">Pattern pattern = Pattern.compile(regex);</span><br><span class="line">Matcher matcher1 = pattern.matcher(s);</span><br></pre></td></tr></table></figure><ul><li>find()：尝试查找与该模式匹配的输入序列的的下一个子序列。重要,下面重点说</li><li>find(int start)：重置此匹配器，然后尝试查找匹配该模式、从指定索引开始的输入序列的下一个子序列。</li><li>group()：匹配成功返回的组,重要,下面重点说</li><li>start()：返回先前匹配的起始位置的索引。</li><li>end()：返回最后匹配字符的索引加一。</li><li>matches()：尝试将整个区域与模式匹配。匹配成功返回true</li><li>lookingAt()：尝试将从区域开头开始的输入序列与该模式匹配。</li><li>replaceFirst()：替换掉匹配的第一个子序列</li><li>replaceAll()：替换掉匹配的全部子序列</li><li>appendReplacement：重要，下面重点说</li><li>appendTail(StringBuffer buf)：重要，下面重点说</li><li>reset():重置匹配器,从起始位置重新开始</li><li>reset(CharSequence input):重置匹配器,放入新的待匹配的串</li></ul><p><strong>部分方法解析</strong></p><ol><li><p><strong>find()方法</strong></p><p>注意:该方法尝试查找与该模式匹配的输入序列的下一个子序列.此方法从匹配器区域的开头开始，如果该方法的前一次调用成功了,并且从那时开始匹配器没有被重置，则从以前匹配操作没有匹配的第一个字符开始</p></li></ol><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">String regex = <span class="string">"Java."</span>;</span><br><span class="line">String s = <span class="string">"Java1Java2"</span>;</span><br><span class="line">Pattern pattern = Pattern.compile(regex);</span><br><span class="line">Matcher matcher1 = pattern.matcher(s);</span><br><span class="line">matcher1.find(); <span class="comment">// 这里返回true</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 其实此时我们可以使用下面的方式来循环获取匹配得到的子串</span></span><br><span class="line"><span class="keyword">while</span>(matcher.find)&#123; <span class="comment">// 循环查找,本次查找结束了,下次如果想获得查找结果应该重新执行find()方法</span></span><br><span class="line">    System.out.println(matcher.group()); <span class="comment">// 关于group方法将在下面介绍</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 上面的方法输出:</span></span><br><span class="line">Java1</span><br><span class="line">Java2</span><br></pre></td></tr></table></figure><ol start="2"><li><p><strong>group()方法</strong></p><p><em>这里介绍下组的概念：组是用括号划分的正则表达式，可以根据组的编号来引用这个组。组号为0表示整个表达式，组号为1表示被第一对括号括起的组，依次类推，例如A(B(C))D，组0是ABCD，组1是BC，组2是C。</em></p><p><em>Matcher类提供了start()，end()，group()分别用于返回字符串的起始索引，结束索引，以及匹配到到的字符串。</em></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">String regex = <span class="string">"(Java).*(Java)"</span>;</span><br><span class="line">String s = <span class="string">"Java123Java456"</span>;</span><br><span class="line">Pattern pattern = Pattern.compile(regex);</span><br><span class="line">Matcher matcher2 = pattern.matcher(s);</span><br><span class="line">matcher2.find(); <span class="comment">// 注意,这里需要先执行find方法</span></span><br><span class="line">System.out.println(matcher2.group()); <span class="comment">// 如果find()方法执行返回true,则group()或者group(0)代表整个字符串s:Java123Java456</span></span><br><span class="line">System.out.println(matcher2.group(<span class="number">1</span>)); <span class="comment">// 输出 Java123</span></span><br><span class="line">System.out.println(matcher2.group(<span class="number">2</span>)); <span class="comment">// 输出Java456</span></span><br></pre></td></tr></table></figure></li><li><p>appendReplacement(StringBuffer sb,String replacement)方法</p><p>先从字符串中执行查找,查找到了,替换成replacement,并从开始匹配的位置处将字符串写入StringBuffer中,示例入下:</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line">String s = <span class="string">"2018-4-10 15-45-30"</span>;</span><br><span class="line">String regex = <span class="string">"-"</span>;</span><br><span class="line">Pattern pattern = Pattern.compile(regex);</span><br><span class="line">Matcher matcher = pattern.matcher(s);</span><br><span class="line">StringBuffer sb = <span class="keyword">new</span> StringBuffer();</span><br><span class="line">matcher.find();</span><br><span class="line">matcher.appendReplacement(sb, <span class="string">":"</span>);</span><br><span class="line">System.out.println(sb.toString());</span><br><span class="line">matcher.find();</span><br><span class="line">matcher.appendReplacement(sb, <span class="string">":"</span>);</span><br><span class="line">System.out.println(sb.toString());</span><br><span class="line">matcher.find();</span><br><span class="line">matcher.appendReplacement(sb, <span class="string">":"</span>);</span><br><span class="line">System.out.println(sb.toString());</span><br><span class="line"></span><br><span class="line">输出入下:</span><br><span class="line"><span class="number">2018</span>:</span><br><span class="line"><span class="number">2018</span>:<span class="number">4</span>:</span><br><span class="line"><span class="number">2018</span>:<span class="number">4</span>:<span class="number">10</span> <span class="number">15</span>:</span><br></pre></td></tr></table></figure><p>可以看到,它比String的replaceAll()或者replace()方法更加灵活</p><h2 id="正则表达式语法"><a href="#正则表达式语法" class="headerlink" title="正则表达式语法"></a>正则表达式语法</h2><p>请参考 <a href="http://www.runoob.com/java/java-regular-expressions.html" target="_blank" rel="noopener">Java 正则表达式</a></p></li></ol>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h1 id=&quot;Java中的Pattern、Matcher、常用的正则表达式&quot;&gt;&lt;a href=&quot;#Java中的Pattern、Matcher、常用的正则表达式&quot; class=&quot;headerlink&quot; title=&quot;Java中的Pattern、Matcher、常用的正则表达式&quot;&gt;
      
    
    </summary>
    
      <category term="Java" scheme="https://blueleer.github.io/categories/Java/"/>
    
    
      <category term="Java" scheme="https://blueleer.github.io/tags/Java/"/>
    
      <category term="Java正则表达式" scheme="https://blueleer.github.io/tags/Java%E6%AD%A3%E5%88%99%E8%A1%A8%E8%BE%BE%E5%BC%8F/"/>
    
  </entry>
  
  <entry>
    <title>在活动中使用菜单Menu和PopupMenu</title>
    <link href="https://blueleer.github.io/2016/11/01/%E5%9C%A8%E6%B4%BB%E5%8A%A8%E4%B8%AD%E4%BD%BF%E7%94%A8%E8%8F%9C%E5%8D%95Menu%E5%92%8CPopupMenu/"/>
    <id>https://blueleer.github.io/2016/11/01/在活动中使用菜单Menu和PopupMenu/</id>
    <published>2016-11-01T15:55:32.000Z</published>
    <updated>2018-04-06T16:05:39.468Z</updated>
    
    <content type="html"><![CDATA[<h3 id="在Activity中使用Menu和PopupMenu"><a href="#在Activity中使用Menu和PopupMenu" class="headerlink" title="在Activity中使用Menu和PopupMenu"></a>在Activity中使用Menu和PopupMenu</h3><p>流程:</p><ol><li>点击<strong>res</strong>目录新建<strong>Android resouce file</strong>文件,选择<strong>resoucetype</strong>为<strong>menu</strong>,然后可以创建如下菜单的布局:</li></ol><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">&lt;?xml version="1.0" encoding="utf-8"?&gt;</span><br><span class="line"><span class="tag">&lt;<span class="name">menu</span> <span class="attr">xmlns:android</span>=<span class="string">"http://schemas.android.com/apk/res/android"</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">item</span></span></span><br><span class="line"><span class="tag">        <span class="attr">android:id</span>=<span class="string">"@+id/refresh_item"</span></span></span><br><span class="line"><span class="tag">        <span class="attr">android:title</span>=<span class="string">"刷新"</span>/&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">item</span> <span class="attr">android:id</span>=<span class="string">"@+id/change_city"</span></span></span><br><span class="line"><span class="tag">        <span class="attr">android:title</span>=<span class="string">"选择城市"</span>/&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">menu</span>&gt;</span></span><br></pre></td></tr></table></figure><ol start="2"><li><p>然后在活动中重写<strong>onCreateOptionsMenu(Menu menu)</strong>方法:</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">onCreateOptionsMenu</span><span class="params">(Menu menu)</span> </span>&#123;</span><br><span class="line">    <span class="comment">//R.menu.menu就是menu的布局文件</span></span><br><span class="line">    getMenuInflater().inflate(R.menu.menu,menu);</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>​</p></li><li><p>然后在手机上点击”菜单”就可以弹出菜单了,该菜单是从屏幕底部弹出的.</p></li></ol><p>当然我们也可以为点击菜单上的项目注册响应事件,通过重写<strong>onOptionsItemSelected()</strong>方法:</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">onOptionsItemSelected</span><span class="params">(MenuItem item)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">switch</span>(item.getItemId())&#123;</span><br><span class="line">        <span class="keyword">case</span> R.id.refresh_item:</span><br><span class="line">            <span class="comment">//加入逻辑</span></span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">        <span class="keyword">case</span>  R.id.change_city:</span><br><span class="line">            <span class="comment">//加入逻辑</span></span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">super</span>.onOptionsItemSelected(item);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ol start="4"><li><p>有时候我们希望通过点击屏幕上自己定义的一个组件弹出一个菜单来,并且这个菜单就在这个组件的周围,那么可以这么来写(还是使用刚刚我们定义的<strong>menu</strong>布局文件):</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">Button button = (Button)findViewById(R.id.refresh);</span><br><span class="line"><span class="comment">//点击这个按钮就能弹出一个菜单来</span></span><br><span class="line">button.setOnClickListener(<span class="keyword">new</span> View.OnClickListener()&#123;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">onClick</span><span class="params">(View view)</span> </span>&#123;</span><br><span class="line">        PopupMenu popupMenu = <span class="keyword">new</span> PopupMenu(MainActivity.<span class="keyword">this</span>,view);</span><br><span class="line">        popupMenu.getMenuInflater().inflate(R.menu.menu,popupMenu.getMenu());</span><br><span class="line">        popupMenu.show();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure><p>​</p></li></ol><p>​     在刷新按钮的周围弹出了一个菜单</p><p><img src="1.jpg" alt="弹出popupMenu"></p><p>​     当然我们也可以为PopupMenu响应点击事件:</p><pre><code><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">popupMenu.setOnMenuItemClickListener(<span class="keyword">new</span> PopupMenu.OnMenuItemClickListener()  &#123;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">onMenuItemClick</span><span class="params">(MenuItem menuItem)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">switch</span>(menuItem.getId())&#123;</span><br><span class="line">            <span class="keyword">case</span> R.id.refresh_item</span><br><span class="line">                <span class="comment">//加入自己的逻辑(点击以后发生的事件)</span></span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure></code></pre>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h3 id=&quot;在Activity中使用Menu和PopupMenu&quot;&gt;&lt;a href=&quot;#在Activity中使用Menu和PopupMenu&quot; class=&quot;headerlink&quot; title=&quot;在Activity中使用Menu和PopupMenu&quot;&gt;&lt;/a&gt;在Activit
      
    
    </summary>
    
      <category term="Android" scheme="https://blueleer.github.io/categories/Android/"/>
    
    
      <category term="Android" scheme="https://blueleer.github.io/tags/Android/"/>
    
  </entry>
  
</feed>
